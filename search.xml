<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>毕业生统计</title>
      <link href="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/"/>
      <url>/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="毕业生统计">1. 毕业生统计</h1><h2 id="班委-非班委">1.1. 班委/非班委</h2><h3 id="绩点比较">1.1.1. 绩点比较</h3><ol><li>班委绩点占比，半数以上班委绩点在前40%</li></ol><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231154030637.png" alt="班委绩点占比"></p><ol><li>非班委前40% 占比不足30%</li></ol><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231153939906.png" alt="非班委绩点占比"></p><h3 id="就业情况比较">1.1.2. 就业情况比较</h3><ol><li><p>班委，班委的签约率就业率与非班委持平，保持良好的就业情况，升学率到达36%，未落实就业率仅有6%</p><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231160311646.png" alt="班委就业情况"></p></li><li><p>非班委， 非班委 签约就业人数较多，但是未落实就业率到达22%，超过专业平均水平</p></li></ol><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231155902428.png" alt="非班委就业情况"></p><h4 id="升学详情对比">1.1.2.1. 升学详情对比</h4><p>在毕业层次的顶层对比，班委与非班委都取得优秀成绩，因此，非班委同学不要气馁，应该鼓励非班委同学积极学习</p><h2 id="班委比较">1.2. 班委比较</h2><p>!<img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231165502271.png" alt="班委间比较"></p><ol><li>班长的就业较为均衡， 考研、考公、国考考公均有</li><li>团支书的国考考公人数最多，建议考公的同学竞选团支书</li><li>教学信息员升学比例最高，保研3人，考研3人</li><li>文艺委员签约就业人数最多，体现出除了专业能力，其他特长尤为重要</li><li>体育委员和宣传委员分别有2， 1人未落实就业，请体育委员和宣传委员在体育与摄影外，多注重专业学习</li></ol><h3 id="班长就业情况">1.2.1. 班长就业情况</h3><div class="table-container"><table><thead><tr><th>毕业去向</th><th>毕业具体单位或学校</th></tr></thead><tbody><tr><td>保研</td><td>西安交通大学</td></tr><tr><td>保研</td><td>浙江大学</td></tr><tr><td>考研</td><td>山东大学</td></tr><tr><td>签就业协议形式就业</td><td>国网福建省电力有限公司</td></tr><tr><td>签就业协议形式就业</td><td>军队文职</td></tr><tr><td>签就业协议形式就业</td><td>北京京东世纪贸易有限公司</td></tr><tr><td>签就业协议形式就业</td><td>一汽解放汽车有限公司</td></tr></tbody></table></div><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231170309583.png" alt="班长就业情况"></p><h3 id="团支书就业情况">1.2.2. 团支书就业情况</h3><p>团支书就业多为公考就业，如果想要走公考，建议参与团支书评选</p><div class="table-container"><table><thead><tr><th>毕业去向</th><th>毕业具体单位或学校</th></tr></thead><tbody><tr><td>国考考公</td><td>齐齐哈尔市公安局</td></tr><tr><td>签就业协议形式就业</td><td>东北大学</td></tr><tr><td>签就业协议形式就业</td><td>兴业银行股份有限公司天津分行</td></tr><tr><td>国考考公</td><td>中国共产党费县纪律检查委员会机关</td></tr><tr><td>签就业协议形式就业</td><td>比亚迪股份有限公司</td></tr><tr><td>国考考公</td><td>国家安全部门</td></tr><tr><td>考研</td><td>中国农业大学</td></tr></tbody></table></div><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231170157929.png" alt="团支书就业情况"></p><h3 id="教学信息员就业情况">1.2.3. 教学信息员就业情况</h3><div class="table-container"><table><thead><tr><th>毕业去向</th><th>毕业具体单位或学校</th></tr></thead><tbody><tr><td>考研</td><td>上海交通大学</td></tr><tr><td>签就业协议形式就业</td><td>杭州智感科技有限公司</td></tr><tr><td>保研</td><td>清华大学</td></tr><tr><td>考研</td><td>东北大学</td></tr><tr><td>保研</td><td>上海交通大学</td></tr><tr><td>考研</td><td>中国农业大学</td></tr><tr><td>保研</td><td>浙江大学</td></tr></tbody></table></div><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231170411650.png" alt="教学信息员就业信息"></p><h3 id="体育委员就业情况">1.2.4. 体育委员就业情况</h3><div class="table-container"><table><thead><tr><th>毕业去向</th><th>毕业具体单位或学校</th></tr></thead><tbody><tr><td>签就业协议形式就业</td><td>郑州宇通集团有限公司</td></tr><tr><td>签就业协议形式就业</td><td>中国联合网络通信有限公司东莞市分公司</td></tr><tr><td>未落实</td><td>未落实</td></tr><tr><td>保研</td><td>电子科技大学</td></tr><tr><td>考研</td><td>南京大学</td></tr><tr><td>考研</td><td>深圳大学</td></tr><tr><td>签就业协议形式就业</td><td>东北大学</td></tr></tbody></table></div><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231171533717.png" alt="image-20251231171533717"></p><h3 id="宣传委员就业情况">1.2.5. 宣传委员就业情况</h3><div class="table-container"><table><thead><tr><th>毕业去向</th><th>毕业具体单位或学校</th></tr></thead><tbody><tr><td>考研</td><td>电子科技大学</td></tr><tr><td>考研</td><td>东北大学（比亚迪股份有限公司解约）</td></tr><tr><td>签就业协议形式就业</td><td>东北大学</td></tr><tr><td>保研</td><td>浙江大学</td></tr><tr><td>未落实</td><td>未落实</td></tr><tr><td>未落实</td><td>未落实</td></tr><tr><td>国考考公</td><td>国家安全部门</td></tr></tbody></table></div><p><img src="/2025/12/31/%E7%A0%940/operation/%E6%AF%95%E4%B8%9A%E7%94%9F%E7%BB%9F%E8%AE%A1/image-20251231171757045.png" alt="宣传委员就业情况"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/12/28/%E7%A0%940/operation/learn_trace/base_learn/data/README/"/>
      <url>/2025/12/28/%E7%A0%940/operation/learn_trace/base_learn/data/README/</url>
      
        <content type="html"><![CDATA[<h1 id="MLApp-登录系统使用说明">1. MLApp 登录系统使用说明</h1><h2 id="文件说明">1.1. 文件说明</h2><ul><li><code>LoginApp.m</code> - 登录界面主程序</li><li><code>registerUser.m</code> - 用户注册函数</li><li><code>setup.m</code> - 初始化设置脚本</li><li><code>createLoginApp.m</code> - 启动登录界面</li></ul><h2 id="快速开始">1.2. 快速开始</h2><h3 id="方式一：运行设置脚本（推荐）">1.2.1. 方式一：运行设置脚本（推荐）</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">setup()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按提示输入用户名和密码，系统会自动创建配置文件。</p><h3 id="方式二：手动注册用户">1.2.2. 方式二：手动注册用户</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">registerUser(&#39;admin&#39;, &#39;your_password&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="方式三：使用环境变量（最安全）">1.2.3. 方式三：使用环境变量（最安全）</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">setenv(&#39;MLAPP_USERNAME&#39;, &#39;admin&#39;);setenv(&#39;MLAPP_PASSWORD&#39;, &#39;your_password&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="启动登录界面">1.3. 启动登录界面</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">app &#x3D; LoginApp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">createLoginApp()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="密码存放方案">1.4. 密码存放方案</h2><div class="table-container"><table><thead><tr><th>方案</th><th>安全等级</th><th>适用场景</th></tr></thead><tbody><tr><td>环境变量</td><td>⭐⭐⭐⭐⭐</td><td>生产环境</td></tr><tr><td>加密MAT文件</td><td>⭐⭐⭐⭐</td><td>开发/测试</td></tr></tbody></table></div><h2 id="功能特性">1.5. 功能特性</h2><ul><li>用户名/密码登录验证</li><li>记住密码功能（加密存储）</li><li>新用户注册功能</li><li>环境变量支持</li><li>SHA-256 密码哈希</li></ul><h2 id="注意事项">1.6. 注意事项</h2><ul><li>密码长度至少 6 位</li><li>credentials.mat 包含记住的密码，请妥善保管</li><li>user_config.mat 包含用户数据，请勿删除</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>matlab 面向对象</title>
      <link href="/2025/12/24/%E7%A0%940/operation/matlab-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/12/24/%E7%A0%940/operation/matlab-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="matlab-面向对象">1. matlab 面向对象</h1><blockquote><p>每个类定义在单独的.m 文件中， 文件名与类名相同</p></blockquote><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">classdef test_class     % 定义属性    properties(Access &#x3D; private)        Radius &#x3D; 1; % 默认值    end        % 定义方法    methods        % 构造函数        function obj &#x3D; test_class(r)            % nargin 内置变量， 表示输入参数个数            if nargin &gt; 0                 obj.Radius &#x3D; r;            end        end        % obj 作为第一个参数        function area &#x3D; getArea(obj)            area &#x3D; pi * (obj.Radius^2);        end        % 重载disp 方法        function disp(obj)            fprintf(&#39;Circle with radius &#x3D; %.2f \n&#39;, obj.Radius);        end    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">classdef test_inherit &lt; test_class    properties        Height &#x3D; 1;    end    methods         function obj &#x3D; test_inherit(r, h)            % 调用父类构造函数            obj@test_class(r);            if nargin &gt; 1                 obj.Height &#x3D; h;            end        end                function volume &#x3D; getVolume(obj)            volume &#x3D; obj.getArea()* obj.Height;        end    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="appdesigner">2. appdesigner</h1><h2 id="绘图">2.1. 绘图</h2><p><code>plot</code>, <code>hold</code> 都需要指定图像画布位置，即第一参数设置为<code>app.UIAxes</code></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; 1: 0.01 : 10;y &#x3D; sin(x);y1 &#x3D; cos(x);plot(app.UIAxes, x, y , &#39;LineStyle&#39;,&#39;-&#39;,&#39;Color&#39;,&#39;r&#39;);hold(app.UIAxes, &quot;on&quot;);plot(app.UIAxes, x, y1, &#39;LineStyle&#39;,&#39;-&#39;, &#39;Color&#39;,&#39;b&#39;);xlabel(app.UIAxes, &quot;时间&quot;);ylabel(app.UIAxes, &quot;幅度&quot;);title(app.UIAxes, &quot;时域分析&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="run">2.2. run</h2><p>使用’run’ 命令启动一个m 脚本</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">delete(app.UIFigure) ; % 关闭当前文件run new_app.mlapp; % 启动新的app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="uigetfile">2.3. uigetfile</h2><p>打开文件管理器，选择文件</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">[filename, pathname] &#x3D; uigetfile(&#123;&#39;*.png; *.jpg&#39; ; &#39;*.*&#39;&#125;, &#39;选择图片&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="readtable">2.4. readtable</h2><p>读取数据，返回table 类型</p><h2 id="，-（）">2.5. {} ， （）</h2><ol><li>{} 返回元素的属性值</li><li>（） 返回元素的子集</li></ol><h2 id="addpath">2.6. addpath</h2><p>在脚本中增加环境变量</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">addpath(&quot;D:\soft\&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="保存数据">2.7. 保存数据</h2><ol><li><p>assignin 数据保存在工作区中</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">assignin(&#39;base&#39;, &#39;x&#39;, x);% &#39;base&#39; 保存的工作区, 或者&#39;caller&#39;% &#39;x&#39; 导入工作区名称% x 变量名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>save 保存数据到磁盘中</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">save filename x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="使用摄像头">2.8. 使用摄像头</h2><ol><li><p>附加功能中选择下载使用webcams</p><p><img src="/2025/12/24/%E7%A0%940/operation/matlab-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20251228224632005.png" alt="image-20251228224632005"></p></li><li><p>使用webcam 调取</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; webcam ; % 默认第一个摄像头cam &#x3D; webcam(2) ; % 选择第二个摄像头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用snapshot(cam) ， 抓取一张图片</p></li><li><p>preview(cam) 显示视频</p></li></ol><blockquote><p>在调用后需要清楚cam 对象，避免影响之后调用</p><p>一般放在appdesigner 中，声明为属性， 使用析构函数删除</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yalmip使用</title>
      <link href="/2025/12/22/%E7%A0%940/operation/learn_trace/yalmip%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/12/22/%E7%A0%940/operation/learn_trace/yalmip%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="yalmip">1. yalmip</h1><h2 id="常用流程">1.1. 常用流程</h2><ol><li><p>创建变量</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x &#x3D; sdpvar(1, 2, 3, &#39;full&#39;) % 这里全部使用&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>? 为什么maltab 中’’ 与 “” 不同呢？</p></blockquote></li><li><p>优化</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">d &#x3D; optimize(Constraints, Objective, options)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>提取求解值</p><pre class="line-numbers language-y" data-language="y"><code class="language-y">xopt &#x3D; value(x);yopt &#x3D; value(y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>创建options</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ops &#x3D; sdpsettings(&#39;solver&#39;, &#39;gurobi&#39;);ops &#x3D; sdpsettings(ops, &#39;verbose&#39;, 0) ;% 追加设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="创建变量">1.2. 创建变量</h2><ol><li>sdpvar </li><li>binvar</li><li>intvar</li></ol><h2 id="优化">1.3. 优化</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">diagnostics &#x3D; optimize(Constraints, Objective, options)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="优化器">1.3.1. 优化器</h3><p>提供参数，用于调参</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">P &#x3D; optimizer(Con, Obj, Options, Parameters, WantedVariables)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Constraints">1.4. Constraints</h2><ol><li><p>单个约束</p></li><li><p>多个约束组合,使用<code>[]</code>包括</p></li><li><p>矩阵约束，使用矩阵的方式</p></li><li><p>逻辑约束</p><ol><li><p>指示约束</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">&#96;c &#x3D; implies(x &gt;0 , y&#x3D;&#x3D;1)&#96;, 如果x &gt;0 ， y 必须等于1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>互斥约束</p></li></ol><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">c_mutual &#x3D; xor(x_A &gt; 0 , x_B &gt; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>整数约束</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x_int &#x3D; intvar(1, 1);c_mod &#x3D; mod(x_int , 2) &#x3D;&#x3D; 0; % x 必须是整数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol></li></ol><h2 id="求解options">1.5. 求解options</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">options &#x3D; sdpsettings(&#39;solver&#39;, &#39;gurobi&#39;); % 指定求解器options &#x3D; sdpsettings(options, &#39;verbose&#39;, 1)% 0 静默，1 详细， 2 更详细options &#x3D; sdpsettings(options, &#39;timeout&#39;, 60) % 用s 计算optiosn &#x3D; sdpsettings(options, &#39;FeasibilityTol&#39;, 1e-6); % 可行性容忍度options &#x3D; sdpsettings(&#39;gurobi.OptimalityTol&#39;,1e-6);   % 最优性容忍度options &#x3D; sdpsettings(&#39;gurobi.MIPGap&#39;,0.01);          % MIP间隙（1%）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求解状态">1.6. 求解状态</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sol &#x3D; optimize(Constraits, Objective, options);xOpt &#x3D; value(x); % 提取x optimal_value &#x3D; value(objective); % 目标函数sol.problem % 状态sol.info % 错误信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求解状态：</p><ol><li>0 ：最优</li><li>1： 不可行</li><li>2 ： 问题无解</li><li>3： 求解超时，返回最优解</li><li>4： 内存不足</li><li>5： 用户中断</li><li>10-100：求解器错误</li></ol><h1 id="examples">2. examples</h1><h2 id="工厂排班">2.1. 工厂排班</h2><p><strong>问题描述：</strong><br>某工厂生产两种产品A和B。生产每单位A需要2小时机器时间，3小时人工时间，利润为40元；生产每单位B需要4小时机器时间，2小时人工时间，利润为50元。工厂每天最多有100小时机器时间和80小时人工时间。问如何安排生产计划使利润最大？</p><ol><li>变量： A, B 生成量</li><li>目标函数：最大化利润</li><li>约束条件： <ol><li>机器用时</li><li>人工用时</li></ol></li></ol><script type="math/tex; mode=display">max \space 40x_A + 50x_b\\s.b \space \begin{array} 2x_A + 4x_A  \leq 100 ;机器时间\\3x_A + 2 x_B \leq 80\end{array}</script><p><a href="base_learn\factory_produce.m">factory_produce</a></p><h2 id="背包问题">2.2. 背包问题</h2><p>你有一个容量为15kg的背包，有5件物品可选，每件物品有重量和价值。问如何选择物品使总价值最大，且总重量不超过15kg？</p><p>物品信息：</p><ul><li>物品1：重量2kg，价值3元，有1个</li><li>物品2：重量3kg，价值4元  ，有2个</li><li>物品3：重量4kg，价值5元， 3个</li><li>物品4：重量5kg，价值8元， 1个</li><li>物品5：重量9kg，价值10元， 1个</li></ul><ol><li><p>决策变量： $y_I$ 表示选择个数</p></li><li><p>目标函数：最大价值v</p><p>$max \space v*y$</p></li><li><p>约束条件：</p><ol><li>重量约束</li><li>个数约束</li></ol></li></ol><p>代码路径：</p><p><a href="base_learn\bag_weight.md">weight_bag</a></p><h2 id="二次规划-QP">2.3. 二次规划(QP)</h2><p><a href="base_learn\QP.m">QP matlab</a></p><h1 id="gurobi">3. gurobi</h1><h2 id="求解参数策略">3.1. 求解参数策略</h2><blockquote><p>该章节记住有这些方法即可，使用时再进行查阅，详见<a href="Qcode.md">Qcode</a></p></blockquote><ol><li>MIPFocus， 求解策略， 2= 可行解， 3= 最优性</li><li>NodeMethod， 节点松弛方法</li><li>Heuristics， 启发式搜索强度， 0-1</li><li>Threads 使用多个线程求解</li><li>ConcurrentMIP,  并发求解MIP 问题</li></ol><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% MIP策略options &#x3D; sdpsettings(&#39;gurobi.MIPFocus&#39;,2);  % 1&#x3D;侧重找到可行解，2&#x3D;侧重证明最优性options &#x3D; sdpsettings(&#39;gurobi.NodeMethod&#39;,2); % 2&#x3D;barrier方法，用于节点松弛options &#x3D; sdpsettings(&#39;gurobi.Heuristics&#39;,0.1); % 启发式搜索强度(0-1)% 并行计算options &#x3D; sdpsettings(&#39;gurobi.Threads&#39;,8); % 使用8个线程options &#x3D; sdpsettings(&#39;gurobi.ConcurrentMIP&#39;,2); % 并行MIP求解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 收敛性参数</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 精度控制options &#x3D; sdpsettings(&#39;gurobi.FeasibilityTol&#39;,1e-6); % 可行性容忍度options &#x3D; sdpsettings(&#39;gurobi.OptimalityTol&#39;,1e-6);  % 最优性容忍度options &#x3D; sdpsettings(&#39;gurobi.IntegralityTol&#39;,1e-5); % 整数容忍度% MIP间隙控制options &#x3D; sdpsettings(&#39;gurobi.MIPGap&#39;,0.01);  % 1%的相对间隙options &#x3D; sdpsettings(&#39;gurobi.MIPGapAbs&#39;,0.001); % 绝对间隙<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 内存与时间管理</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 内存控制， 与分支定界有关options &#x3D; sdpsettings(&#39;gurobi.NodefileStart&#39;,0.5); % 0.5GB后开始写节点文件options &#x3D; sdpsettings(&#39;gurobi.NodefileDir&#39;,&#39;&#x2F;tmp&#39;); % 节点文件目录% 时间控制options &#x3D; sdpsettings(&#39;gurobi.TimeLimit&#39;,300); % 300秒超时options &#x3D; sdpsettings(&#39;timeout&#39;,300); % YALMIP级别的超时<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 预处理与切割平面</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 预处理options &#x3D; sdpsettings(&#39;gurobi.Presolve&#39;,2); % 2&#x3D;激进预处理% 切割平面options &#x3D; sdpsettings(&#39;gurobi.Cuts&#39;,2); % 2&#x3D;激进切割options &#x3D; sdpsettings(&#39;gurobi.GomoryPasses&#39;,2); % Gomory切割强度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="根据参数规模调优">3.2. 根据参数规模调优</h2><ol><li><p>小规模问题： 1. 精确解</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">MIPGap &#x3D; 1e-4;TimeLimit &#x3D; 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>中等规模问题： 1. 解适度精确；2. 时间放宽</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">MIPGap &#x3D; 1e-2;TimeLimite &#x3D; 300;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>大规模问题： 1. 优先找到可行解; 2. 使用启发算法； 3. 增大解经读 ； 4. 增大求解时间</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">MIPFocus &#x3D; 1;Heuristics &#x3D; 0.5;MIPGap &#x3D; 0.05;TimeLimit &#x3D; 1200;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>约束密度调整</p><p>约束数量 超过 变量 一定程度</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">density &#x3D; n_constraits&#x2F;(n_vars^2);if density &gt; 0.1Presolve &#x3D; 2 ; % 使用激进预处理end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>MIP 问题：1. 增加线程数量 2. 使用ConcurrentMIP 优化</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">threads &#x3D; min(16, max(1, floor(nCores * 0.8)));ConcurrentMIP &#x3D; 2; % 2 中求解方案并行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h1 id="debug">4. debug</h1><h2 id="infeasible">4.1. infeasible</h2><p><code>sol == 1</code></p><h3 id="deBug-步骤">4.1.1. deBug 步骤</h3><ol><li>无目标函数，求解一次，查看是否依旧是不可行的</li><li>使用方法检测不可行的约束</li><li>适当减少部分约束</li></ol><h3 id="debug-工具">4.1.2. debug 工具</h3><h2 id="unbounded">4.2. unbounded</h2><p><code>sol == 2</code></p><ol><li>查看目标函数</li><li>人为 增加一个约束，添加合理的上界和下届</li></ol><h1 id="编程技巧">5. 编程技巧</h1><h2 id="矩阵">5.1. 矩阵</h2><p>使用循环表示矩阵相乘，替换为矩阵，对于0-1变量时，非常有效</p><p>eg : 变量两两互斥，非0 即 1</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 低效：使用嵌套循环n &#x3D; 1000;x &#x3D; sdpvar(n,1);Constraints &#x3D; [];for i &#x3D; 1:n    Constraints &#x3D; [Constraints, x(i) &gt;&#x3D; 0];    for j &#x3D; 1:n        if i ~&#x3D; j            Constraints &#x3D; [Constraints, x(i) + x(j) &lt;&#x3D; 1];        end    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$o(n^2)$个约束</p><p>使用矩阵</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sum(x) &lt;&#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>$O(1)$ 约束， 简单有效</p><ol><li><p>使用Yalmip 的check 工具</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">[infeasible_constraints, ~] &#x3D; check(Constraints)for i &#x3D; 1: length(infeasible_constraints):if infearible_constraints(i): fprintf(&quot;约束 %d 不可行 \n&quot;) fprintf(&quot;输入约束&quot;)endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用Gurobi中IIS </p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 重新求解并要求IISoptions_iis &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.IISMethod&#39;,1);sol_iis &#x3D; optimize(Constraints, Objective, options_iis);% 获取IIS信息if isfield(sol_iis.info, &#39;IIS&#39;)    fprintf(&#39;\nGurobi IIS分析结果:\n&#39;);    iis_constraints &#x3D; sol_iis.info.IIS;    for i &#x3D; 1:length(iis_constraints)        if iis_constraints(i)            fprintf(&#39;  约束 %d 属于IIS\n&#39;, i);        end    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>引入松弛变量</p><blockquote><p>? 方法原理不懂</p></blockquote><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">slack &#x3D; sdpvar(length(Constraints),1);Constraints_relaxed &#x3D; Constraints + diag(sign(slack))*slack;Objective_relaxed &#x3D; sum(abs(slack));options_relaxed &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;);sol_relaxed &#x3D; optimize(Constraints_relaxed, Objective_relaxed, options_relaxed);if sol_relaxed.problem &#x3D;&#x3D; 0    slack_values &#x3D; value(slack);    fprintf(&#39;约束松弛量:\n&#39;);    for i &#x3D; 1:length(slack_values)        if abs(slack_values(i)) &gt; 1e-6            fprintf(&#39;  约束 %d 需要松弛 %.4f\n&#39;, i, slack_values(i));        end    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>matlab</title>
      <link href="/2025/12/21/%E7%A0%940/operation/matlab/"/>
      <url>/2025/12/21/%E7%A0%940/operation/matlab/</url>
      
        <content type="html"><![CDATA[<h1 id="matlab">1. matlab</h1><h2 id="匿名函数">1.1. 匿名函数</h2><p>首先传入两个变量后，另一个变量自动绑定</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">a &#x3D; 2;b &#x3D; 5;g &#x3D; @(x) myfun(x, a, b);  % 快捷方式：自动带 a&#x3D;2, b&#x3D;5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>fcn2optimexpr()， 只能接收一个参数的函数</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 对于具有三个参数，需要使用objExpr &#x3D; fcn2optimexpr(@(x) myComplexObjective(x, a, b), x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="函数句柄">1.2. @函数句柄</h2><p>返回函数的调用地址，相当于函数指针</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/12/21/%E7%A0%940/operation/learn_trace/k2/"/>
      <url>/2025/12/21/%E7%A0%940/operation/learn_trace/k2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="第一阶段：环境搭建与认知重构（第1-3天）">0.1. 第一阶段：环境搭建与认知重构（第1-3天）</h2><h3 id="第一天：理解”优化”本质与工具链定位">0.1.1. 第一天：理解”优化”本质与工具链定位</h3><h4 id="上午（2小时）：概念认知重塑">0.1.1.1. 上午（2小时）：概念认知重塑</h4><p><strong>1.1 什么是优化问题？（从生活实例讲起）</strong></p><p>想象你在超市购物，手里有200元预算，要买10种商品。每种商品有：</p><ul><li>价格（成本）</li><li>营养价值（收益）</li><li>保质期（约束条件）</li></ul><p>目标：在预算内买到营养最高的组合，且每种商品至少买1件。</p><p><strong>这就是优化问题的三要素：</strong></p><ul><li><strong>决策变量</strong>：每种商品买多少（x₁, x₂, …, x₁₀）</li><li><strong>目标函数</strong>：最大化营养价值（或最小化成本）</li><li><strong>约束条件</strong>：总预算≤200元，每种商品≥1件</li></ul><pre class="line-numbers language-wolfram" data-language="wolfram"><code class="language-wolfram">数学表达：maximize: Σ(营养值ᵢ × xᵢ)subject to: Σ(价格ᵢ × xᵢ) ≤ 200            xᵢ ≥ 1, ∀i ∈ &#123;1,2,...,10&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>优化求解器（Gurobi）的作用就是：<strong>自动帮你找到满足所有条件的最优解，而不是让你穷举所有可能组合</strong>。</p><p><strong>1.2 工具链角色分工（保姆级比喻）</strong></p><pre class="line-numbers language-none"><code class="language-none">┌─────────────────────────────────────────────────────────┐│                    你的办公桌 (MATLAB)                  ││                                                          ││  ┌──────────────┐       ┌──────────────┐               ││  │   秘书小姐   │◄─────►│   数学苦力   │               ││  │   (YALMIP)   │ 翻译  │   (Gurobi)   │               ││  └──────────────┘       └──────────────┘               │└─────────────────────────────────────────────────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>MATLAB</strong>：你的”操作系统”。所有操作都在这里完成，负责数据预处理、结果可视化、脚本管理</li><li><strong>YALMIP</strong>：你的”智能翻译秘书”。她懂数学语言（≤, ≥, Σ），会把你的数学公式翻译成Gurobi能听懂的机器语言</li><li><strong>Gurobi</strong>：你的”超级计算苦力”。他只做一件事：快速解方程，但需要你告诉他方程长什么样</li></ul><p><strong>关键认知</strong>：<strong>千万不要跳过YALMIP直接学Gurobi！</strong> 就像你不会为了学英语直接去读莎士比亚原著，而是应该先学语法。YALMIP就是那个”语法老师”。</p><h4 id="下午（3小时）：软件安装实战">0.1.1.2. 下午（3小时）：软件安装实战</h4><p><strong>1.3 MATLAB安装与基础配置</strong></p><pre class="line-numbers language-none"><code class="language-none">【安装步骤】1. 获取安装包：   - 学校版：通过学校软件中心，使用校园邮箱注册MathWorks账号   - 试用版：官网下载R2024a&#x2F;R2024b（30天试用）   - 注意：建议使用R2021b及以上版本，对YALMIP兼容性最好2. 安装注意事项：   - 勾选&quot;MATLAB Compiler&quot;和&quot;Optimization Toolbox&quot;（虽然我们用Gurobi，但这两个工具箱有时辅助用）   - 安装路径不要有中文和空格，例如：D:\MATLAB\R2024b   - 安装后首次启动，选择&quot;激活&quot;，输入许可证或登录MathWorks账号3. 基础配置（关键！）：   &gt;&gt; cd(&#39;D:\MATLAB\R2024b\bin&#39;)  % 进入安装目录   &gt;&gt; matlab -register            % 注册环境变量（Windows）      % 设置默认工作路径（避免每次打开都在C盘）   &gt;&gt; userpath(&#39;D:\MyMATLABProjects&#39;)   &gt;&gt; savepath<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.4 Gurobi学术许可证申请（全程图文）</strong></p><p>这是最容易卡壳的环节，务必按步骤操作：</p><pre class="line-numbers language-none"><code class="language-none">【申请流程（学生版）】1. 访问 Gurobi 官网：https:&#x2F;&#x2F;www.gurobi.com&#x2F;2. 点击 &quot;Free Trial&quot; → &quot;Academic Licenses&quot;3. 选择 &quot;Gurobi Academic License&quot;（不是Gurobi Cloud！）4. 填写信息：   - First Name: 你的名（拼音，如 Xiaoming）   - Last Name: 你的姓（拼音，如 Zhang）   - Email: 教育网邮箱（关键！必须是 .edu.cn 或学校邮箱）   - Institution: 你的大学全称5. 提交后，邮箱会收到验证邮件，点击链接6. 登录Gurobi账户，进入 &quot;Downloads&quot; 页面7. 下载对应版本（建议 11.0.3 及以上）8. 安装时勾选 &quot;Install for all users&quot;（避免权限问题）【激活许可证】1. 安装完成后，打开 &quot;Gurobi License Center&quot;2. 复制你的许可证密钥（格式：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx）3. 打开MATLAB，输入：   &gt;&gt; grbgetkey xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx4. 等待激活成功提示【验证安装】在MATLAB命令行输入：&gt;&gt; g &#x3D; gurobi()如果显示 &quot;Gurobi Optimizer version 11.0.3...&quot;，说明安装成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.5 YALMIP安装（最简单但最重要）</strong></p><pre class="line-numbers language-none"><code class="language-none">【安装步骤】1. 访问 YALMIP 官网：http:&#x2F;&#x2F;yalmip.github.io&#x2F;2. 点击 &quot;Download&quot; → &quot;Download ZIP&quot;3. 解压到：D:\MATLAB\R2024b\toolbox\yalmip（推荐路径）4. 在MATLAB中添加路径：   &gt;&gt; addpath(&#39;D:\MATLAB\R2024b\toolbox\yalmip&#39;)   &gt;&gt; savepath  % 永久保存路径【验证安装】在MATLAB命令行输入：&gt;&gt; yalmiptest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>预期输出应包含：</strong><br><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|       Test|   CPLEX|   GUROBI|   MOSEK|   SDPT3|   SEDUMI|   FMINCON|++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++|    Linear |    OK  |    OK   |   OK   |   OK   |   OK    |    OK    ||      SOCP |    OK  |    OK   |   OK   |   OK   |   OK    |    OK    ||   InfeasLP|    OK  |    OK   |   OK   |   OK   |   OK    |    OK    |++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>关键</strong>：Gurobi栏必须显示”OK”，否则需检查许可证或路径。</p><h4 id="晚上（1小时）：环境测试与第一个程序">0.1.1.3. 晚上（1小时）：环境测试与第一个程序</h4><p><strong>1.6 运行你的第一个优化问题</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 文件名：test_optimization.m% 问题描述：minimize x^2 + y^2，满足 x + y &#x3D; 1clear all; clc;  % 清除变量和命令行% 步骤1：定义变量x &#x3D; sdpvar(1,1);  % 实数变量xy &#x3D; sdpvar(1,1);  % 实数变量y% 步骤2：设置约束Constraints &#x3D; [x + y &#x3D;&#x3D; 1];  % 注意：&#x3D;&#x3D; 表示等式约束% 步骤3：设置目标函数Objective &#x3D; x^2 + y^2;  % 最小化平方和% 步骤4：求解设置options &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;verbose&#39;,1);  % 显示求解过程% 步骤5：求解diary(&#39;solver_log.txt&#39;);  % 记录日志result &#x3D; optimize(Constraints, Objective, options);diary off;  % 关闭日志% 步骤6：提取结果if result.problem &#x3D;&#x3D; 0  % 求解成功    x_opt &#x3D; value(x);    y_opt &#x3D; value(y);    fprintf(&#39;最优解: x &#x3D; %.4f, y &#x3D; %.4f\n&#39;, x_opt, y_opt);    fprintf(&#39;最优目标值: %.4f\n&#39;, value(Objective));else    fprintf(&#39;求解失败，错误代码: %d\n&#39;, result.problem);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常见问题排查：</strong></p><ul><li>错误”Undefined function ‘sdpvar’”：YALMIP路径未添加成功，重新addpath</li><li>错误”Gurobi license error”：许可证未激活或过期，重新运行grbgetkey</li><li>错误”Infeasible model”：约束矛盾，检查==和&lt;=的使用</li></ul><hr><h3 id="第二天：数学基础补全与YALMIP核心语法">0.1.2. 第二天：数学基础补全与YALMIP核心语法</h3><h4 id="上午（2-5小时）：优化问题的数学分类">0.1.2.1. 上午（2.5小时）：优化问题的数学分类</h4><p><strong>2.1 问题的分类体系（必须理解）</strong></p><pre class="line-numbers language-none"><code class="language-none">优化问题分类树：               优化问题                 │        ┌────────┴────────┐    线性规划(LP)        非线性规划                         │              ┌──────────┴──────────┐         二次规划(QP)            一般非线性(NLP)              │        ┌─────┴─────┐    凸QP          非凸QP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>详细解释（逐项拆解）：</strong></p><p><strong>① 线性规划 (LP - Linear Programming)</strong></p><ul><li><strong>数学形式</strong>：所有表达式都是线性的（变量的1次方）<pre class="line-numbers language-wolfram" data-language="wolfram"><code class="language-wolfram">minimize: c₁x₁ + c₂x₂ + ... + cₙxₙsubject to: a₁₁x₁ + a₁₂x₂ + ... + a₁ₙxₙ ≤ b₁            a₂₁x₁ + a₂₂x₂ + ... + a₂ₙxₙ ≤ b₂            xᵢ ≥ 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>YALMIP特点</strong>：使用<code>sdpvar</code>定义变量，目标函数和约束都是线性表达式</li><li><strong>求解难度</strong>：★☆☆☆☆（Gurobi可在毫秒级求解百万变量问题）</li></ul><p><strong>② 混合整数线性规划 (MILP - Mixed Integer LP)</strong></p><ul><li><strong>数学形式</strong>：LP + 部分变量必须是整数（通常是0或1）<pre class="line-numbers language-wolfram" data-language="wolfram"><code class="language-wolfram">xᵢ ∈ &#123;0,1&#125; 表示&quot;是否选择i&quot;，或 xᵢ ∈ ℤ 表示&quot;整数个&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><strong>YALMIP特点</strong>：使用<code>binvar</code>或<code>intvar</code>定义变量</li><li><strong>求解难度</strong>：★★★★☆（NP-hard问题，Gurobi的最强项）</li></ul><p><strong>③ 二次规划 (QP - Quadratic Programming)</strong></p><ul><li><strong>数学形式</strong>：目标函数是二次的，约束是线性的<pre class="line-numbers language-wolfram" data-language="wolfram"><code class="language-wolfram">minimize: xᵀQx + cᵀx  (Q是二次项系数矩阵)subject to: Ax ≤ b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><strong>YALMIP特点</strong>：目标函数可写为<code>x&#39;*Q*x + c&#39;*x</code></li><li><strong>求解难度</strong>：★★★☆☆（凸QP易解，非凸QP极难）</li></ul><p><strong>④ 二阶锥规划 (SOCP - Second Order Cone Programming)</strong></p><ul><li><strong>数学形式</strong>：包含范数约束<pre class="line-numbers language-wolfram" data-language="wolfram"><code class="language-wolfram">||Ax + b||₂ ≤ cᵀx + d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><strong>YALMIP特点</strong>：可写为<code>norm(A*x + b) &lt;= c&#39;*x + d</code></li><li><strong>求解难度</strong>：★★★☆☆</li></ul><p><strong>2.2 YALMIP核心语法深度解析</strong></p><p><strong>语法1：定义变量（sdpvar/binvar/intvar）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 1. 实数变量（sdpvar）x &#x3D; sdpvar(1);              % 标量实数变量x_vec &#x3D; sdpvar(3,1);        % 3×1列向量 [x1;x2;x3]x_mat &#x3D; sdpvar(2,3);        % 2×3矩阵（每个元素都是变量）% 2. 二元变量（binvar）- 只能取0或1y &#x3D; binvar(1);              % 开关变量y_vec &#x3D; binvar(5,1);        % 5个开关的组合% 3. 整数变量（intvar）z &#x3D; intvar(1);              % 整数变量（如购买数量）z_mat &#x3D; intvar(3,3);        % 3×3整数矩阵% 4. 特殊形式：对称矩阵变量（用于SDP问题）X &#x3D; sdpvar(3,3,&#39;symmetric&#39;); % 3×3对称矩阵，X &#x3D; X&#39;% 5. 多维变量：决策变量是三维张量（高阶问题）W &#x3D; sdpvar([2,3,4]);        % 2×3×4三维变量数组% 重要技巧：变量命名规范P_gen &#x3D; sdpvar(10,1);       % 发电机功率（10台机组）u_on &#x3D; binvar(10,1);        % 机组启停状态（1&#x3D;运行）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法2：构建约束（Constraints）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 方式1：逐个添加（适合小型问题）C1 &#x3D; [x &gt;&#x3D; 0];              % 单个约束C2 &#x3D; [x + y &lt;&#x3D; 10];         % 线性约束C &#x3D; [C1, C2];               % 约束集合% 方式2：批量添加（推荐，效率高）n &#x3D; 100;x &#x3D; sdpvar(n,1);A &#x3D; randn(50,n);  b &#x3D; rand(50,1);C &#x3D; [A*x &lt;&#x3D; b, x &gt;&#x3D; 0];   % 一次性添加50个约束% 方式3：逻辑约束（需要最新版YALMIP）y &#x3D; binvar(1);C &#x3D; [implies(y&#x3D;&#x3D;1, x&gt;&#x3D;5)]; % 如果y&#x3D;1，则x必须≥5% 方式4：绝对值约束（自动转化为线性约束）C &#x3D; [abs(x) &lt;&#x3D; 5];          % 等价于 -5 &lt;&#x3D; x &lt;&#x3D; 5% 方式5：分段约束（分段线性）C &#x3D; [-5 &lt;&#x3D; x &lt;&#x3D; 5, -3 &lt;&#x3D; y &lt;&#x3D; 3];% 常见错误示例：% 错误1：使用等号赋值约束C &#x3D; [x &#x3D; 5];  % 错误！必须用 &#x3D;&#x3D; % 错误2：未初始化的约束数组C &#x3D; [];  % 正确做法：先初始化为空数组for i &#x3D; 1:10    C &#x3D; [C, x(i) &lt;&#x3D; i];  % 逐个添加end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法3：设置目标函数（Objective）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 类型1：最小化（最常用）obj &#x3D; c&#39;*x;                 % 线性目标obj &#x3D; x&#39;*Q*x + c&#39;*x;        % 二次目标obj &#x3D; sum(x.^2);            % 平方和% 类型2：最大化obj &#x3D; -c&#39;*x;                % 最大化c&#39;*x 等价于 最小化 -c&#39;*x% 或在求解时指定：ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;solvefor&#39;,&#39;max&#39;);% 类型3：多目标（加权和）obj1 &#x3D; c1&#39;*x;  obj2 &#x3D; c2&#39;*x;weights &#x3D; [0.7, 0.3];obj &#x3D; weights(1)*obj1 + weights(2)*obj2;% 重要：目标函数必须是标量obj &#x3D; sum(x);               % 正确，标量obj &#x3D; x;                    % 错误，当x是向量时，这是向量目标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语法4：求解与结果提取（optimize &amp; value）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 基础求解ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;);optimize(C, obj, ops);      % 最小化objoptimize(C, -obj, ops);     % 最大化obj% 高级设置ops &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...        % 指定求解器    &#39;verbose&#39;,1,...              % 显示求解过程    &#39;debug&#39;,1,...                % 开启调试模式    &#39;saveinput&#39;,&#39;model.mps&#39;);    % 保存模型到文件% 结果诊断result &#x3D; optimize(C, obj, ops);disp(result);  % 显示求解信息% result.problem 取值含义：%   0: 求解成功%   1: 问题无可行解（约束矛盾）%   2: 问题无界（目标函数可无限优化）%   3: 达到迭代限制%   4: 求解器错误% 提取结果if result.problem &#x3D;&#x3D; 0    x_opt &#x3D; value(x);               % 提取最优解    obj_opt &#x3D; value(obj);           % 提取最优目标值    dual_opt &#x3D; dual(C&#123;1&#125;);          % 提取约束的对偶变量（灵敏度分析）        % 格式化输出    fprintf(&#39;最优目标值: %.4f\n&#39;, obj_opt);    disp(&#39;最优解:&#39;);    disp(x_opt);else    % 错误处理    switch result.problem        case 1            error(&#39;模型无可行解，请检查约束条件！&#39;);        case 2            error(&#39;模型无界，请检查目标函数和约束！&#39;);        otherwise            error(&#39;求解失败，错误代码: %d&#39;, result.problem);    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="下午（2小时）：YALMIP调试技巧与常见错误">0.1.2.2. 下午（2小时）：YALMIP调试技巧与常见错误</h4><p><strong>2.3 调试工具箱</strong></p><p>你的问题非常好！你提供的代码片段反映了你在使用 <strong>YALMIP</strong> 进行建模和调试，但其中确实 <strong>混入了一些非 YALMIP 的函数或用法错误</strong>。下面我将：</p><ol><li><strong>逐条分析你例子中的问题</strong>；</li><li><strong>系统介绍 YALMIP 正确的调试方法</strong>；</li><li><strong>提供修正后的可运行示例</strong>。</li></ol><hr><h3 id="一、你例子中的问题分析">0.1.3. 一、你例子中的问题分析</h3><h4 id="❌-analyze-C">0.1.3.1. ❌ analyze(C)</h4><ul><li><strong>问题</strong>：YALMIP <strong>没有</strong>名为 <code>analyze</code> 的函数。</li><li><strong>正确做法</strong>：可用 <code>sdisplay(C)</code> 查看约束表达式，或用 <code>depends(C)</code> 查看涉及的变量，但 <strong>没有一键显示变量数、约束数、问题类型的函数</strong>。</li><li>若想查看模型结构，推荐使用：<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 查看约束内容sdisplay(C)% 查看所有变量all_vars &#x3D; allvariables(C, obj);  % obj 是目标函数disp([&#39;Number of variables: &#39;, num2str(length(all_vars))]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="❌-assign-x-5-check-C">0.1.3.2. ❌ assign(x,5); check(C)</h4><ul><li><strong>问题 1</strong>：你定义的是 <code>n = binvar(10...</code>，但后面用 <code>assign(x,5)</code>，变量名不一致（<code>x</code> 未定义）。</li><li><strong>问题 2</strong>：<code>check</code> 不是 YALMIP 函数。</li><li><strong>正确做法</strong>：<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">assign(n, some_binary_vector);  % 必须是 0&#x2F;1 向量，长度1000value(C)  % 返回每个约束的数值（如 sum(n) &lt;&#x3D; 500 的左边值）% 检查是否满足：所有 value(C) &lt;&#x3D; 0（因为 YALMIP 把约束表示为 &lt;&#x3D; 0 形式）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="❌-feasibility-optimize-C-ops">0.1.3.3. ❌ feasibility = optimize(C,[],ops);</h4><ul><li><strong>语法问题</strong>：YALMIP 的 <code>optimize</code> <strong>不能接受空目标（[]）</strong>。</li><li><strong>正确做法</strong>：使用 <code>0</code> 作为目标（常数）：<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">feasibility &#x3D; optimize(C, 0, ops);  % 仅求可行解<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="❌-disp-value-obj-但-obj-未定义">0.1.3.4. ❌ disp(value(obj)); 但 obj 未定义</h4><ul><li>在工具1和工具4中你都没有定义 <code>obj</code>，但工具5却用了它。</li><li>这会导致运行错误。</li></ul><h4 id="❌-saveinput-参数拼写错误">0.1.3.5. ❌ saveinput 参数拼写错误</h4><ul><li>正确参数是 <code>&#39;savesolverinput&#39;</code> 或 <code>&#39;saveduals&#39;</code>，但 <strong>YALMIP 没有 <code>&#39;saveinput&#39;</code></strong>。</li><li>若想导出 <code>.lp</code> 文件，应使用：<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;, &#39;savesolverinput&#39;, &#39;debug.lp&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>或更推荐用：<pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">export(C, obj, &#39;debug.lp&#39;);  % 直接导出模型，不求解<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h3 id="二、YALMIP-正确的调试方法（系统总结）">0.1.4. 二、YALMIP 正确的调试方法（系统总结）</h3><h4 id="✅-1-检查模型结构">0.1.4.1. ✅ 1. 检查模型结构</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">n &#x3D; binvar(1000,1);C &#x3D; [sum(n) &lt;&#x3D; 500];obj &#x3D; sum(n);  % 示例目标% 查看约束表达式sdisplay(C)% 查看所有变量vars &#x3D; allvariables(C, obj);fprintf(&#39;变量数量: %d (应为1000)\n&#39;, length(vars));% 查看问题是否为混合整数is_mip &#x3D; any([vars(:).binvar]) || any([vars(:).intvar]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="✅-2-导出模型为-LP-MPS-文件">0.1.4.2. ✅ 2. 导出模型为 LP/MPS 文件</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">export(C, obj, &#39;model.lp&#39;);  % 不求解，仅导出% 然后用文本编辑器打开 model.lp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="✅-3-手动赋值并验证约束">0.1.4.3. ✅ 3. 手动赋值并验证约束</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 构造一个可行解：前500个为1，其余为0test_val &#x3D; [ones(500,1); zeros(500,1)];assign(n, test_val);con_vals &#x3D; value(C);  % 例如返回 -1（表示 sum(n)-500 &#x3D; -1 &lt;&#x3D; 0）fprintf(&#39;约束值: %.2f (应 &lt;&#x3D; 0)\n&#39;, con_vals);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>⚠️ 注意：<code>assign</code> 只用于调试，<strong>不会影响 optimize 的求解</strong>。求解时 YALMIP 会忽略手动赋值。</p></blockquote><h4 id="✅-4-仅求可行解（Feasibility-Check）">0.1.4.4. ✅ 4. 仅求可行解（Feasibility Check）</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ops &#x3D; sdpsettings(&#39;verbose&#39;, 1);  % 显示求解器输出feas &#x3D; optimize(C, 0, ops);       % 目标为 0if feas.problem &#x3D;&#x3D; 0    disp(&#39;找到可行解&#39;);else    disp(&#39;问题不可行&#39;);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="✅-5-检查目标函数值（在某赋值下）">0.1.4.5. ✅ 5. 检查目标函数值（在某赋值下）</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">assign(n, test_val);obj_val &#x3D; value(obj);disp([&#39;目标值: &#39;, num2str(obj_val)]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="✅-6-查看求解器返回信息">0.1.4.6. ✅ 6. 查看求解器返回信息</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">sol &#x3D; optimize(C, obj, ops);if sol.problem ~&#x3D; 0    disp([&#39;求解失败，错误代码: &#39;, num2str(sol.problem)]);    % 常见：1&#x3D;不可行，2&#x3D;无界，3&#x3D;求解失败else    optimal_n &#x3D; value(n);    optimal_obj &#x3D; value(obj);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="✅-7-使用-spy-查看稀疏结构（对大型问题）">0.1.4.7. ✅ 7. 使用 spy 查看稀疏结构（对大型问题）</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 查看约束矩阵结构（需先构造内部模型）diagnostic &#x3D; optimize(C, obj, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;debug&#39;,1));% 或使用 internal model[F, f] &#x3D; model(C, obj);  % 不推荐直接用，但可用于分析<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="三、修正后的完整示例">0.1.5. 三、修正后的完整示例</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 定义变量n &#x3D; binvar(1000, 1);% 约束C &#x3D; [sum(n) &lt;&#x3D; 500];% 目标（假设最小化 sum(n)）obj &#x3D; sum(n);% 1. 检查模型fprintf(&#39;变量数: %d\n&#39;, length(allvariables(C, obj)));sdisplay(C)% 2. 导出模型export(C, obj, &#39;debug.lp&#39;);% 3. 可行性检查ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;verbose&#39;,0);feas &#x3D; optimize(C, 0, ops);if feas.problem &#x3D;&#x3D; 0    disp(&#39;模型可行&#39;);else    disp(&#39;模型不可行！&#39;);end% 4. 手动赋值验证assign(n, [ones(300,1); zeros(700,1)]);con_val &#x3D; value(C);obj_val &#x3D; value(obj);fprintf(&#39;手动赋值下：约束值&#x3D;%.1f (&lt;&#x3D;0?), 目标值&#x3D;%.1f\n&#39;, con_val, obj_val);% 5. 正常求解sol &#x3D; optimize(C, obj, ops);if sol.problem &#x3D;&#x3D; 0    fprintf(&#39;最优目标: %.1f\n&#39;, value(obj));else    error(&#39;求解失败&#39;);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="总结">0.1.6. 总结</h3><ul><li><code>analyze</code>, <code>check</code> 不是 YALMIP 函数；</li><li>空目标 <code>[]</code> 应替换为 <code>0</code>；</li><li>变量名要一致（你用了 <code>n</code> 但赋值 <code>x</code>）；</li><li>使用 <code>assign</code> + <code>value</code> 是调试赋值的有效方法；</li><li>用 <code>export</code> 导出 <code>.lp</code> 文件，比 <code>saveinput</code> 更可靠；</li><li>始终检查 <code>sol.problem</code> 判断求解状态。</li></ul><p>如果你有具体的模型不可行、求解慢、结果异常等问题，也可以贴出来，我可以帮你进一步诊断。</p><p><strong>2.4 十个新手必犯错误与解决方案</strong></p><div class="table-container"><table><thead><tr><th>错误现象</th><th>原因分析</th><th>解决方案</th></tr></thead><tbody><tr><td><code>Undefined function &#39;sdpvar&#39;</code></td><td>YALMIP路径未添加</td><td><code>addpath(&#39;.../yalmip&#39;); savepath</code></td></tr><tr><td><code>Gurobi license error 10009</code></td><td>学术许可证未激活</td><td>重新运行<code>grbgetkey</code>，检查系统时间</td></tr><tr><td><code>Model is infeasible</code></td><td>约束矛盾</td><td>用<code>relax(C)</code>或逐个注释约束排查</td></tr><tr><td><code>Matrix dimensions must agree</code></td><td>矩阵维度不匹配</td><td>用<code>size()</code>检查变量和系数矩阵维度</td></tr><tr><td><code>Objective must be scalar</code></td><td>目标函数是向量</td><td>使用<code>sum()</code>或<code>square_pos()</code>转换</td></tr><tr><td><code>Cannot convert sdpvar to double</code></td><td>在optimize前使用value()</td><td>只在求解后使用value()提取结果</td></tr><tr><td><code>Solver not found</code></td><td>Gurobi未正确安装</td><td>运行<code>gurobi_setup</code>，检查MATLAB路径</td></tr><tr><td><code>Out of memory</code></td><td>问题规模太大</td><td>使用<code>sparse()</code>创建稀疏矩阵</td></tr><tr><td><code>Undefined operator &#39;*&#39;</code></td><td>非线性项错误</td><td>检查二次项是否写成<code>x&#39;*Q*x</code>形式</td></tr><tr><td><code>Warning: Solver not applicable</code></td><td>问题类型与求解器不匹配</td><td>检查是否是MILP却用了不支持整数求解器</td></tr></tbody></table></div><hr><h3 id="第三天：问题类型实战与参数调优">0.1.7. 第三天：问题类型实战与参数调优</h3><h4 id="上午（2-5小时）：参数调优详解">0.1.7.1. 上午（2.5小时）：参数调优详解</h4><p><strong>3.1 Gurobi参数体系（性能调优关键）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 参数设置结构ops &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;gurobi.MIPGap&#39;,0.01,...        % MIP间隙容忍度（1%）    &#39;gurobi.TimeLimit&#39;,3600,...     % 时间限制（秒）    &#39;gurobi.Threads&#39;,8,...          % 使用CPU核数    &#39;gurobi.OutputFlag&#39;,1,...       % 显示迭代过程    &#39;gurobi.Heuristics&#39;,0.5,...     % 启发式算法强度    &#39;gurobi.CutPasses&#39;,2,...        % 割平面法迭代次数    &#39;gurobi.Presolve&#39;,2,...         % 预求解级别（0-2）    &#39;gurobi.Method&#39;,-1,...          % 算法选择（-1&#x3D;自动）    &#39;gurobi.LogFile&#39;,&#39;gurobi.log&#39;);% 日志文件% 常用参数组合模板：% 模板1：快速可行解（适合初次运行）ops_fast &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;gurobi.MIPFocus&#39;,1,...         % 重点找可行解    &#39;gurobi.Heuristics&#39;,0.8,...     % 加强启发式    &#39;gurobi.TimeLimit&#39;,300);        % 5分钟上限% 模板2：精确最优解（适合最终求解）ops_accurate &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;gurobi.MIPGap&#39;,0.001,...       % 0.1%精度    &#39;gurobi.MIPFocus&#39;,2,...         % 重点优化界    &#39;gurobi.Cuts&#39;,3,...             % 激进割平面    &#39;gurobi.NodeMethod&#39;,2);         % 节点用对偶单纯形% 模板3：大规模问题（内存受限）ops_large &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;gurobi.Threads&#39;,4,...          % 限制线程数    &#39;gurobi.NodefileStart&#39;,0.5,...  % 内存占用50%时转硬盘    &#39;gurobi.Method&#39;,2,...           % 使用内点法    &#39;gurobi.BarConvTol&#39;,1e-4);     % 降低精度换速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.2 参数调优案例：背包问题性能对比</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 问题：100个物品中选择，价值最大化n &#x3D; 100;value &#x3D; rand(n,1)*100;weight &#x3D; rand(n,1)*50;capacity &#x3D; 1000;% 定义变量x &#x3D; binvar(n,1);% 约束C &#x3D; [sum(weight.*x) &lt;&#x3D; capacity];% 目标obj &#x3D; -value&#39;*x;  % 最大化价值% 测试不同参数param_sets &#x3D; &#123;    &#123;&#39;MIPGap&#39;,0.01,&#39;Threads&#39;,4&#125;;    &#123;&#39;MIPGap&#39;,0.05,&#39;Heuristics&#39;,0.8&#125;;    &#123;&#39;MIPGap&#39;,0.001,&#39;Cuts&#39;,3,&#39;MIPFocus&#39;,2&#125;;&#125;;for i &#x3D; 1:length(param_sets)    fprintf(&#39;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 参数组合 %d &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#39;, i);    ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,...        param_sets&#123;i&#125;&#123;:&#125;,&#39;verbose&#39;,1,&#39;savesolveroutput&#39;,1);        tic;    result &#x3D; optimize(C, obj, ops);    time &#x3D; toc;        if result.problem &#x3D;&#x3D; 0        fprintf(&#39;求解时间: %.2f 秒\n&#39;, time);        fprintf(&#39;目标值: %.2f\n&#39;, -value(value(x)));        fprintf(&#39;节点数: %d\n&#39;, result.solveroutput.IterCount);    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="下午（2-5小时）：第一阶段总结与实战检验">0.1.7.2. 下午（2.5小时）：第一阶段总结与实战检验</h4><p><strong>3.3 第一阶段综合测试题</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 任务：生产排程问题% 工厂生产A、B两种产品，需要经过机器M1、M2% 数据：%  - 产品A利润：30元&#x2F;件，M1耗时2h，M2耗时3h%  - 产品B利润：50元&#x2F;件，M1耗时4h，M2耗时2h%  - M1可用时间：120h&#x2F;周，M2可用时间：100h&#x2F;周%  - 产品A最大销量：25件&#x2F;周% 求：利润最大的生产方案% 请完成以下代码（填空）：% 1. 定义变量x_A &#x3D; ______(1,1);  % 产品A产量x_B &#x3D; ______(1,1);  % 产品B产量% 2. 约束条件C &#x3D; [2*x_A + 4*x_B &lt;&#x3D; ______,  % M1时间约束     3*x_A + 2*x_B &lt;&#x3D; ______,  % M2时间约束     ______ &lt;&#x3D; 25,             % 销量约束     x_A &gt;&#x3D; 0, x_B &gt;&#x3D; 0];% 3. 目标函数Profit &#x3D; ______*x_A + ______*x_B;% 4. 求解ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;);result &#x3D; optimize(C, -Profit, ops);  % 最大化利润% 5. 结果输出if result.problem &#x3D;&#x3D; ____    fprintf(&#39;最优生产：A&#x3D;%.0f件, B&#x3D;%.0f件\n&#39;, ______, ______);    fprintf(&#39;最大利润：%.0f元\n&#39;, ______);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>答案与解析：</strong><br><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 答案：x_A &#x3D; sdpvar(1,1);x_B &#x3D; sdpvar(1,1);C &#x3D; [2*x_A + 4*x_B &lt;&#x3D; 120,     3*x_A + 2*x_B &lt;&#x3D; 100,     x_A &lt;&#x3D; 25,     x_A &gt;&#x3D; 0, x_B &gt;&#x3D; 0];Profit &#x3D; 30*x_A + 50*x_B;result &#x3D; optimize(C, -Profit, ops);if result.problem &#x3D;&#x3D; 0    fprintf(&#39;最优生产：A&#x3D;%.0f件, B&#x3D;%.0f件\n&#39;, value(x_A), value(x_B));    fprintf(&#39;最大利润：%.0f元\n&#39;, value(Profit));end% 最优解：A&#x3D;20件, B&#x3D;20件, 利润&#x3D;1600元<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><strong>3.4 第一阶段学习检查清单</strong></p><ul><li>[ ] 能独立安装MATLAB、Gurobi、YALMIP</li><li>[ ] 运行yalmiptest显示Gurobi为OK</li><li>[ ] 理解sdpvar/binvar/intvar的区别</li><li>[ ] 能写出至少3种约束条件</li><li>[ ] 会设置目标函数（最小化和最大化）</li><li>[ ] 会调用optimize并提取value</li><li>[ ] 能读懂Gurobi求解日志</li><li>[ ] 遇到”Infeasible”知道如何排查</li></ul><hr><h2 id="第二阶段：经典模型实战（第2周）">0.2. 第二阶段：经典模型实战（第2周）</h2><h3 id="第4天：线性规划（LP）深度实战">0.2.1. 第4天：线性规划（LP）深度实战</h3><h4 id="上午（3小时）：线性规划理论体系">0.2.1.1. 上午（3小时）：线性规划理论体系</h4><p><strong>4.1 线性规划标准形式与转换</strong></p><pre class="line-numbers language-wolfram" data-language="wolfram"><code class="language-wolfram">标准形式：minimize    cᵀxsubject to  Ax &#x3D; b            x ≥ 0实际问题的转换技巧：1. 不等式转等式：添加松弛变量   aᵢᵀx ≤ bᵢ   →   aᵢᵀx + sᵢ &#x3D; bᵢ, sᵢ ≥ 0   2. 自由变量处理：x无约束 → x &#x3D; x⁺ - x⁻, x⁺,x⁻ ≥ 0   3. 最大化转最小化：   max cᵀx  →  min -cᵀx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.2 生产排程问题完整案例</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 问题描述：% 某工厂生产4种产品(P1-P4)，使用3种原材料(R1-R3)% 数据：% 利润向量（万元&#x2F;吨）：[5, 8, 6, 7]% 原材料消耗矩阵（吨原材料&#x2F;吨产品）：%        P1  P2  P3  P4% R1     2   3   1   2% R2     1   2   3   1% R3     3   1   2   3% 原材料可用量（吨）：R1&#x3D;150, R2&#x3D;180, R3&#x3D;200% 市场需求上限（吨）：P1&#x3D;30, P2&#x3D;40, P3&#x3D;35, P4&#x3D;25% MATLAB实现（工业级代码）：%% 第一步：数据准备（通常从Excel读取）profit &#x3D; [5; 8; 6; 7];  % 利润向量A &#x3D; [2 3 1 2;          % 原材料消耗矩阵     1 2 3 1;     3 1 2 3];b &#x3D; [150; 180; 200];    % 原材料上限demand &#x3D; [30; 40; 35; 25]; % 市场需求%% 第二步：定义决策变量x &#x3D; sdpvar(4,1);  % x(i)表示产品i的产量%% 第三步：构建约束条件（矩阵化风格）Constraints &#x3D; [    A*x &lt;&#x3D; b,        % 原材料约束（3个约束，一行代码）    x &gt;&#x3D; 0,          % 非负约束    x &lt;&#x3D; demand      % 市场需求约束];%% 第四步：设置目标函数（最大化利润）Objective &#x3D; -profit&#39;*x;  % 负号因为YALMIP默认最小化%% 第五步：求解设置（工业级参数）ops &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;verbose&#39;,1,...    &#39;gurobi.Method&#39;,0,...         % 自动选择算法    &#39;gurobi.FeasibilityTol&#39;,1e-6,... % 可行性容差    &#39;gurobi.OptimalityTol&#39;,1e-6);   % 最优性容差%% 第六步：求解与结果输出result &#x3D; optimize(Constraints, Objective, ops);%% 第七步：结果分析与可视化if result.problem &#x3D;&#x3D; 0    x_opt &#x3D; value(x);    profit_opt &#x3D; -value(Objective);        % 创建结果表格    fprintf(&#39;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 生产排程最优方案 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#39;);    fprintf(&#39;%-10s %-15s %-15s\n&#39;, &#39;产品&#39;, &#39;产量(吨)&#39;, &#39;利润(万元)&#39;);    fprintf(&#39;----------------------------------------\n&#39;);    for i &#x3D; 1:4        fprintf(&#39;%-10s %-15.2f %-15.2f\n&#39;, [&#39;P&#39;,num2str(i)], x_opt(i), profit(i)*x_opt(i));    end    fprintf(&#39;----------------------------------------\n&#39;);    fprintf(&#39;总利润: %.2f 万元\n&#39;, profit_opt);        % 可视化    figure;    subplot(2,1,1);    bar(x_opt);    set(gca,&#39;xticklabel&#39;,&#123;&#39;P1&#39;,&#39;P2&#39;,&#39;P3&#39;,&#39;P4&#39;&#125;);    title(&#39;最优生产方案&#39;);    ylabel(&#39;产量(吨)&#39;);        subplot(2,1,2);    pie(x_opt, &#123;&#39;P1&#39;,&#39;P2&#39;,&#39;P3&#39;,&#39;P4&#39;&#125;);    title(&#39;产量分布&#39;);else    error(&#39;求解失败，错误代码: %d&#39;, result.problem);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.3 灵敏度分析（Shadow Price）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 在求解后提取对偶变量if result.problem &#x3D;&#x3D; 0    % 原材料约束的对偶变量（影子价格）    shadow_price &#x3D; dual(Constraints(1:3));    fprintf(&#39;\n原材料影子价格（万元&#x2F;吨）:\n&#39;);    fprintf(&#39;R1: %.4f\n&#39;, shadow_price(1));    fprintf(&#39;R2: %.4f\n&#39;, shadow_price(2));    fprintf(&#39;R3: %.4f\n&#39;, shadow_price(3));    % 影子价格&gt;0表示该原材料是瓶颈资源end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="下午（3小时）：运输问题与指派问题">0.2.1.2. 下午（3小时）：运输问题与指派问题</h4><p><strong>4.4 运输问题（Transportation Problem）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 问题：3个工厂 → 4个仓库，最小化运输成本% 数据supply &#x3D; [100; 150; 200];  % 工厂供应量demand &#x3D; [80; 90; 120; 160]; % 仓库需求量cost &#x3D; [4 5 6 8;           % 单位运输成本矩阵（工厂×仓库）        6 4 3 5;        7 8 5 6];% 决策变量：x(i,j)表示从工厂i到仓库j的运量x &#x3D; sdpvar(3,4,&#39;full&#39;);  % &#39;full&#39;表示非对称矩阵% 约束Constraints &#x3D; [    sum(x,2) &#x3D;&#x3D; supply,    % 行和&#x3D;供应（每个工厂运出量）    sum(x,1)&#39; &#x3D;&#x3D; demand,   % 列和&#x3D;需求（每个仓库接收量）    x &gt;&#x3D; 0                 % 非负];% 目标Objective &#x3D; sum(sum(cost.*x));  % 总成本% 求解optimize(Constraints, Objective, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;));% 结果展示x_opt &#x3D; value(x);fprintf(&#39;\n最优运输方案:\n&#39;);for i &#x3D; 1:3    for j &#x3D; 1:4        if x_opt(i,j) &gt; 0.1            fprintf(&#39;工厂%d → 仓库%d: %.1f 吨\n&#39;, i, j, x_opt(i,j));        end    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.5 指派问题（Assignment Problem）——纯0-1问题</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 问题：5个工人 → 5个任务，最小化总工时% 数据：工时矩阵time_cost &#x3D; [9 2 7 8 2;             6 4 3 7 6;             5 8 1 4 7;             7 6 9 8 5;             2 3 4 5 6];n &#x3D; 5;% 决策变量：x(i,j)&#x3D;1表示工人i做任务jx &#x3D; binvar(n,n);  % 5×5二元矩阵% 约束：每个工人只做1个任务，每个任务只由1个工人做Constraints &#x3D; [    sum(x,2) &#x3D;&#x3D; 1,  % 行和&#x3D;1（每个工人1个任务）    sum(x,1)&#39; &#x3D;&#x3D; 1  % 列和&#x3D;1（每个任务1个工人）];% 目标Objective &#x3D; sum(sum(time_cost.*x));% 求解（Gurobi在此类问题上性能卓越）optimize(Constraints, Objective, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;));% 结果x_opt &#x3D; value(x);fprintf(&#39;\n任务分配方案:\n&#39;);for i &#x3D; 1:n    for j &#x3D; 1:n        if x_opt(i,j) &gt; 0.5            fprintf(&#39;工人%d ←→ 任务%d (工时:%d)\n&#39;, i, j, time_cost(i,j));        end    endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第5天：混合整数线性规划（MILP）——Gurobi最擅长的领域">0.2.2. 第5天：混合整数线性规划（MILP）——Gurobi最擅长的领域</h3><h4 id="上午（3小时）：MILP核心理论与建模技巧">0.2.2.1. 上午（3小时）：MILP核心理论与建模技巧</h4><p><strong>5.1 为什么MILP这么难？（NP-hard问题）</strong></p><pre class="line-numbers language-none"><code class="language-none">MILP的求解复杂度：- 若有n个二元变量，理论上需要检查2ⁿ种组合- 当n&#x3D;100时，2¹⁰⁰ ≈ 1.27×10³⁰，比宇宙中原子总数还多- Gurobi的Branch-and-Cut算法：通过剪枝和割平面，实际只需检查极小一部分组合Gurobi在MILP上的优势：1. 先进的预求解技术（Presolve）：可消去30-50%的变量和约束2. 启发式算法（Heuristics）：快速找到高质量可行解3. 割平面（Cutting Planes）：强化松弛问题，逼近整数解4. 并行计算：利用多核CPU加速分支定界<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.2 背包问题（Knapsack Problem）——MILP入门</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 问题：容量15kg的背包，选哪些物品使总价值最大% 数据：10个物品weights &#x3D; [2,3,4,5,6,1,2,3,4,5];  % 重量(kg)values  &#x3D; [3,5,6,8,9,2,3,4,6,7];  % 价值capacity &#x3D; 15;n &#x3D; length(weights);% 决策变量：x(i)&#x3D;1表示选第i个物品x &#x3D; binvar(n,1);% 约束Constraints &#x3D; [weights*x &lt;&#x3D; capacity];% 目标Objective &#x3D; -values&#39;*x;  % 最大化价值% 求解ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.MIPGap&#39;,0.01);result &#x3D; optimize(Constraints, Objective, ops);% 结果x_opt &#x3D; value(x);fprintf(&#39;\n选中物品: &#39;);for i &#x3D; 1:n    if x_opt(i) &gt; 0.5        fprintf(&#39;%d &#39;, i);    endendfprintf(&#39;\n总价值: %.0f\n&#39;, -value(Objective));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.3 设施选址问题（Facility Location）——经典MILP</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 问题：在5个候选地建仓库，服务10个客户，最小化总成本（建设+运输）% 数据build_cost &#x3D; [100,150,120,90,110];  % 建设成本（万元）transport_cost &#x3D; randn(5,10);       % 运输成本矩阵（5仓库×10客户）demand &#x3D; ones(10,1)*50;             % 每个客户需求50吨% 决策变量1：y(i)&#x3D;1表示在i地建仓库y &#x3D; binvar(5,1);% 决策变量2：x(i,j)表示仓库i供应客户j的量x &#x3D; sdpvar(5,10);% 约束Constraints &#x3D; [    sum(x,1)&#39; &#x3D;&#x3D; demand,           % 满足所有客户需求    sum(x,2) &lt;&#x3D; 1000*y,            % 只有在建的仓库才能供应（大M法）    x &gt;&#x3D; 0];% 目标Objective &#x3D; build_cost&#39;*y + sum(sum(transport_cost.*x));% 求解（Gurobi会自动处理大M法）optimize(Constraints, Objective, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="下午（3小时）：MILP高级建模技巧">0.2.2.2. 下午（3小时）：MILP高级建模技巧</h4><p><strong>5.4 逻辑约束建模（Indicator Constraints）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 场景：如果工厂开启(y&#x3D;1)，则产量x≥100；否则x&#x3D;0y &#x3D; binvar(1);  % 开关变量x &#x3D; sdpvar(1);  % 产量% 传统大M法（可能数值不稳定）M &#x3D; 1000;Constraints &#x3D; [    x &lt;&#x3D; M*y,    x &gt;&#x3D; 100*y];% YALMIP高级语法（自动转化为Indicator）Constraints &#x3D; [implies(y&#x3D;&#x3D;1, x&gt;&#x3D;100), implies(y&#x3D;&#x3D;0, x&#x3D;&#x3D;0)];% YALMIP会自动转换为Gurobi的indicator约束，数值更稳定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.5 分段线性成本函数建模</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 场景：用电成本分段计价% 0-100度：0.5元&#x2F;度% 100-200度：0.8元&#x2F;度% 200度以上：1.2元&#x2F;度x &#x3D; sdpvar(1);  % 用电量cost &#x3D; sdpvar(1); % 成本% 方法1：引入辅助变量和约束x1 &#x3D; sdpvar(1); x2 &#x3D; sdpvar(1); x3 &#x3D; sdpvar(1);Constraints &#x3D; [    x &#x3D;&#x3D; x1 + x2 + x3,    0 &lt;&#x3D; x1 &lt;&#x3D; 100,    0 &lt;&#x3D; x2 &lt;&#x3D; 100,    0 &lt;&#x3D; x3 &lt;&#x3D; inf,    cost &#x3D;&#x3D; 0.5*x1 + 0.8*x2 + 1.2*x3];% 方法2：使用YALMIP的pwlf函数（推荐）cost &#x3D; pwlf(x, [0 100 200], [0 50 130]); % 断点[0,100,200]，累计成本[0,50,130]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第6天：二次规划（QP）与投资组合优化">0.2.3. 第6天：二次规划（QP）与投资组合优化</h3><h4 id="上午（3小时）：QP理论与凸性判断">0.2.3.1. 上午（3小时）：QP理论与凸性判断</h4><p><strong>6.1 二次规划的数学本质</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 标准形式：% minimize  0.5*x&#39;*Q*x + c&#39;*x% subject to Ax &lt;&#x3D; b% 关键概念：矩阵Q必须是半正定（PSD）才是凸QP% Gurobi只能高效求解凸QP% 判断凸性方法：Q &#x3D; [2 -1; -1 2];  % 正定矩阵eig_Q &#x3D; eig(Q);if all(eig_Q &gt;&#x3D; -1e-6)  % 容忍小负特征值    disp(&#39;是凸QP，Gurobi可解&#39;);else    error(&#39;是非凸QP，Gurobi可能无法找到全局最优&#39;);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>6.2 投资组合优化（Markowitz模型）——经典QP</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 问题：在10支股票中选择投资组合，期望收益≥12%，风险最小% 数据准备（通常从CSV&#x2F;Excel读取）returns &#x3D; [0.1;0.12;0.09;0.11;0.13;0.08;0.1;0.09;0.12;0.14];  % 期望收益cov_matrix &#x3D; cov(randn(100,10));  % 10×10协方差矩阵% 决策变量：x(i)表示投资比例x &#x3D; sdpvar(10,1);% 约束Constraints &#x3D; [    sum(x) &#x3D;&#x3D; 1,           % 总投资100%    x &gt;&#x3D; 0,                % 不允许做空    returns&#39;*x &gt;&#x3D; 0.12     % 期望收益≥12%];% 目标：最小化风险（方差）Objective &#x3D; x&#39;*cov_matrix*x;  % 二次项% 求解（Gurobi对凸QP有专门算法）ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.BarHomogeneous&#39;,1);optimize(Constraints, Objective, ops);% 结果分析x_opt &#x3D; value(x);risk_opt &#x3D; sqrt(value(Objective));  % 标准差return_opt &#x3D; returns&#39;*x_opt;fprintf(&#39;\n最优投资组合:\n&#39;);for i &#x3D; 1:10    if x_opt(i) &gt; 0.01  % 只显示占比&gt;1%的股票        fprintf(&#39;股票%d: %.2f%%\n&#39;, i, x_opt(i)*100);    endendfprintf(&#39;预期收益: %.2f%%\n&#39;, return_opt*100);fprintf(&#39;组合风险: %.4f\n&#39;, risk_opt);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="下午（3小时）：二次约束规划（QCP）与鲁棒优化">0.2.3.2. 下午（3小时）：二次约束规划（QCP）与鲁棒优化</h4><p><strong>6.3 带二次约束的问题</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 场景：投资组合中，要求90%的置信水平下风险不超过15%% 数据同上% 约束中引入二次项VaR_constraint &#x3D; [x&#39;*cov_matrix*x &lt;&#x3D; 0.15^2];  % 风险约束Constraints &#x3D; [    sum(x) &#x3D;&#x3D; 1,    x &gt;&#x3D; 0,    returns&#39;*x &gt;&#x3D; 0.12,    VaR_constraint];% Gurobi会自动识别为QCP问题optimize(Constraints, -returns&#39;*x, ops);  % 最大化收益<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>6.4 鲁棒优化初步（仿射可调鲁棒）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 场景：收益不确定，在±0.02范围内波动，求最坏情况下的最优解% 定义不确定集delta &#x3D; sdpvar(10,1);  % 收益波动Gamma &#x3D; 2;             % 预算不确定参数（控制保守度）% 鲁棒约束Robust_Constraints &#x3D; [    sum(x) &#x3D;&#x3D; 1,    x &gt;&#x3D; 0,    (returns+delta)&#39;*x &gt;&#x3D; 0.12,  % 收益约束需满足所有delta    sum(abs(delta)) &lt;&#x3D; Gamma,    % 不确定预算约束    -0.02 &lt;&#x3D; delta &lt;&#x3D; 0.02       % 波动范围];% YALMIP会自动将鲁棒约束转化为确定性等价形式optimize(Robust_Constraints, -min((returns+delta)&#39;*x), ops);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第7天：第二阶段综合实战与复盘">0.2.4. 第7天：第二阶段综合实战与复盘</h3><h4 id="全天（6小时）：完整项目——微电网调度">0.2.4.1. 全天（6小时）：完整项目——微电网调度</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 微电网经济调度问题（MILP+QP混合）% 系统组成：% - 柴油发电机：成本函数 0.1P² + 5P + 100（二次成本）% - 光伏：发电成本0，但不确定% - 电池：充放电效率90%，容量限制% - 负荷：必须满足% 预测数据（24小时）load_profile &#x3D; [50 45 40 38 35 40 55 70 85 90 88 85 82 80 78 75 80 88 92 85 78 70 62 55];solar_forecast &#x3D; [0 0 0 0 0 5 15 30 45 60 70 75 80 75 65 50 35 20 8 0 0 0 0 0];%% 参数设置n &#x3D; 24;  % 24小时调度P_diesel &#x3D; sdpvar(n,1);  % 柴油发电机功率P_battery &#x3D; sdpvar(n,1); % 电池充放电（正&#x3D;放电，负&#x3D;充电）P_grid &#x3D; sdpvar(n,1);    % 主网购售电（正&#x3D;购电，负&#x3D;售电）SoC &#x3D; sdpvar(n+1,1);     % 电池荷电状态（0-100%）u_diesel &#x3D; binvar(n,1);  % 柴油机启停状态% 技术参数P_diesel_max &#x3D; 100;      % 柴油机最大功率P_battery_max &#x3D; 50;      % 电池功率限制SoC_min &#x3D; 0.2; SoC_max &#x3D; 0.9;  % SoC限制SoC_initial &#x3D; 0.5;       % 初始SoCbattery_eff &#x3D; 0.9;       % 充放电效率diesel_cost_coeff &#x3D; [0.1, 5, 100];  % 成本系数[a,b,c]对应aP²+bP+cgrid_buy_price &#x3D; 0.8;    % 购电价格grid_sell_price &#x3D; 0.5;   % 售电价格%% 约束条件Constraints &#x3D; [];% 1. 功率平衡约束（最关键的等式约束）for t &#x3D; 1:n    Constraints &#x3D; [Constraints,         P_diesel(t) + P_battery(t) + solar_forecast(t) + P_grid(t) &#x3D;&#x3D; load_profile(t)];end% 2. 柴油机约束Constraints &#x3D; [Constraints,    0 &lt;&#x3D; P_diesel &lt;&#x3D; P_diesel_max*u_diesel,  % 不运行时功率为0    u_diesel &lt;&#x3D; 1, u_diesel &gt;&#x3D; 0];% 3. 电池约束（动力学模型）Constraints &#x3D; [Constraints,    -P_battery_max &lt;&#x3D; P_battery &lt;&#x3D; P_battery_max,    SoC(1) &#x3D;&#x3D; SoC_initial  % 初始荷电状态];for t &#x3D; 1:n    Constraints &#x3D; [Constraints,        SoC(t+1) &#x3D;&#x3D; SoC(t) - P_battery(t)&#x2F;P_battery_max*battery_eff,        SoC(t+1) &gt;&#x3D; SoC_min,        SoC(t+1) &lt;&#x3D; SoC_max    ];end% 4. 主网约束（设双向功率限制）P_grid_max &#x3D; 200;Constraints &#x3D; [Constraints, -P_grid_max &lt;&#x3D; P_grid &lt;&#x3D; P_grid_max];%% 目标函数（分段成本）% 柴油机成本 &#x3D; 0.1*P² + 5*P + 100*udiesel_cost &#x3D; diesel_cost_coeff(1)*sum(P_diesel.^2) + ...              diesel_cost_coeff(2)*sum(P_diesel) + ...              diesel_cost_coeff(3)*sum(u_diesel);% 电网交互成本（购电正成本，售电负成本）grid_cost &#x3D; grid_buy_price*sum(max(P_grid,0)) - grid_sell_price*sum(max(-P_grid,0));% 总成本Objective &#x3D; diesel_cost + grid_cost;%% 求解ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;, &#39;gurobi.TimeLimit&#39;,600, &#39;verbose&#39;,1);result &#x3D; optimize(Constraints, Objective, ops);%% 结果分析与绘图if result.problem &#x3D;&#x3D; 0    % 提取结果    P_diesel_opt &#x3D; value(P_diesel);    P_battery_opt &#x3D; value(P_battery);    P_grid_opt &#x3D; value(P_grid);    SoC_opt &#x3D; value(SoC(1:n));  % 取前24小时的        % 绘制调度曲线    figure(&#39;Position&#39;,[100 100 1200 800]);        subplot(3,1,1);    plot(1:n, load_profile, &#39;k-&#39;, &#39;LineWidth&#39;,2); hold on;    plot(1:n, P_diesel_opt, &#39;r--&#39;);    plot(1:n, solar_forecast, &#39;y:&#39;);    plot(1:n, P_battery_opt, &#39;b-.&#39;);    plot(1:n, P_grid_opt, &#39;g--&#39;);    legend(&#39;负荷&#39;,&#39;柴油机&#39;,&#39;光伏&#39;,&#39;电池&#39;,&#39;主网&#39;);    title(&#39;功率调度曲线&#39;);    xlabel(&#39;时间(h)&#39;); ylabel(&#39;功率(kW)&#39;);    grid on;        subplot(3,1,2);    stairs(1:n, value(u_diesel), &#39;r-&#39;, &#39;LineWidth&#39;,2);    title(&#39;柴油机启停状态&#39;);    ylabel(&#39;状态&#39;); ylim([-0.1 1.1]); grid on;        subplot(3,1,3);    plot(0:n, value(SoC), &#39;b-o&#39;, &#39;LineWidth&#39;,2);    title(&#39;电池荷电状态&#39;);    xlabel(&#39;时间(h)&#39;); ylabel(&#39;SoC(%)&#39;);    grid on;        % 成本分析    total_cost &#x3D; value(Objective);    fprintf(&#39;\n总运行成本: %.2f 元\n&#39;, total_cost);    fprintf(&#39;柴油机成本: %.2f 元\n&#39;, value(diesel_cost));    fprintf(&#39;电网交互成本: %.2f 元\n&#39;, value(grid_cost));end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="第三阶段：进阶技巧与参数调优（第3周）">0.3. 第三阶段：进阶技巧与参数调优（第3周）</h2><h3 id="第8天：大规模问题处理技巧">0.3.1. 第8天：大规模问题处理技巧</h3><h4 id="上午（3小时）：稀疏矩阵与向量化编程">0.3.1.1. 上午（3小时）：稀疏矩阵与向量化编程</h4><p><strong>8.1 为什么不能用for循环？（性能对比）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% 场景：创建1000个发电机的出力约束n &#x3D; 1000;P &#x3D; sdpvar(n,1);P_max &#x3D; rand(n,1);%% 方法1：for循环（不推荐）tic;Constraints &#x3D; [];for i &#x3D; 1:n    Constraints &#x3D; [Constraints, P(i) &lt;&#x3D; P_max(i)];endtoc;  % 耗时约 0.5-2秒，内存占用高%% 方法2：向量化（推荐）tic;Constraints &#x3D; [P &lt;&#x3D; P_max];  % 一行代码toc;  % 耗时约 0.01秒，内存占用低% 性能对比：% n&#x3D;1000时，方法2快50-200倍% n&#x3D;10000时，方法1可能内存溢出，方法2依然流畅<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>8.2 稀疏矩阵在电力系统中的应用</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：IEEE 118节点系统（大规模潮流约束）% 导入系统数据（导纳矩阵）load(&#39;case118.mat&#39;);  % 包含bus, branch, gen等结构体nb &#x3D; 118;  % 节点数ng &#x3D; 54;   % 发电机数% 决策变量P_gen &#x3D; sdpvar(ng,1);V &#x3D; sdpvar(nb,1);  % 电压幅值% 构建节点功率平衡（稀疏方式）% 传统稠密矩阵：A &#x3D; zeros(nb,nb); 占用内存 118*118*8 ≈ 105KB% 稀疏矩阵：A &#x3D; sparse(nb,nb); 占用内存 &lt; 10KB% 导纳矩阵G和B通常是稀疏的G &#x3D; sparse(gen_G_matrix);  % 电导矩阵B &#x3D; sparse(gen_B_matrix);  % 电纳矩阵% 功率注入表达式（向量化计算）P_inj &#x3D; V.*(G*V) + V.*(B*V);  % 节点注入功率% 负荷向量P_load &#x3D; bus(:,3);  % 第3列是负荷% 功率平衡（稀疏约束）Constraints &#x3D; [P_inj &#x3D;&#x3D; P_load + A_gen*P_gen];  % A_gen是稀疏的关联矩阵<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>8.3 参数化的约束生成</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：不同场景下的鲁棒优化% 定义场景数n_scenarios &#x3D; 100;P_load &#x3D; sdpvar(n_scenarios,1);  % 每个场景下的负荷% 基础约束Constraints &#x3D; [];for s &#x3D; 1:n_scenarios    % 从数据文件读取场景s的负荷    load_data &#x3D; load([&#39;scenario_&#39;,num2str(s),&#39;.mat&#39;]);        % 参数化约束：根据不同场景调整约束右端项    Constraints &#x3D; [Constraints,         P_gen(s) + P_grid(s) &#x3D;&#x3D; load_data.P_load];end% 等价的高效写法（如果需要）：% 使用cell数组预先生成所有约束constraint_cell &#x3D; cell(n_scenarios,1);for s &#x3D; 1:n_scenarios    constraint_cell&#123;s&#125; &#x3D; (P_gen(s) + P_grid(s) &#x3D;&#x3D; load_data.P_load);endConstraints &#x3D; [constraint_cell&#123;:&#125;];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="下午（3小时）：求解器日志解读与性能调优">0.3.1.2. 下午（3小时）：求解器日志解读与性能调优</h4><p><strong>8.4 Gurobi日志深度解读</strong></p><pre class="line-numbers language-none"><code class="language-none">典型日志输出分析：Optimize a model with 100 rows, 200 columns and 500 nonzerosModel fingerprint: 0x12345678Variable types: 150 continuous, 50 integer (50 binary)Coefficient statistics:  Matrix range     [1e+00, 1e+03]  Objective range  [1e-01, 2e+02]  Bounds range     [1e+00, 1e+00]  RHS range        [1e+02, 1e+03]Presolve removed 25 rows and 50 columns (presolve time &#x3D; 0.05s)...【解读】- 100 rows &#x3D; 100个约束- 200 columns &#x3D; 200个变量- 500 nonzeros &#x3D; 500个非零系数（稀疏度&#x3D;500&#x2F;(100*200)&#x3D;2.5%）- Presolve removed：预求解消去了25个冗余约束和50个变量- 50 binary：50个二元变量 → MILP问题Presolve time: 0.12sPresolved: 75 rows, 150 columns, 375 nonzerosExplored 0 nodes (0 simplex iterations) in 0.05 secondsThread count was 8 (of 8 available processors)Solution count 2: 1234.5 1567.8Optimal solution found (tolerance 1.00e-04)Best objective 1.234500000000e+03, best bound 1.234500000000e+03, gap 0.0000%【解读】- Explored 0 nodes：根节点就找到了最优解（幸运！）- Solution count 2：找到2个可行解- gap 0.0000%：最优性间隙为0，证明全局最优- Best objective &#x3D; Best bound：上下界重合，最优性得证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>8.5 性能调优实战案例</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：混合整数规划求解太慢% 问题：机组组合（Unit Commitment），1440个二元变量% 目标：24小时调度，最小化成本% 初始设置（慢，需600秒）ops_slow &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;);% optimize(...)  % 600秒% 调优后设置（快，仅需45秒）ops_fast &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;gurobi.MIPGap&#39;,0.005,...              % 接受0.5%间隙    &#39;gurobi.Heuristics&#39;,0.8,...            % 加强启发式    &#39;gurobi.VarBranch&#39;,3,...               % 最大冲突分支策略    &#39;gurobi.CutPasses&#39;,5,...               % 增加割平面迭代    &#39;gurobi.Presolve&#39;,2,...                % 最高级预求解    &#39;gurobi.NumFocus&#39;,1,...                % 侧重找到可行解    &#39;gurobi.Threads&#39;,12);                 % 使用更多线程% 性能提升原理：% 1. MIPGap放宽：从默认0.01%到0.5%，减少枚举% 2. Heuristics加强：更快找到优质初始解% 3. VarBranch策略：选择对目标影响大的变量分支% 4. Cuts增加：收紧松弛问题，更接近整数解% 5. 并行加速：12线程 vs 4线程，理论加速3倍（实际约2.5倍）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第9天：不可行性诊断与模型修复">0.3.2. 第9天：不可行性诊断与模型修复</h3><h4 id="上午（3小时）：冲突约束检测">0.3.2.1. 上午（3小时）：冲突约束检测</h4><p><strong>9.1 使用conflict函数定位矛盾</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：模型无可行解，但不知道哪个约束冲突% 构造一个故意矛盾的模型x &#x3D; sdpvar(1);C1 &#x3D; [x &gt;&#x3D; 5];C2 &#x3D; [x &lt;&#x3D; 3];C3 &#x3D; [x &#x3D;&#x3D; 4];  % 与前两个矛盾Constraints &#x3D; [C1, C2, C3];% 求解result &#x3D; optimize(Constraints, x, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;));% 检测冲突if result.problem &#x3D;&#x3D; 1  % 无可行解    [conflict_constraints, conflict_flags] &#x3D; conflict(Constraints);        % conflict_flags显示哪些约束参与冲突    disp(&#39;冲突约束索引:&#39;);    find(conflict_flags)        % 详细分析    analyze(conflict_constraints)end% 输出示例：% Conflict set size 2% Constraint 1:  x &gt;&#x3D; 5% Constraint 2:  x &lt;&#x3D; 3% 说明这两个约束直接矛盾，C3是冗余的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>9.2 软约束（Soft Constraints）与罚函数</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：负荷平衡约束可能无法满足，允许少量切负荷P_gen &#x3D; sdpvar(10,1);P_load &#x3D; ones(10,1)*50;  % 预测负荷% 硬约束（可能导致无解）% Constraints &#x3D; [sum(P_gen) &#x3D;&#x3D; sum(P_load)];  % 可能不可行% 软约束（允许偏差，但惩罚）violation &#x3D; sdpvar(1);  % 偏差变量penalty_weight &#x3D; 1000;  % 惩罚系数% 修改约束Constraints &#x3D; [    sum(P_gen) + violation &#x3D;&#x3D; sum(P_load),  % 允许偏差    violation &gt;&#x3D; 0];% 目标函数增加惩罚项Base_Cost &#x3D; sum(P_gen);Penalty_Cost &#x3D; penalty_weight * violation;Objective &#x3D; Base_Cost + Penalty_Cost;% 求解后会优先满足硬约束，软约束尽量满足optimize(Constraints, Objective, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="下午（3小时）：数值稳定性处理">0.3.2.2. 下午（3小时）：数值稳定性处理</h4><p><strong>9.3 数据缩放（Scaling）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：模型系数范围太大导致数值问题% 原始数据（极差巨大）coeff &#x3D; [1e-6, 1e3, 1e-3, 1e6];  % 矩阵范围[1e-6,1e6]% Gurobi会警告：Matrix coefficient range exceeds 1e+06% 解决方法：缩放scale_factor &#x3D; 1e3;coeff_scaled &#x3D; coeff &#x2F; scale_factor;  % 新范围[1e-9,1e3]% 求解后再反缩放结果% 或在YALMIP中自动处理：ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.ScaleFlag&#39;,1);% ScaleFlag&#x3D;1启用自动缩放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>9.4 大M法的问题与改进</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：逻辑约束中的大M值选择y &#x3D; binvar(1);x &#x3D; sdpvar(1);% 错误做法：M过大导致数值不稳定M_bad &#x3D; 1e6;Constraints_bad &#x3D; [x &lt;&#x3D; M_bad*y]; % 正确做法：M尽量紧% 先估算x的最大可能值x_max &#x3D; 100;  % 基于业务逻辑估算Constraints_good &#x3D; [x &lt;&#x3D; x_max*y];% 最佳做法：使用YALMIP的implies（自动避免大M）Constraints_best &#x3D; [implies(y&#x3D;&#x3D;0, x&#x3D;&#x3D;0), implies(y&#x3D;&#x3D;1, x&gt;&#x3D;0)];% YALMIP会生成Gurobi的indicator约束，无需手动大M<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第10天：结果后处理与可视化">0.3.3. 第10天：结果后处理与可视化</h3><h4 id="上午（2小时）：提取对偶变量与灵敏度分析">0.3.3.1. 上午（2小时）：提取对偶变量与灵敏度分析</h4><p><strong>10.1 对偶变量（Shadow Price）的经济学意义</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：电力系统节点电价计算% 节点功率平衡约束P_inj &#x3D; sdpvar(n,1);  % 节点注入P_load &#x3D; bus(:,3);    % 节点负荷Gen_incidence &#x3D; ...;  % 发电机-节点关联矩阵% 约束Constraints &#x3D; [P_inj &#x3D;&#x3D; P_load + Gen_incidence*P_gen];% 求解optimize(Constraints, Cost, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;));% 提取对偶变量（节点电价）if result.problem &#x3D;&#x3D; 0    nodal_price &#x3D; dual(Constraints);  % 每个节点的影子价格    % 对偶变量表示该节点每增加1MW负荷，总成本增加量（$&#x2F;MW）        % 绘制电价地图    figure;    scatter(bus(:,2), bus(:,3), 100, nodal_price, &#39;filled&#39;);    colorbar;    title(&#39;节点电价分布&#39;);    xlabel(&#39;经度&#39;); ylabel(&#39;纬度&#39;);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>10.2 参数灵敏度分析</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：天然气价格变化对机组调度影响gas_price_range &#x3D; 2:0.5:5;  % 天然气价格范围（$&#x2F;MMBtu）total_cost_curve &#x3D; zeros(size(gas_price_range));for i &#x3D; 1:length(gas_price_range)    % 重新计算目标函数（系数含gas_price）    gas_price &#x3D; gas_price_range(i);    Fuel_Cost &#x3D; gas_price * Heat_Rate * P_gen;        % 求解    optimize(Constraints, Fuel_Cost, ops);        if result.problem &#x3D;&#x3D; 0        total_cost_curve(i) &#x3D; value(Fuel_Cost);    endend% 绘制成本曲线plot(gas_price_range, total_cost_curve, &#39;-o&#39;);xlabel(&#39;天然气价格 ($&#x2F;MMBtu)&#39;);ylabel(&#39;总运行成本 ($)&#39;);title(&#39;价格灵敏度分析&#39;);grid on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="下午（2小时）：结果可视化高级技巧">0.3.3.2. 下午（2小时）：结果可视化高级技巧</h4><p><strong>10.3 Gantt图（调度问题必备）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：5台机组24小时启停计划% 求解后得到u_on矩阵（5台×24小时）u_on_opt &#x3D; value(u_on);  % 5×24的二元矩阵% 绘制Gantt图figure(&#39;Position&#39;,[100 100 1200 400]);y_tics &#x3D; 1:5;for i &#x3D; 1:5    on_periods &#x3D; find(u_on_opt(i,:)&#x3D;&#x3D;1);    if ~isempty(on_periods)        for t &#x3D; on_periods            x_start &#x3D; t-1;            y_bottom &#x3D; i-0.3;            rectangle(&#39;Position&#39;,[x_start,y_bottom,1,0.6],...                     &#39;FaceColor&#39;,[0.2 0.6 0.9],...                     &#39;EdgeColor&#39;,&#39;none&#39;);        end    endendxlim([0 24]);ylim([0.5 5.5]);set(gca,&#39;YTick&#39;,y_tics,&#39;YTickLabel&#39;,&#123;&#39;G1&#39;,&#39;G2&#39;,&#39;G3&#39;,&#39;G4&#39;,&#39;G5&#39;&#125;);xlabel(&#39;时间 (h)&#39;);ylabel(&#39;机组&#39;);title(&#39;机组启停计划甘特图&#39;);grid on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>10.4 3D曲面图（展示多参数影响）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：电池容量 vs 光伏容量 对系统成本影响battery_cap_range &#x3D; 0:10:100;  % 电池容量范围solar_cap_range &#x3D; 0:5:50;      % 光伏容量范围cost_matrix &#x3D; zeros(length(battery_cap_range), length(solar_cap_range));for i &#x3D; 1:length(battery_cap_range)    for j &#x3D; 1:length(solar_cap_range)        % 重新设置容量参数        battery_capacity &#x3D; battery_cap_range(i);        solar_capacity &#x3D; solar_cap_range(j);                % 更新约束（电池容量约束）        Constraints &#x3D; [SoC &lt;&#x3D; battery_capacity&#x2F;1000, ...];                % 求解        optimize(Constraints, Objective, ops);                if result.problem &#x3D;&#x3D; 0            cost_matrix(i,j) &#x3D; value(Objective);        end    endend% 绘制3D曲面[B,S] &#x3D; meshgrid(solar_cap_range, battery_cap_range);surf(B,S,cost_matrix&#x2F;1e6);xlabel(&#39;光伏容量 (MW)&#39;);ylabel(&#39;电池容量 (MWh)&#39;);zlabel(&#39;年化成本 (百万元)&#39;);title(&#39;容量配置优化分析&#39;);colorbar;shading interp;  % 平滑着色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="第四阶段：综合项目实战（第4周）">0.4. 第四阶段：综合项目实战（第4周）</h2><h3 id="第11天：电力系统——机组组合问题（Unit-Commitment）">0.4.1. 第11天：电力系统——机组组合问题（Unit Commitment）</h3><h4 id="全天（6小时）：IEEE-30节点系统UC问题">0.4.1.1. 全天（6小时）：IEEE 30节点系统UC问题</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% IEEE 30节点系统机组组合问题（完整工业级代码）clear; clc; close all;%% 1. 系统数据加载% 数据包括：机组参数、负荷曲线、网络参数load(&#39;case30data.mat&#39;);  % 假设已准备好n_gen &#x3D; 6;    % 6台发电机n_hour &#x3D; 24;  % 24小时调度% 机组参数（通常从Excel读取）gen_param &#x3D; [    10 20 100 50 0.1 0.2 5 100;  % [Pmin Pmax a b c start_cost min_down min_up]    20 50 150 80 0.08 0.15 8 120;    15 35 120 60 0.09 0.18 6 110;    12 40 130 70 0.11 0.22 7 130;    18 45 140 75 0.12 0.24 9 140;    25 60 160 90 0.13 0.26 10 150];P_min &#x3D; gen_param(:,1);P_max &#x3D; gen_param(:,2);cost_a &#x3D; gen_param(:,3);cost_b &#x3D; gen_param(:,4);cost_c &#x3D; gen_param(:,5);start_cost &#x3D; gen_param(:,6);min_down &#x3D; gen_param(:,7);min_up &#x3D; gen_param(:,8);% 24小时负荷曲线（MW）load_curve &#x3D; 100*[2.4 2.3 2.2 2.1 2.0 2.1 2.3 2.8 3.2 3.5 3.6 3.4 3.2 3.0 3.1 3.3 3.5 3.8 3.6 3.4 3.2 2.9 2.6 2.5];%% 2. 决策变量定义P &#x3D; sdpvar(n_gen, n_hour);      % 发电功率u &#x3D; binvar(n_gen, n_hour);      % 启停状态v_start &#x3D; binvar(n_gen, n_hour); % 启动变量v_shutdown &#x3D; binvar(n_gen, n_hour); % 停机变量%% 3. 约束条件Constraints &#x3D; [];% 3.1 功率平衡（每个小时）for t &#x3D; 1:n_hour    Constraints &#x3D; [Constraints,         sum(P(:,t)) &#x3D;&#x3D; load_curve(t)];end% 3.2 机组出力限制for t &#x3D; 1:n_hour    for g &#x3D; 1:n_gen        Constraints &#x3D; [Constraints,            P(g,t) &gt;&#x3D; P_min(g)*u(g,t),            P(g,t) &lt;&#x3D; P_max(g)*u(g,t)        ];    endend% 3.3 最小启停时间约束（逻辑复杂，需仔细）% 假设初始状态：已运行3小时initial_status &#x3D; ones(n_gen,1);initial_runtime &#x3D; 3*ones(n_gen,1);% 启动&#x2F;停机变量定义for g &#x3D; 1:n_gen    for t &#x3D; 1:n_hour        if t &#x3D;&#x3D; 1            Constraints &#x3D; [Constraints,                v_start(g,t) &gt;&#x3D; u(g,t) - initial_status(g),                v_shutdown(g,t) &gt;&#x3D; initial_status(g) - u(g,t)            ];        else            Constraints &#x3D; [Constraints,                v_start(g,t) &gt;&#x3D; u(g,t) - u(g,t-1),                v_shutdown(g,t) &gt;&#x3D; u(g,t-1) - u(g,t)            ];        end        Constraints &#x3D; [Constraints,            v_start(g,t) &lt;&#x3D; u(g,t),            v_shutdown(g,t) &lt;&#x3D; 1 - u(g,t)        ];    endend% 最小运行&#x2F;停机时间for g &#x3D; 1:n_gen    for t &#x3D; 1:n_hour        % 最小运行时间        for tau &#x3D; max(1,t-min_up(g)+1):t            Constraints &#x3D; [Constraints,                u(g,t) &lt;&#x3D; sum(v_start(g,tau:t)) + (initial_runtime(g) &gt;&#x3D; min_up(g))];        end                % 最小停机时间        for tau &#x3D; max(1,t-min_down(g)+1):t            Constraints &#x3D; [Constraints,                1-u(g,t) &lt;&#x3D; sum(v_shutdown(g,tau:t)) + (initial_status(g)&#x3D;&#x3D;0)];        end    endend%% 4. 目标函数Generation_Cost &#x3D; 0;Start_Cost &#x3D; 0;for g &#x3D; 1:n_gen    for t &#x3D; 1:n_hour        Generation_Cost &#x3D; Generation_Cost + ...            cost_c(g)*P(g,t)^2 + cost_b(g)*P(g,t) + cost_a(g)*u(g,t);        Start_Cost &#x3D; Start_Cost + start_cost(g)*v_start(g,t);    endendObjective &#x3D; Generation_Cost + Start_Cost;%% 5. 求解设置与运行ops &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;verbose&#39;,1,...    &#39;gurobi.MIPGap&#39;,0.01,...          % 1%间隙    &#39;gurobi.TimeLimit&#39;,1800,...       % 30分钟    &#39;gurobi.MIPFocus&#39;,1,...           % 重点找可行解    &#39;gurobi.Heuristics&#39;,0.8);        % 强化启发式% 添加初始解（暖启动）% 假设全部机组以最小出力运行P_init &#x3D; repmat(P_min, 1, n_hour);u_init &#x3D; ones(n_gen, n_hour);ops &#x3D; sdpsettings(ops,&#39;gurobi.Start&#39;,struct(&#39;P&#39;,P_init,&#39;u&#39;,u_init));% 求解tic;result &#x3D; optimize(Constraints, Objective, ops);solve_time &#x3D; toc;%% 6. 结果分析与验证if result.problem &#x3D;&#x3D; 0    P_opt &#x3D; value(P);    u_opt &#x3D; value(u);    v_start_opt &#x3D; value(v_start);        total_cost &#x3D; value(Objective);        fprintf(&#39;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 机组组合求解成功 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#39;);    fprintf(&#39;求解时间: %.2f 秒\n&#39;, solve_time);    fprintf(&#39;总成本: $%.2f\n&#39;, total_cost);        % 绘制调度曲线    figure(&#39;Position&#39;,[100 100 1400 800]);        % 发电堆叠图    subplot(2,1,1);    area(1:n_hour, P_opt&#39;, &#39;LineStyle&#39;,&#39;none&#39;);    hold on;    plot(1:n_hour, load_curve, &#39;k-&#39;, &#39;LineWidth&#39;,2);    legend(&#39;G1&#39;,&#39;G2&#39;,&#39;G3&#39;,&#39;G4&#39;,&#39;G5&#39;,&#39;G6&#39;,&#39;负荷&#39;);    title(&#39;机组出力曲线&#39;);    xlabel(&#39;时间(h)&#39;); ylabel(&#39;功率(MW)&#39;);    grid on;        % 启停状态图    subplot(2,1,2);    imagesc(1:n_hour, 1:n_gen, u_opt);    set(gca,&#39;YTick&#39;,1:n_gen,&#39;YTickLabel&#39;,&#123;&#39;G1&#39;,&#39;G2&#39;,&#39;G3&#39;,&#39;G4&#39;,&#39;G5&#39;,&#39;G6&#39;&#125;);    xlabel(&#39;时间(h)&#39;); ylabel(&#39;机组&#39;);    title(&#39;启停状态（蓝色&#x3D;运行）&#39;);    colorbar;        % 成本构成分析    gen_cost_val &#x3D; value(Generation_Cost);    start_cost_val &#x3D; value(Start_Cost);        figure;    pie([gen_cost_val, start_cost_val], &#123;&#39;发电成本&#39;,&#39;启停成本&#39;&#125;);    title(&#39;成本构成&#39;);else    error(&#39;机组组合求解失败，错误代码: %d&#39;, result.problem);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第12天：控制工程——模型预测控制（MPC）">0.4.2. 第12天：控制工程——模型预测控制（MPC）</h3><h4 id="全天（6小时）：MPC完整实现">0.4.2.1. 全天（6小时）：MPC完整实现</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 线性MPC控制器设计（以双积分系统为例）% 系统模型：x(k+1) &#x3D; A*x(k) + B*u(k)% 状态：x &#x3D; [位置;速度]% 控制输入：u &#x3D; 加速度%% 1. 系统参数Ts &#x3D; 0.1;  % 采样时间(s)A &#x3D; [1 Ts; 0 1];  % 离散状态矩阵B &#x3D; [0.5*Ts^2; Ts];  % 离散输入矩阵nx &#x3D; 2;  % 状态数nu &#x3D; 1;  % 控制输入数% 约束u_min &#x3D; -5; u_max &#x3D; 5;  % 加速度限制x_max &#x3D; [10; 5];        % 位置和速度限制% MPC参数N &#x3D; 20;  % 预测时域Q &#x3D; eye(nx);  % 状态权重R &#x3D; 0.1;      % 输入权重%% 2. 决策变量定义X &#x3D; sdpvar(nx, N+1);  % 预测时域内所有状态U &#x3D; sdpvar(nu, N);    % 预测时域内所有输入x0 &#x3D; sdpvar(nx,1);    % 当前状态（已知参数）%% 3. MPC模型约束Constraints &#x3D; [];% 初始条件Constraints &#x3D; [X(:,1) &#x3D;&#x3D; x0];% 系统动力学（对每个预测步）for k &#x3D; 1:N    Constraints &#x3D; [Constraints,         X(:,k+1) &#x3D;&#x3D; A*X(:,k) + B*U(:,k)];end% 状态约束for k &#x3D; 1:N+1    Constraints &#x3D; [Constraints,         -x_max &lt;&#x3D; X(:,k) &lt;&#x3D; x_max];end% 输入约束for k &#x3D; 1:N    Constraints &#x3D; [Constraints,         u_min &lt;&#x3D; U(:,k) &lt;&#x3D; u_max];end%% 4. 目标函数Objective &#x3D; 0;for k &#x3D; 1:N    Objective &#x3D; Objective + X(:,k)&#39;*Q*X(:,k) + R*U(:,k)^2;end% 终端代价Objective &#x3D; Objective + X(:,N+1)&#39;*Q*X(:,N+1);%% 5. 创建MPC求解器（离线编译）% 将x0作为参数Controller &#x3D; optimizer(Constraints, Objective, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;), x0, U(:,1));%% 6. 仿真闭环控制sim_time &#x3D; 50;  % 仿真步数x_current &#x3D; [5; 0];  % 初始状态[位置;速度]x_history &#x3D; zeros(nx, sim_time);u_history &#x3D; zeros(nu, sim_time);for t &#x3D; 1:sim_time    % 求解MPC（在线计算）    u_opt &#x3D; Controller&#123;x_current&#125;;        % 应用第一个控制输入    u_current &#x3D; value(u_opt);        % 记录    x_history(:,t) &#x3D; x_current;    u_history(:,t) &#x3D; u_current;        % 模拟系统演化（真实系统）    x_current &#x3D; A*x_current + B*u_current;        % 可视化    clf;    subplot(2,1,1);    plot(1:t, x_history(1,1:t), &#39;b-&#39;, &#39;LineWidth&#39;,2);    hold on;    plot(t, x_current(1), &#39;ro&#39;);    title(&#39;位置轨迹&#39;); xlabel(&#39;步数&#39;); ylabel(&#39;位置&#39;);    grid on;        subplot(2,1,2);    stairs(1:t, u_history(:,1:t), &#39;r-&#39;, &#39;LineWidth&#39;,2);    title(&#39;控制输入&#39;); xlabel(&#39;步数&#39;); ylabel(&#39;加速度&#39;);    grid on;    ylim([u_min u_max]);        drawnow;    pause(0.1);end%% 7. 性能分析figure;subplot(2,1,1);plot(x_history(1,:), x_history(2,:), &#39;b-&#39;, &#39;LineWidth&#39;,2);title(&#39;状态相轨迹&#39;);xlabel(&#39;位置&#39;); ylabel(&#39;速度&#39;);grid on;subplot(2,1,2);plot(u_history, &#39;r-&#39;, &#39;LineWidth&#39;,2);title(&#39;控制输入时序&#39;);xlabel(&#39;步数&#39;); ylabel(&#39;加速度&#39;);grid on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第13天：路径规划与旅行商问题（TSP）">0.4.3. 第13天：路径规划与旅行商问题（TSP）</h3><h4 id="全天（6小时）：TSP建模与求解">0.4.3.1. 全天（6小时）：TSP建模与求解</h4><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 旅行商问题（TSP）—— 经典组合优化% 问题：访问10个城市，每个城市一次，返回起点，路程最短% 城市坐标cities &#x3D; [    0 0; 10 0; 5 8.66; 15 8.66; 20 0;    25 8.66; 30 0; 35 8.66; 40 0; 45 8.66];n &#x3D; size(cities,1);% 计算距离矩阵D(i,j)D &#x3D; zeros(n,n);for i &#x3D; 1:n    for j &#x3D; 1:n        D(i,j) &#x3D; norm(cities(i,:) - cities(j,:));    endend%% 1. Miller-Tucker-Zemlin (MTZ) 建模法% 决策变量：x(i,j)&#x3D;1表示路径i→jx &#x3D; binvar(n,n,&#39;full&#39;);  % &#39;full&#39;表示非对称% 辅助变量：u(i)用于消除子回路u &#x3D; sdpvar(n,1);% 约束Constraints &#x3D; [];% 每个城市恰好一次入边和出边Constraints &#x3D; [Constraints, sum(x,1)&#39; &#x3D;&#x3D; 1];  % 出度&#x3D;1Constraints &#x3D; [Constraints, sum(x,2) &#x3D;&#x3D; 1];   % 入度&#x3D;1% 消除子回路（MTZ约束）M &#x3D; n;  % 大Mfor i &#x3D; 2:n    for j &#x3D; 2:n        if i ~&#x3D; j            Constraints &#x3D; [Constraints, u(i) - u(j) + M*x(i,j) &lt;&#x3D; M-1];        end    endend% 固定起点（城市1）Constraints &#x3D; [Constraints, x(1,1) &#x3D;&#x3D; 0];  % 不自我连接% 目标函数Objective &#x3D; sum(sum(D.*x));%% 2. 求解（TSP是MILP，Gurobi强项）ops &#x3D; sdpsettings(...    &#39;solver&#39;,&#39;gurobi&#39;,...    &#39;verbose&#39;,1,...    &#39;gurobi.MIPGap&#39;,0.001,...      % 0.1%精度    &#39;gurobi.Heuristics&#39;,0.8,...    % 强化启发式    &#39;gurobi.CutPasses&#39;,5);         % 加强割平面result &#x3D; optimize(Constraints, Objective, ops);%% 3. 结果可视化if result.problem &#x3D;&#x3D; 0    x_opt &#x3D; value(x);        % 提取路径    tour &#x3D; zeros(1,n+1);    tour(1) &#x3D; 1;  % 起点    for i &#x3D; 2:n+1        next_city &#x3D; find(x_opt(tour(i-1),:) &gt; 0.5);        tour(i) &#x3D; next_city;    end        % 绘制路径图    figure(&#39;Position&#39;,[100 100 800 600]);    plot(cities(:,1), cities(:,2), &#39;ko&#39;, &#39;MarkerSize&#39;,10, &#39;LineWidth&#39;,2);    hold on;        % 绘制路线    plot(cities(tour,1), cities(tour,2), &#39;b-&#39;, &#39;LineWidth&#39;,2);    plot([cities(tour(end),1), cities(tour(1),1)],...         [cities(tour(end),2), cities(tour(1),2)], &#39;b-&#39;, &#39;LineWidth&#39;,2);        % 标注城市    for i &#x3D; 1:n        text(cities(i,1), cities(i,2)+1, sprintf(&#39;C%d&#39;,i),...            &#39;HorizontalAlignment&#39;,&#39;center&#39;);    end        title(sprintf(&#39;TSP最优路径 (距离&#x3D;%.2f)&#39;, value(Objective)));    xlabel(&#39;X坐标&#39;);    ylabel(&#39;Y坐标&#39;);    grid on;    axis equal;        % 绘制时间序列（如果是动态TSP）    figure;    plot(1:n+1, tour, &#39;b-o&#39;, &#39;LineWidth&#39;,2);    yticks(1:n);    title(&#39;访问顺序&#39;);    xlabel(&#39;步骤&#39;);    ylabel(&#39;城市编号&#39;);    grid on;else    error(&#39;TSP求解失败&#39;);end%% 4. 对比：使用Gurobi的预热启动（Warm Start）% 提供初始可行解（如最近邻启发式）initial_tour &#x3D; nearest_neighbor_tour(cities); % 自定义函数x_initial &#x3D; zeros(n,n);for k &#x3D; 1:n-1    x_initial(initial_tour(k), initial_tour(k+1)) &#x3D; 1;endx_initial(initial_tour(n), initial_tour(1)) &#x3D; 1;% 设置初始解ops_warm &#x3D; sdpsettings(ops, &#39;gurobi.Start&#39;, struct(&#39;x&#39;,x_initial));% 再次求解tic;result_warm &#x3D; optimize(Constraints, Objective, ops_warm);time_warm &#x3D; toc;fprintf(&#39;\n预热启动效果:\n&#39;);fprintf(&#39;原求解时间: %.2f秒\n&#39;, result.solverinfo.solvetime);fprintf(&#39;预热后时间: %.2f秒\n&#39;, time_warm);fprintf(&#39;加速比: %.2f%%\n&#39;, (1-time_warm&#x2F;result.solverinfo.solvetime)*100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第14天：考试与项目答辩">0.4.4. 第14天：考试与项目答辩</h3><h4 id="全天（6小时）：模拟项目答辩">0.4.4.1. 全天（6小时）：模拟项目答辩</h4><p><strong>14.1 答辩题目（随机抽取）</strong></p><pre class="line-numbers language-none"><code class="language-none">题目1：微电网调度优化- 需求：设计一个含5台柴油发电机、2个储能、光伏和负荷的微电网日前调度模型- 约束：功率平衡、机组爬坡、储能动力学、旋转备用- 目标：最小化运行成本- 要求：提交代码、结果曲线、经济性分析报告题目2：无人机路径规划- 需求：5架无人机从基地出发，访问20个目标点，返回基地- 约束：每架无人机航程&lt;50km，避障（禁飞区），时间窗- 目标：最小化总航程- 要求：3D可视化路径，冲突检测分析题目3：智能制造排程- 需求：10台机器，20个订单，每个订单多道工序- 约束：机器能力、工序先后、交付时间窗- 目标：最小化延迟交付惩罚- 要求：Gantt图，机器利用率分析<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>14.2 评分标准</strong></p><div class="table-container"><table><thead><tr><th>维度</th><th>权重</th><th>评分细则</th></tr></thead><tbody><tr><td><strong>模型正确性</strong></td><td>40%</td><td>约束完整、逻辑正确、变量定义合理</td></tr><tr><td><strong>代码质量</strong></td><td>30%</td><td>结构化、注释清晰、矩阵化（无for循环）</td></tr><tr><td><strong>结果分析</strong></td><td>20%</td><td>可视化专业、灵敏度分析、经济性评估</td></tr><tr><td><strong>创新性</strong></td><td>10%</td><td>额外功能（如鲁棒性、多目标）</td></tr></tbody></table></div><p><strong>14.3 项目报告模板</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 项目报告生成脚本（自动生成Word&#x2F;PDF）% 1. 设置报告模板import mlreportgen.report.*;import mlreportgen.dom.*;rpt &#x3D; Report(&#39;optimization_project&#39;,&#39;pdf&#39;);% 2. 添加标题页tp &#x3D; TitlePage();tp.Title &#x3D; &#39;微电网经济调度优化项目&#39;;tp.Author &#x3D; &#39;学习者&#39;;tp.Date &#x3D; date;add(rpt,tp);% 3. 添加问题描述chapter1 &#x3D; Chapter(&#39;问题描述&#39;);add(chapter1, Paragraph(&#39;本研究考虑一个含...&#39;));add(rpt, chapter1);% 4. 添加数学模型chapter2 &#x3D; Chapter(&#39;数学模型&#39;);eq1 &#x3D; FormalEq(&#39;$min \sum_&#123;t&#x3D;1&#125;^&#123;24&#125; \sum_&#123;g&#x3D;1&#125;^&#123;6&#125; (a_g P_&#123;g,t&#125;^2 + b_g P_&#123;g,t&#125; + c_g u_&#123;g,t&#125;)$&#39;);add(chapter2, eq1);add(rpt, chapter2);% 5. 添加代码chapter3 &#x3D; Chapter(&#39;MATLAB实现&#39;);code &#x3D; ProgrammaticCode(which(&#39;microgrid_uc.m&#39;));add(chapter3, code);add(rpt, chapter3);% 6. 添加结果图chapter4 &#x3D; Chapter(&#39;结果分析&#39;);fig &#x3D; Figure();fig.Snapshot &#x3D; &#39;results_figure1.png&#39;;add(chapter4, fig);add(rpt, chapter4);% 7. 生成报告close(rpt);rptview(rpt);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="第五阶段：避坑指南与进阶学习（第4周补充）">0.5. 第五阶段：避坑指南与进阶学习（第4周补充）</h2><h3 id="第15天：新手必踩的100个坑（精选TOP-20）">0.5.1. 第15天：新手必踩的100个坑（精选TOP 20）</h3><h4 id="上午（3小时）：代码级错误">0.5.1.1. 上午（3小时）：代码级错误</h4><p><strong>TOP 1-5：变量类型混淆</strong><br><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% ❌ 错误1：数值变量和sdpvar混用x &#x3D; sdpvar(1);if x &gt; 0  % 错误！x是符号变量，不能用于逻辑判断    y &#x3D; 1;end% ✅ 正确：用YALMIP的逻辑约束y &#x3D; binvar(1);Constraints &#x3D; [implies(x&gt;&#x3D;0, y&#x3D;&#x3D;1), implies(x&lt;0, y&#x3D;&#x3D;0)];% ❌ 错误2：赋值与约束混淆x &#x3D; sdpvar(1);x &#x3D; 5;  % 这是赋值，不是约束！x不再是sdpvar% ✅ 正确：Constraints &#x3D; [x &#x3D;&#x3D; 5];% ❌ 错误3：使用非线性函数x &#x3D; sdpvar(1);obj &#x3D; sin(x);  % 错误！YALMIP不支持sin% ✅ 正确：用分段线性近似obj &#x3D; pwlf(x, [-pi -pi&#x2F;2 0 pi&#x2F;2 pi], [-1 0 1 0 -1]);  % 近似sin(x)% ❌ 错误4：矩阵乘法维度错误x &#x3D; sdpvar(3,1);A &#x3D; rand(2,3);obj &#x3D; x&#39;*A*x;  % 错误！x&#39;是1×3，A是2×3% ✅ 正确：obj &#x3D; x&#39;*(A&#39;*A)*x;  % A&#39;*A是3×3% 或obj &#x3D; sum((A*x).^2);% ❌ 错误5：未初始化的约束数组Constraints &#x3D; [];  % 正确初始化for i &#x3D; 1:10    Constraints &#x3D; [Constraints, x(i) &lt;&#x3D; i];  % 逐个添加end% 如果忘记初始化：Constraints未定义，报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><strong>TOP 6-10：求解器设置错误</strong><br><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% ❌ 错误6：求解器名称拼写错误ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;);  % 正确ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;Gurobi&#39;);  % 错误！大小写敏感% ❌ 错误7：参数名称错误ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;MIPGap&#39;,0.01);  % 错误！应加前缀% ✅ 正确：ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.MIPGap&#39;,0.01);% ❌ 错误8：设置了求解器不支持的参数ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;barrier_iterations&#39;,100);% Gurobi没有barrier_iterations参数，正确的是&#39;gurobi.BarIterLimit&#39;% ❌ 错误9：时间单位混淆ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.TimeLimit&#39;,100);% 单位是秒！设置为100以为100分钟，实际是100秒% ❌ 错误10：verbose和OutputFlag混淆sdpsettings(&#39;verbose&#39;,0)  % 抑制YALMIP输出sdpsettings(&#39;gurobi.OutputFlag&#39;,0)  % 抑制Gurobi输出% 两者都要设才能完全静默<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="下午（3小时）：建模级错误">0.5.1.2. 下午（3小时）：建模级错误</h4><p><strong>TOP 11-15：约束建模错误</strong><br><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% ❌ 错误11：严格不等式Constraints &#x3D; [x &gt; 0];  % 错误！MILP不支持严格不等式% ✅ 正确：epsilon &#x3D; 1e-6;Constraints &#x3D; [x &gt;&#x3D; epsilon];  % 或x &gt;&#x3D; 0（如果允许零）% ❌ 错误12：双向约束写错% 意图：10 &lt;&#x3D; x &lt;&#x3D; 20Constraints &#x3D; [10 &lt;&#x3D; x &lt;&#x3D; 20];  % MATLAB解析错误% ✅ 正确：Constraints &#x3D; [10 &lt;&#x3D; x, x &lt;&#x3D; 20];% ❌ 错误13：非凸二次约束x &#x3D; sdpvar(2,1);Constraints &#x3D; [x&#39;*[1 0;0 -1]*x &gt;&#x3D; 0];  % 非凸！Gurobi报错% 解决方案：用Cplex或Bonmin求解器，或改写约束% ❌ 错误14：循环约束索引错误x &#x3D; sdpvar(10,1);Constraints &#x3D; [];for i &#x3D; 1:10    Constraints &#x3D; [Constraints, x(i) &lt;&#x3D; x(i+1)];  % i+1&#x3D;11越界！end% ✅ 正确：for i &#x3D; 1:9    Constraints &#x3D; [Constraints, x(i) &lt;&#x3D; x(i+1)];end% ❌ 错误15：使用绝对值导致非线性x &#x3D; sdpvar(1);obj &#x3D; abs(x);  % 这不是线性！% ✅ 正确：引入辅助变量y &#x3D; sdpvar(1);Constraints &#x3D; [y &gt;&#x3D; x, y &gt;&#x3D; -x];obj &#x3D; y;  % 最小化y等价于最小化|x|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><strong>TOP 16-20：算法与理论错误</strong><br><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">% ❌ 错误16：QP问题Q矩阵非正定Q &#x3D; [1 2; 2 1];  % 特征值&#x3D;-1,3，非正定x &#x3D; sdpvar(2,1);obj &#x3D; x&#39;*Q*x;  % Gurobi警告&quot;Q matrix is not positive semi-definite&quot;% 解决方案：Q &#x3D; 0.5*(Q+Q&#39;) + epsilon*eye(n); 强制对称正定% ❌ 错误17：未检查求解状态直接使用结果result &#x3D; optimize(C,obj,ops);x_opt &#x3D; value(x);  % 如果求解失败，value返回NaN% ✅ 正确：if result.problem &#x3D;&#x3D; 0    x_opt &#x3D; value(x);else    error(&#39;求解未成功，结果无效&#39;);end% ❌ 错误18：MILP问题设置了连续算法ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.Method&#39;,0);  % 对MILP，Method只在根节点有效% 对MILP，主要控制分支定界的是&#39;MIPFocus&#39;、&#39;Heuristics&#39;等% ❌ 错误19：混合精度问题% 数据：load &#x3D; 100.000000000001（CSV导入产生的微小误差）% 约束：sum(gen) &#x3D;&#x3D; load% 结果：可行解可能因数值误差被判为不可行% ✅ 正确：load &#x3D; round(load, 6);  % 保留6位小数% 或设置容差：ops &#x3D; sdpsettings(&#39;gurobi.FeasibilityTol&#39;,1e-5);% ❌ 错误20：未使用暖启动重复求解% 场景：滚动优化中，每次从头求解for k &#x3D; 1:100    optimize(C,obj,ops);  % 每次都冷启动，慢！end% ✅ 正确：利用前次解x_previous &#x3D; [];for k &#x3D; 1:100    if ~isempty(x_previous)        ops.Start &#x3D; x_previous;  % 暖启动    end    result &#x3D; optimize(C,obj,ops);    x_previous &#x3D; value(x);  % 保存当前解end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><hr><h3 id="第16天：进阶主题与前沿技术">0.5.2. 第16天：进阶主题与前沿技术</h3><h4 id="上午（3小时）：鲁棒优化与分布鲁棒">0.5.2.1. 上午（3小时）：鲁棒优化与分布鲁棒</h4><p><strong>16.1 经典鲁棒优化（Box Uncertainty）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：需求不确定，在±10%范围内波动P_load_nominal &#x3D; 100;  % 标称负荷uncertainty &#x3D; 0.1;     % 10%波动% 传统确定性优化P_gen &#x3D; sdpvar(1);Constraints_det &#x3D; [P_gen &#x3D;&#x3D; P_load_nominal];optimize(Constraints_det, P_gen^2);% 鲁棒优化（最坏情况）delta &#x3D; sdpvar(1);  % 不确定性变量Constraints_robust &#x3D; [    P_gen &gt;&#x3D; P_load_nominal + delta,  % 必须覆盖最坏情况    -uncertainty*P_load_nominal &lt;&#x3D; delta &lt;&#x3D; uncertainty*P_load_nominal];optimize(Constraints_robust, P_gen^2);  % 最大化最坏情况下的性能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>16.2 分布鲁棒优化（Wasserstein球）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：基于历史数据的分布鲁棒% 假设有100个历史负荷场景load_scenarios &#x3D; load_data_hist;  % 100×1向量% Wasserstein球半径epsilon &#x3D; 0.1;% 定义概率分布变量p &#x3D; sdpvar(100,1);Constraints &#x3D; [    p &gt;&#x3D; 0,    sum(p) &#x3D;&#x3D; 1];% 构造分布鲁棒约束（较复杂，需对偶转换）% YALMIP的distribute函数可简化% 此处为概念性代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="下午（3小时）：多目标优化与帕累托前沿">0.5.2.2. 下午（3小时）：多目标优化与帕累托前沿</h4><p><strong>16.3 加权和方法</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：成本 vs 排放 双目标Cost &#x3D; ...;   % 经济性目标Emission &#x3D; ...; % 环境目标% 加权和weights &#x3D; linspace(0,1,11);  % 11个权重组合pareto_front &#x3D; zeros(2,length(weights));for i &#x3D; 1:length(weights)    Objective &#x3D; weights(i)*Cost + (1-weights(i))*Emission;    optimize(Constraints, Objective, ops);        pareto_front(1,i) &#x3D; value(Cost);    pareto_front(2,i) &#x3D; value(Emission);end% 绘制帕累托前沿plot(pareto_front(1,:), pareto_front(2,:), &#39;-o&#39;);xlabel(&#39;成本&#39;);ylabel(&#39;排放&#39;);title(&#39;帕累托前沿&#39;);grid on;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>16.4 epsilon约束法</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 更精确的方法：epsilon约束cost_target &#x3D; linspace(min_cost, max_cost, 20);emission_min &#x3D; zeros(size(cost_target));for i &#x3D; 1:length(cost_target)    Constraints_epsilon &#x3D; [Constraints, Cost &lt;&#x3D; cost_target(i)];    optimize(Constraints_epsilon, Emission, ops);    emission_min(i) &#x3D; value(Emission);endplot(cost_target, emission_min, &#39;-x&#39;);xlabel(&#39;成本上限&#39;);ylabel(&#39;最小排放&#39;);title(&#39;epsilon约束法帕累托前沿&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="第17天：工业界最佳实践">0.5.3. 第17天：工业界最佳实践</h3><h4 id="上午（3小时）：代码工程化">0.5.3.1. 上午（3小时）：代码工程化</h4><p><strong>17.1 函数封装与模块化</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 规范的优化项目结构% 项目文件夹结构：% microgrid_project&#x2F;%   ├── main.m                    % 主脚本%   ├── data&#x2F;%   │   ├── case30.mat           % 系统数据%   │   └── load_forecast.csv    % 负荷预测%   ├── src&#x2F;%   │   ├── build_model.m        % 模型构建%   │   ├── solve_model.m        % 求解器调用%   │   ├── post_process.m       % 后处理%   │   └── visual_results.m     % 可视化%   └── results&#x2F;%       ├── figures&#x2F;%       └── logs&#x2F;%%% build_model.m 示例function [Constraints, Objective, vars] &#x3D; build_model(system_data, params)% 构建微电网调度模型% 输入：%   system_data - 系统数据结构体%   params - 参数结构体% 输出：%   Constraints - 约束集合%   Objective - 目标函数%   vars - 变量结构体% 解包数据n_gen &#x3D; system_data.n_gen;n_hour &#x3D; params.n_hour;% 定义变量vars.P_gen &#x3D; sdpvar(n_gen, n_hour);vars.u_on &#x3D; binvar(n_gen, n_hour);% 构建约束（此处简化，实际更复杂）Constraints &#x3D; [];Constraints &#x3D; [Constraints, vars.P_gen &gt;&#x3D; 0];Constraints &#x3D; [Constraints, vars.P_gen &lt;&#x3D; system_data.P_max*vars.u_on];% 目标函数cost_coeff &#x3D; system_data.cost_coeff;Objective &#x3D; sum(sum(cost_coeff(1)*vars.P_gen.^2 + ...                    cost_coeff(2)*vars.P_gen + ...                    cost_coeff(3)*vars.u_on));end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>17.2 错误处理与日志系统</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%%% solve_model.m 示例（工业级错误处理）function [result, vars_opt] &#x3D; solve_model(Constraints, Objective, vars, ops)% 求解模型并处理错误% 创建日志文件log_file &#x3D; sprintf(&#39;solver_log_%s.txt&#39;, datestr(now,&#39;yyyymmdd_HHMMSS&#39;));diary(log_file);try    % 求解    result &#x3D; optimize(Constraints, Objective, ops);        % 检查求解状态    switch result.problem        case 0            fprintf(&#39;求解成功！\n&#39;);            % 提取结果            vars_opt &#x3D; extract_results(vars);        case 1            warning(&#39;模型无可行解&#39;);            vars_opt &#x3D; [];            % 调用冲突分析            conflict_analysis(Constraints);        case 2            warning(&#39;模型无界&#39;);            vars_opt &#x3D; [];        otherwise            error(&#39;求解失败，错误代码: %d&#39;, result.problem);    end    catch ME    % 捕获异常    fprintf(&#39;求解过程中发生异常: %s\n&#39;, ME.message);    vars_opt &#x3D; [];    result.problem &#x3D; -1;enddiary off;end%%% 辅助函数function vars_opt &#x3D; extract_results(vars)% 递归提取所有变量的值fields &#x3D; fieldnames(vars);for i &#x3D; 1:length(fields)    field &#x3D; fields&#123;i&#125;;    if isa(vars.(field), &#39;sdpvar&#39;)        vars_opt.(field) &#x3D; value(vars.(field));    elseif isstruct(vars.(field))        vars_opt.(field) &#x3D; extract_results(vars.(field));    endendend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="下午（3小时）：性能优化与并行计算">0.5.3.2. 下午（3小时）：性能优化与并行计算</h4><p><strong>17.3 YALMIP + Parallel Computing Toolbox</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 场景：多场景并行优化（场景间独立）% 创建并行池parpool(8);  % 启动8个worker% 定义场景scenarios &#x3D; 1:50;% 并行求解results &#x3D; parallel_fcn(@solve_single_scenario, scenarios);% 关闭并行池delete(gcp);%%% 辅助函数function result &#x3D; solve_single_scenario(scenario_id)% 每个worker独立求解一个场景% 加载场景数据load([&#39;scenario_&#39;,num2str(scenario_id),&#39;.mat&#39;]);% 构建并求解模型（与主程序隔离）Constraints &#x3D; ...;Objective &#x3D; ...;ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.OutputFlag&#39;,0);  % 抑制输出result &#x3D; optimize(Constraints, Objective, ops);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>17.4 Gurobi分布式优化（Tuning Tool）</strong></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 使用Gurobi Tuning Tool自动调参% 保存模型savemodel(Constraints, Objective, &#39;model.mps&#39;);% 调用gurobi调参工具% 命令行：gurobi_cl TuneTimeLimit&#x3D;3600 TuneCriterion&#x3D;2 model.mps% 在MATLAB中：system(&#39;gurobi_cl TuneTimeLimit&#x3D;3600 TuneCriterion&#x3D;2 model.mps&#39;);% 调参后生成.prm文件，加载使用ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.Params&#39;,&#39;tuned.prm&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="附录：学习资源与工具链">0.6. 附录：学习资源与工具链</h2><h3 id="A-1-必备资源清单">0.6.1. A-1 必备资源清单</h3><pre class="line-numbers language-none"><code class="language-none">【软件安装】- MATLAB R2024b（官网：mathworks.com）- Gurobi 11.0（官网：gurobi.com，学术许可证免费）- YALMIP（GitHub：yalmip&#x2F;yalmip）【文档教程】- YALMIP Wiki：yalmip.github.io（最好的教材，所有函数说明）- Gurobi Documentation：www.gurobi.com&#x2F;documentation（参数详解）- MATLAB Optimization Toolbox：mathworks.com&#x2F;help&#x2F;optim&#x2F;【书籍推荐】- 《Convex Optimization》（Boyd &amp; Vandenberghe）- 理论基石- 《Optimization in Engineering》（Kirby）- 工程应用- 《Model Predictive Control》（Rawlings &amp; Mayne）- MPC圣经【在线课程】- Coursera: Discrete Optimization（含MILP）- edX: Optimization Methods for Business Analytics- B站：搜索&quot;YALMIP教程&quot;（有中文视频）【论文复现】- 电力系统：《Unit commitment in electric power systems》（Wood &amp; Wollenberg）- 路径规划：《A survey on the vehicle routing problem》- MPC：《Model predictive control: theory and practice》【社区支持】- Stack Overflow: 标签[yalmip], [gurobi]- YALMIP Google Groups: 提问和查看历史问题- GitHub Issues: 报告bug和请求功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="A-2-自测题与答案">0.6.2. A-2 自测题与答案</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 自测题1：判断模型类型% 根据以下目标函数和约束，判断问题类型（LP&#x2F;MILP&#x2F;QP&#x2F;QCP）% (1) % minimize x1 + 2*x2% s.t. x1 + x2 &gt;&#x3D; 5%      x1, x2 &gt;&#x3D; 0% 答案：LP（线性目标，线性约束，连续变量）% (2)% minimize x1^2 + x2^2% s.t. x1 + x2 &gt;&#x3D; 5%      x1, x2 ∈ &#123;0,1&#125;% 答案：非凸QP（二元变量+二次目标）→ Gurobi可处理但可能慢% (3)% minimize x1 + y1% s.t. x1 + 2*y1 &gt;&#x3D; 3%      x1 &gt;&#x3D; 0, y1 ∈ &#123;0,1&#125;% 答案：MILP（线性混合整数）% (4)% minimize x1&#39;*Q*x1 + c&#39;*x1 + y1&#39;*d% s.t. ||x1||_2 &lt;&#x3D; 10%      y1 ∈ &#123;0,1&#125;% 答案：MIQCP（混合整数二次约束）%% 自测题2：代码纠错% 以下代码有3处错误，请找出并修正x &#x3D; sdpvar(5,1);y &#x3D; binvar(5,1);Constraints &#x3D; [];for i &#x3D; 1:5    Constraints &#x3D; [x(i) + y(i) &lt;&#x3D; 10];  % 错误1：覆盖而非追加endobj &#x3D; sum(x.^2 + y);ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;MIPGap&#39;,0.01);  % 错误2：参数名optimize(Constraints, obj, ops);disp(&#39;最优值:&#39;, value(obj));  % 错误3：语法% 修正后：x &#x3D; sdpvar(5,1);y &#x3D; binvar(5,1);Constraints &#x3D; [];for i &#x3D; 1:5    Constraints &#x3D; [Constraints, x(i) + y(i) &lt;&#x3D; 10];  % 追加endobj &#x3D; sum(x.^2 + y);ops &#x3D; sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;,&#39;gurobi.MIPGap&#39;,0.01);  % 加前缀result &#x3D; optimize(Constraints, obj, ops);if result.problem &#x3D;&#x3D; 0    fprintf(&#39;最优值: %.4f\n&#39;, value(obj));  % 正确语法end%% 自测题3：建模练习% 建模问题：仓库选址，最小化建设+运输成本% 数据：%  - 5个候选仓库位置，建设成本[100,150,120,90,110]万元%  - 10个客户，需求量[30,20,15,25,18,22,30,12,28,35]吨%  - 运输成本：距离(km)×0.5元&#x2F;吨km% 要求：写出完整MATLAB代码% 答案框架：clear;% 数据build_cost &#x3D; [100,150,120,90,110];demand &#x3D; [30,20,15,25,18,22,30,12,28,35];distance &#x3D; rand(5,10)*50;  % 随机生成距离transport_rate &#x3D; 0.5;% 变量y &#x3D; binvar(5,1);  % 选址x &#x3D; sdpvar(5,10); % 运输量% 约束C &#x3D; [];C &#x3D; [C, sum(x,2) &lt;&#x3D; 1000*y];  % 只有建的仓库才能供应C &#x3D; [C, sum(x,1)&#39; &#x3D;&#x3D; demand]; % 满足需求C &#x3D; [C, x &gt;&#x3D; 0];% 目标Build_Cost &#x3D; build_cost&#39;*y;Transport_Cost &#x3D; sum(sum(distance*transport_rate.*x));Objective &#x3D; Build_Cost + Transport_Cost;% 求解optimize(C, Objective, sdpsettings(&#39;solver&#39;,&#39;gurobi&#39;));disp(value(Objective));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="结语：从入门到精通">0.7. 结语：从入门到精通</h2><p>恭喜你完成了这个万字学习路线图！回顾四周的学习：</p><ul><li><strong>第1周</strong>：环境搭建 + LP/MILP/QP基础 → <strong>掌握YALMIP语法</strong></li><li><strong>第2周</strong>：经典模型实战 → <strong>理解建模思维</strong></li><li><strong>第3周</strong>：参数调优 + 调试技巧 → <strong>解决实际问题</strong></li><li><strong>第4周</strong>：综合项目 + 避坑指南 → <strong>具备独立项目能力</strong></li></ul><p><strong>下一步建议：</strong></p><ol><li><strong>立即行动</strong>：明天就开始第1天的环境安装，不要拖延</li><li><strong>项目驱动</strong>：结合你的研究方向，1个月内完成一个真实项目</li><li><strong>代码复用</strong>：保存所有写过的代码，建立个人函数库</li><li><strong>持续学习</strong>：关注YALMIP GitHub更新，每年Gurobi新版本都有性能提升</li><li><strong>社区贡献</strong>：在Stack Overflow回答YALMIP问题，教学相长</li></ol><p><strong>记住：优化建模是艺术 + 科学的结合。多练习、多调试、多总结，你很快就能成为团队中的”优化专家”！</strong></p><p>祝学习顺利！</p><hr><p><strong>文档信息：</strong></p><ul><li>版本：v2.5（2025年12月更新）</li><li>作者：基于YALMIP官方文档与工业实践整理</li><li>许可证：CC BY-NC-SA 4.0（非商业用途可自由分享）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OR 导论</title>
      <link href="/2025/12/01/%E7%A0%940/operation/OR_intruction/"/>
      <url>/2025/12/01/%E7%A0%940/operation/OR_intruction/</url>
      
        <content type="html"><![CDATA[<h1 id="intruction">1. intruction</h1><p>问题 - 》模型 - 》 算法</p><h2 id="原理-ARRD">1.1. 原理 ARRD</h2><ul><li>A - approximation ， 近似求解</li><li>R - reformulation ,  对问题进行重构</li><li>R - relaxation , 对复杂约束进行处理 - 线性松弛</li><li>D - Decomposition, 大规模问题分割子问题</li></ul><h1 id="线性导论">2. 线性导论</h1><p>所有的向量都需要使用 <code>mathbf</code> 加粗， 且向量均为列向量</p><script type="math/tex; mode=display">\mathbf{a}</script><div class="table-container"><table><thead><tr><th>类型</th><th>表示方法</th><th>展示</th></tr></thead><tbody><tr><td>标量</td><td>普通</td><td>$x$</td></tr><tr><td>向量</td><td>粗体小写字母，使用 <code>\mathbf</code></td><td>$\mathbf{x}$</td></tr><tr><td>矩阵</td><td>粗体大写字母，使用 <code>mathbf</code></td><td>$\mathbf{X}$</td></tr><tr><td>张量</td><td>花体字母， 使用 <code>\mathcal</code></td><td>$\mathcal{X}$</td></tr></tbody></table></div><h2 id="单纯形法">2.1. 单纯形法</h2><blockquote><p>性质：最优点一定在顶点 / 无穷点 上</p></blockquote><ol><li>从一个顶点开始</li><li>判断是否是最优点，stop， 否则进入 3 中</li><li>如何移动到相邻顶点</li></ol><p>顶点是由两条边相交形成的，然后形成一个顶点，作为待解点</p><h2 id="stardard-form">2.2. stardard form</h2><ol><li>最小化目标函数</li><li>等式约束</li><li>变量非负</li></ol><script type="math/tex; mode=display">\begin{aligned}& \min c^T x \\& s.t \quad \mathbf{A}\mathbf{x} = \mathbf{b}\\& \quad x \geq 0 \end{aligned}</script><p>使用乘法，按照元素方式看待模型</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251204204345353.png" alt="image-20251204204345353"></p><h2 id="converting-to-stardard">2.3. converting  to stardard</h2><h3 id="目标中存在绝对值">2.3.1. 目标中存在绝对值</h3><blockquote><p>使用 $x^+. x^-$ 来替换|x|</p></blockquote><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251204204902956.png" alt="image-20251204204902956"></p><p>按照更换公式, $|x| , x$ 的表示方法如下：</p><script type="math/tex; mode=display">|x| = x^+ + x^- \\x = x^+ - x^-</script><h3 id="不等式转换为等式">2.3.2. 不等式转换为等式</h3><p>增加 松弛变量</p><blockquote><ol><li>小于时， 加上松弛变量</li><li>大于时， 减去松弛变量</li></ol></blockquote><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251204205341113.png" alt="image-20251204205341113"></p><h3 id="最大化-gt-最小化">2.3.3. 最大化 - &gt; 最小化</h3><blockquote><p>增加 “-”</p></blockquote><script type="math/tex; mode=display">\max c^T x = -min -c^T x</script><h2 id="凸函数">2.4. 凸函数</h2><p>凸函数定义：开口向上，具有最小值</p><h3 id="性质">2.4.1. 性质</h3><ol><li><p>$f_1, f_2, \dots, f_n$ 都是凸函数 $y = max(f(x))$ 也是凸函数</p></li><li><p>一堆线性函数求最大值，是凸函数 ，</p><script type="math/tex; mode=display">\max\limits_{i = 1 ... m }{c^T x + b }</script><p>一个凸函数可以转换为多个分段线性函数</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251204210755244.png" alt="Piecewise linear convex objective  "></p></li></ol><blockquote><p>使用多个线性的 max 表示之后，可以使用引入新变量，消除 max </p></blockquote><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251204211051471.png" alt="引用新变量，消除 max "></p><p>max 可以引用一个新的变量替换</p><blockquote><p>|X|  = max{x, -x }</p></blockquote><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251204211628454.png" alt="image-20251204211628454"></p><h2 id="linear-algebra">2.5. linear algebra</h2><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251204212120685.png" alt="image-20251204212120685" style="zoom:80%;"></p><h1 id="几何表示">3. 几何表示</h1><p>一个等式 是 一个超平面（对应维度的子空间， 少一个维度的空间）</p><p>可以叫对应的几何空间划分为三个部分，</p><ul><li>上空间</li><li>超平面</li><li>下空间</li></ul><p>梯度方向是函数增大的方向， - 梯度方向是函数减小的方向</p><h2 id="多面体-polyhedron">3.1. 多面体 polyhedron</h2><p>一个多面体 = 多个半空间相交 </p><p>顶点 = 极值点 = 基可行解</p><h2 id="代数运算">3.2. 代数运算</h2><h3 id="求基解">3.2.1. 求基解</h3><p>紧约束： 等式 对 顶点的确定起了作用， 成为紧约束，即 在这里不等式 变为等式</p><p>顶点定义： 紧约束数量  =  dim()</p><p>等式约束本身就是紧约束，需要再选出部分非等式约束，组成 n 个约束</p><p>此时，求得的顶点是基解，但是由于缺少其他约束， 因此不是可行解</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251205174953597.png" alt="image-20251205174953597"></p><ol><li>线性约束数量 为 m ,  变量数量为 n </li><li>M &lt; n</li><li>此时将 <code>n - m</code> 个  $ x_i \geq 0$ 变为紧约束，可以求解了</li></ol><p>求出的 x 是基解 ， 即所有线段相交的节点</p><script type="math/tex; mode=display">Ax = b \\\begin{bmatrix} B & N \end{bmatrix} \begin{bmatrix} x_B \\ x_N \end{bmatrix} = b \\Bx_B + Nx_N = b \\Bx_B = b \rightarrow x_B = B^{-1}b</script><p>B 是基变量， N 为非基变量</p><h3 id="基解退化">3.2.2. 基解退化</h3><h4 id="几何">3.2.2.1. 几何</h4><p>其他约束在这里也是紧约束，有一个新的约束也是紧约束，是多余的紧约束， 反映在代数中有一个基解为 0 .</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251209182132499.png" alt="基解几何表示" style="zoom:150%;"></p><h4 id="代数">3.2.2.2. 代数</h4><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251209182538869.png" alt="image-20251209182538869" style="zoom: 150%;"></p><p>多个基  可能会对应一个基解</p><p>= 》 变换不同的解，但是相交的节点相同</p><h4 id="基解与节点坐标关系">3.2.2.3. 基解与节点坐标关系</h4><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251209183042320.png" alt="image-20251209183042320"></p><h2 id="simplex-methed">3.3. simplex methed</h2><div class="table-container"><table><thead><tr><th></th><th>$x_B^T$</th><th>$x_N^T$</th><th>rhs</th></tr></thead><tbody><tr><td>$x_B$</td><td>$B$</td><td>$N$</td><td>$b$</td></tr><tr><td>$r^T$</td><td>$0^T$</td><td>$c_N^T - c_B^T N$</td><td>$0^T$</td></tr></tbody></table></div><hr><div class="table-container"><table><thead><tr><th></th><th>$x_B^T$</th><th>$x_N^T$</th><th>rhs</th></tr></thead><tbody><tr><td>$x_B$</td><td>$I$</td><td>$B^{-1} N$</td><td>$B^{-1} b$</td></tr><tr><td>$r^T$</td><td>$0^T$</td><td>$c_N^T - c_B^T B^{-1} N$</td><td>$- c_B^T B^{-1} b$</td></tr></tbody></table></div><blockquote><p>$B^{-1} b$ 代表可行方向， 初始解开始可行，之后变换过程中，始终保持 rhs 为正</p><p>$c_N^T - c_B^T B^{-1} N$ 是最优方向</p></blockquote><p>顶点数量为 $C_{n}^{n-m} =  C_{n}^{m}$ ， 数量较大，选择一种有效的方式筛选点</p><ol><li>选择初始点</li><li>从起始点 -》 最优点</li></ol><p>对于线性规划， 是一个凸函数问题， <strong>局部最优点  =  全局最优</strong></p><ol><li>选择可行方向</li><li>选择最好的方向</li><li>方向上行动的距离</li></ol><h3 id="可行方向">3.3.1. 可行方向</h3><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251209211842303.png" alt="image-20251209211842303" style="zoom: 80%;"></p><ol><li><p>开始 $ Ax = b$</p></li><li><p>移动 x 到 下一个顶点， 为 $ x + \theta d$</p></li><li><p>依旧满足顶点公式， $A(x + \theta d)  = b$,  得到 $A \theta d = 0$</p></li><li><script type="math/tex; mode=display">A = \begin{bmatrix}B, N\end{bmatrix} , d = \begin{bmatrix} d_B \\ d_N \end{bmatrix}</script><p>其中 $ d_N$ 仅 修改 $ d_j$ ， $d_B$ 作为待修改对象（人为规定，不要问为什么）</p><p>计算得到 </p><script type="math/tex; mode=display">d_B = -B^{-1} * A_j</script></li></ol><p>可行方向 $[d_B, d_N]$ ， 对于非退化解， 方向一定是可行，否则，不可行</p><h3 id="好的方向">3.3.2. 好的方向</h3><p>原目标函数 </p><script type="math/tex; mode=display">C^T x ，转换为 C^T（x + \theta d)</script><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251209213512392.png" alt="image-20251209213512392" style="zoom: 100%;"></p><p>reduced_cost 需要保证 $\bar{c}_j = c_j - c_B^T B^{-1} A_J$  , 结果值 要小于 0</p><h3 id="最优条件">3.3.3. 最优条件</h3><ol><li>所有的基 向量大于 0 </li><li>所有非基变量的 reduced cost 大于 0 ，没有可以下降的非基 时候， </li></ol><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251209213930140.png" alt="image-20251209213930140" style="zoom: 150%;"></p><h3 id="行动的步长">3.3.4. 行动的步长</h3><p>$ cost = \theta * \bar{c} $ ，所以 $\theta$ 步长值 尽可能大</p><p>最大步长受限于 $X_B + \theta d_B$， 基变量的值需要满足非负变量</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251209214846730.png" alt="image-20251209214846730" style="zoom:150%;"></p><h2 id="LP-基本矩阵">3.4. LP 基本矩阵</h2><p>$x_B$ 是基变量， $ x_N $ 是非基变量</p><p>其中 <script type="math/tex">Ax = b , A = [B | N] , x =\begin{bmatrix} x_B \\ x_N\end{bmatrix}</script></p><p>其中满足 $Ax = Bx_B + Nx_N  = b$ ， 计算得到 $ x = [x_B ;  x_N] = [B^{-1}b ; 0] $</p><p>式子可以改写为 <img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251213214033236.png" alt="image-20251213214033236"></p><p>其中 M 成为基本矩阵</p><h2 id="两阶段-simplex-method">3.5. 两阶段 simplex method</h2><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251213221428119.png" alt="image-20251213221428119" style="zoom: 67%;"></p><p>原因 ： 当约束中不存在不等式约束 时， 不能增加新的变量， 构成基， 因此不容易找到初始可行解</p><p>方法： 使用两阶段单纯形法</p><h1 id="搜索算法">4. 搜索算法</h1><p>梯度方向 = 当前 $x$  附近， 函数下降最快的方向</p><script type="math/tex; mode=display">目标值的变化值 = f(x + \lambda \Delta x) - f(x) \approx \sum_j (\frac{\partial f}{\partial x_j}) (\lambda \Delta x) = \lambda \Delta f(x) * \Delta x)</script><p>内积最大的情况下， $\Delta f(x) = \Delta x$</p><ol><li>max 变化值最大的 $\Delta x $ ， 取值 $\Delta x = \Delta f(x)$</li><li>min 变化值最大的 $\Delta x $ ， 取值 $\Delta x = -\Delta f(x)$</li></ol><h2 id="有约束的搜索方向">4.1. 有约束的搜索方向</h2><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251215113912567.png" alt="图 1"></p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251215113930482.png" alt="图 2"></p><ol><li>当 $ \Delta x = - \alpha_i^T$ 时候， 沿着可行方向的梯度无法下降，找到局部最优点，此时无法再下降</li><li>否则，需要保持上图 1 中的约束条件</li></ol><h2 id="解析解">4.2. 解析解</h2><p>做出一定的假设，使用解析解进行灵敏度分析</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251215115540793.png" alt="image-20251215115540793"></p><p>解析解是对输入参数的表示，原有输入参数中使用数值表示，是特定情况下的固定结果</p><p>即将原有的公式中的式子使用代数表示， 如图下所示：</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251215115711185.png" alt="模型求解"></p><h1 id="dual-method">5. dual method</h1><p>pinal - &gt; dual</p><p>reformation 一个心得问题，通过 relation 的方式实现</p><ol><li>提供新的求解方案</li><li>提供另一个求解思路</li></ol><h2 id="legrengean-relation">5.1. legrengean relation</h2><script type="math/tex; mode=display">min \space x^2+y^2 \\s.t. \space  x+ y = 1</script><p>对不满足约束的情况增加惩罚 $p$, 得到</p><script type="math/tex; mode=display">min \space  x^2 + y^2 + p(x+y-1)</script><p>希望惩罚越来越小，所有 $()$ 内式子会趋近于 0</p><h2 id="Pinal-gt-dual">5.2. Pinal - &gt; dual</h2><p>$g(p) = c^Tx + p^t(b- Ax)$ 是松弛后的问题，每一 $g(P)$ 对应 原函数 $P$ 的下界，目标转换为对求解 $max \space g(p)$</p><p>然后通过推导，</p><script type="math/tex; mode=display">min \space g(p)= min \space c^Tx + p^T b - p^T Ax =  min \space( p^Tb + (c^T - p^T A)x)</script><p>因为 min 对 x 变量求最小值， 对 $P^T b$ 是常量，得到</p><script type="math/tex; mode=display">min \space g(p) = p^T b + min \space (c^T-p^TA) x</script><p>因为 $x \geq 0$ ，所以，当 $c^T - p^TA \geq 0$ 时， min 可以取得最小值 0 ， 函数值取值为 $p^T b$</p><p>最终问题转换为</p><script type="math/tex; mode=display">max \space p^T b \\s.t. \space p^T A \leq c^T</script><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216152503376.png" alt="p-&gt; d 纸质推导过程"></p><h3 id="剩余形式约束转换">5.2.1. 剩余形式约束转换</h3><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216152607748.png" alt="对偶问题约束转换"></p><h2 id="dualtiy-theory">5.3. dualtiy theory</h2><ol><li>weak duality</li><li>strong duality</li><li>complementary slackness</li></ol><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216162952255.png" alt="对偶性"></p><h3 id="weak-duality">5.3.1. weak duality</h3><script type="math/tex; mode=display">c^T X > b^T w</script><h3 id="strong-duality">5.3.2. strong duality</h3><script type="math/tex; mode=display">c^T x = c_B^T x_B \\= c_B^T B^{-1} b\\= w^T b \\= b w^T</script><p>所以，得到 $w^T = c_B^TB^{-1}$</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216163421611.png" alt="image-20251216163421611"></p><p>对偶问题可行 -》 原问题最优</p><h3 id="对偶理论">5.3.3. 对偶理论</h3><p>P 问题 f-b(feasible - bounded)  与 对应 D 问题的 f-b</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216163754240.png" alt="image-20251216163754240"></p><h3 id="互补松弛理论">5.3.4. 互补松弛理论</h3><p>互补定义： </p><ol><li>P 的松弛 * D 和可行解 = 0</li><li>D 的松弛 * P 的可行解 = 0</li></ol><p>互补松弛理论： 满足互补松弛理论时 = 》 x 时最优解， w 也是最优解</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216170315772.png" alt="对偶松弛理论"></p><h3 id="KKT-条件">5.3.5. KKT 条件</h3><p>对于线性问题， 满足互补松弛理论，即可获得问题的最优解</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216170426742.png" alt="image-20251216170426742"></p><h2 id="经济学变量">5.4. 经济学变量</h2><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251216212935057.png" alt="经济学定义"></p><h3 id="互补松弛解释">5.4.1. 互补松弛解释</h3><p>​    见 PPT</p><h1 id="Integer-programming">6. Integer programming</h1><h2 id="分配问题">6.1. 分配问题</h2><p>好的，我将为你提取图片中展示的三种指派问题（Assignment Problem）的 LaTeX 表达式。</p><hr><h3 id="指派问题-0-1-Assignment-Problem">6.1.1. 指派问题 (0-1 Assignment Problem)</h3><p><strong>目标函数：</strong></p><script type="math/tex; mode=display">\min \sum_{i = 1}^n \sum_{j = 1}^n c_{ij}x_{ij}\\s.t. \quad \sum_{j = 1}^n x_{ij} = 1, \quad \forall i\\\sum_{i = 1}^n x_{ij} = 1, \quad \forall j\\x_{ij} \in \{0,1\}, \quad \forall i, j</script><hr><h3 id="二次指派问题-Quadratic-Assignment-Problem">6.1.2. 二次指派问题 (Quadratic Assignment Problem)</h3><p><strong>目标函数：</strong></p><script type="math/tex; mode=display">\min \sum_{i} \sum_{j} \sum_{k > i} \sum_{l \ne j} c_{i, j, k, l} \cdot x_{ij} \cdot x_{kl}\\s.t. \quad \sum_{j = 1}^n x_{ij} = 1, \quad \forall i\\\sum_{i = 1}^n x_{ij} = 1, \quad \forall j\\x_{ij} \in \{0,1\}, \quad \forall i, j</script><p>分阶段分配：</p><ol><li>从 $x_{ij}$ 表示部门 $i$ 分配到地点 $j$</li><li>从 $x_{kl}$ 表示部门 $k$ 分配到地点 $l$</li></ol><p>$c_{i,j,k,l}$， 表示 $i ,j$ 在 $k, l$ 位置交互的 cost</p><p>$x_{ij} * x_{kl}$ 表示只有分配了这条链路， 才会产生 cost</p><hr><h3 id="广义指派问题-Generalized-Assignment-Problem">6.1.3. 广义指派问题 (Generalized Assignment Problem)</h3><p><strong>目标函数：</strong></p><script type="math/tex; mode=display">\min \sum_{i = 1}^m \sum_{j = 1}^n c_{ij}x_{ij}\\s.t. \quad \sum_{j = 1}^n x_{ij} = 1, \quad \forall i\\\sum_{i = 1}^m s_{ij}x_{ij} \leq b_j, \quad \forall j\\x_{ij} \in \{0,1\}, \quad \forall i, j</script><h2 id="IP-solution">6.2. IP solution</h2><ol><li>LP 问题近似， 先视为连续问题，再求解</li><li>启发式算法，求解质量无保证</li><li>近似算法，求解质量具有保证</li></ol><h2 id="classic-problem">6.3. classic  problem</h2><h3 id="几何覆盖问题">6.3.1. 几何覆盖问题</h3><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251218095654943.png" alt="几何覆盖定义"></p><h3 id="设施选择问题">6.3.2. 设施选择问题</h3><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251218100252960.png" alt="设施选择"></p><ol><li>变量：有两类，<ol><li>整数Y ，用于控制某个站点被建立，</li><li>实数X，表示建立的站点i 对 节点J 的服务比例</li></ol></li></ol><h3 id="网络问题">6.3.3. 网络问题</h3><h3 id="车间调度问题">6.3.4. 车间调度问题</h3><p>决策变量: $x_{j,k}$  工作j 在设备K 上工作</p><p>约束：</p><ol><li><p>$j, j’$ 约束 ， j 必须在 $j’$之前</p><script type="math/tex; mode=display">x_{j,k} + p_{j, k} \leq x_{j',k}</script></li><li><p>$j, j’$ 共同使用设备 $K $, 同一台机器不能同时服务同一个设备</p><ol><li><p>$j’$ 的开始时间需要小于 $j$的结束时间，严格约束</p><script type="math/tex; mode=display">x_{j,k} + p_{j,k} \leq x_{j',k} + M(1 - y_{j,j',k})</script><p>当$y_{j,j’,k}$表示 作业 j 在 $j’$之前使用k ，值为1，表示可以使用</p></li><li><p>当$y_{j,j’,k}$ 为0 时， 约束生效，表示 $j’$必须在$j $之前完成</p><script type="math/tex; mode=display">x_{j',k}+p_{j',k} \leq x_{j,k}+ My_{j, j',k}</script><blockquote><p>$y_{j,j’,k}$， 表示 j ,j’ 在k 上具有冲突</p><p>M 的约束作用， 当y 生效时，等式松弛，约束不起作用</p><p>当y =  0 时，约束严格作用</p></blockquote></li></ol></li></ol><h2 id="0-1-modeling">6.4. 0-1 modeling</h2><ol><li><p>0-1选择问题，是否选择</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251218160554039.png" alt="image-20251218160554039"></p></li><li><p>关联约束</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251218160612332.png" alt="image-20251218160612332"></p></li><li><p>组合中选择一个</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251218160705405.png" alt="image-20251218160705405"></p></li><li><p>选择约束条件</p><p><img src="/2025/12/01/%E7%A0%940/operation/OR_intruction/image-20251218160802044.png" alt="image-20251218160802044"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 运筹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学基础</title>
      <link href="/2025/11/25/%E7%A0%940/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/11/25/%E7%A0%940/%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>目标： 选择满足<strong>约束条件</strong>下， 最大化 <strong>目标</strong> 的最优决策</p><p>步骤： </p><ol><li>建模： 实际问题 -》数学形式表达</li><li>求解： 设计算法，求解目标</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>研0 阶段学习</title>
      <link href="/2025/11/25/%E7%A0%940/README/"/>
      <url>/2025/11/25/%E7%A0%940/README/</url>
      
        <content type="html"><![CDATA[<ol><li><p>java 开发项目学习</p><p><a href="https://www.cnblogs.com/yupi/p/15166218.html">人类高质量 Java 学习路线【一条龙版】 - 程序员鱼皮 - 博客园</a></p></li><li><p>深度学习项目</p><ol><li><a href="https://github.com/wdndev?tab=repositories">大模型开发笔记</a></li></ol></li><li><p>运筹学学习项目</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>supervised learn</title>
      <link href="/2025/10/15/python/mechine_learn/mechine-learn/"/>
      <url>/2025/10/15/python/mechine_learn/mechine-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="一">1. 一</h1><h2 id="supervised-learn">1.1. supervised learn</h2><p>给出正确答案学习</p><p>分为：1. regressiong ; 2. classification</p><h2 id="unsupervised-learn">1.2. unsupervised learn</h2><p>发现数据的不同结构，区分成不同数据</p><h1 id="二">2. 二</h1><h2 id="模型">2.1. 模型</h2><p>由 x 推向 y 的引导函数</p><script type="math/tex; mode=display">h_\theta(x) = \theta_0 + \theta_1 x</script><h2 id="cost-function">2.2. cost function</h2><p>均方误差，$\frac{1}{2m}$ 求导时候消去 1/2， 且 cost funtion 不变</p><script type="math/tex; mode=display">\underset{\theta_0， \theta_1}{minimize} \frac{1}{2m} \sum_{i = 1}^{m}(h(x^i) - y^i)^2</script><p>求出使 cost funtions 最小的参数 $\theta$ </p><h2 id="gradient-descend">2.3. gradient descend</h2><script type="math/tex; mode=display">\theta_j = \theta_j - \alpha \frac{\partial}{\partial_j}J(\theta_0, \theta_1)  \space \space for j = 0 and j = 1</script><p>严格要求计算步骤，优先算完右半部分，在计算左半部分赋值</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251015202451659.png" alt="image-20251015202451659" style="zoom:100%;"></p><p>$\frac{\partial}{\partial_j}J(\theta_0, \theta_1) $ 是梯度下降的方向， $\alpha $ 沿着下降方向下降的幅度</p><p><strong>learn rate $\alpha$ 不需要不断缩小</strong>， 因为随着靠近局部最小值， 梯度逐渐下降，  逐渐趋近于 0</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251015204044375.png" alt="image-20251015204044375"></p><p>batch 梯度下降 考虑了整体训练集</p><h1 id="三">3. 三</h1><h2 id="matrix">3.1. matrix</h2><h3 id="边界形式">3.1.1. 边界形式</h3><ol><li>pmatrix 小括号</li><li>bmatrix 方括号</li><li>Bmatrix 大括号</li><li>vmatrix 行列式</li><li>Vmatrix 双竖线</li><li>matrix   没有边界符号， 使用 <code>\left[</code> <code>\right]</code> 增加边界</li></ol><h3 id="元素">3.1.2. 元素</h3><ol><li>&amp; 分割同行元素</li><li><code>\\</code> 分割列元素</li><li>省略号<ol><li><code>\dots</code> 水平省略号</li><li><code>\vdots</code> 垂直省略号</li><li><code>\ddots</code> 对角省略号</li></ol></li></ol><script type="math/tex; mode=display">\begin{pmatrix}a & b & \dots& c \\\vdots & \vdots & \ddots  & \vdots\\a & b & \dots&c\end{pmatrix}</script><h3 id="slice">3.1.3. slice</h3><p> eg : </p><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 & 3 \\11 & 12 & 13 \\11 & 12 & 13 \\4 & 5 & 6\end{bmatrix}</script><ol><li>dim  = row <em> columns  ， 即为 4</em> 3</li><li>$A_{ij}$ 表示 $i_{th}$ row  ，$j_{th}$ columns 的元素</li></ol><h2 id="compute">3.2. compute</h2><ol><li>scalar multiplication / division / addition / subtraction </li><li>addtion / subtraction 需要 matrix dim 相同</li></ol><h3 id="matrix-vector">3.2.1. matrix * vector</h3><script type="math/tex; mode=display">h(x) = \theta_0 + \theta_1 * x</script><p>矩阵乘法表示为</p><script type="math/tex; mode=display">\begin{matrix}[1, x]* [\theta_0, \theta_1]^t\end{matrix}</script><ol><li>[1, x] 中每组数据与 $\theta$ 相乘，所以 顺序为 $x*\theta$</li><li>常数项 $\theta$ 表示该特征 始终为 1 </li></ol><h3 id="matrix-matrix">3.2.2. matrix *  matrix</h3><p>有多个 hypothesis 函数 </p><script type="math/tex; mode=display">h_1(x) = \theta_{0,1} + \theta_{1,1} * x \\h_2(x) = \theta_{0,2} + \theta_{1,2} * x \\h_3(x) = \theta_{0,3} + \theta_{1,3} * x</script><p>参数组成矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}\theta_{0,1} & \theta_{0,2} & \theta_{0,3} \\\theta_{1,1} & \theta_{1,2} & \theta_{1,3} \\\end{bmatrix}</script><p>使用 matrix 表示</p><script type="math/tex; mode=display">[1, x] * [theta_0, theta_1, theta_2]^T</script><h1 id="四">4. 四</h1><h2 id="more-feature">4.1. more feature</h2><script type="math/tex; mode=display">x = [x_0, x_i, \dots, x_n]</script><p>hypothesis 修改为 $h(x) = \theta_0 + \theta_1<em> x_1 + \theta</em>x_n$， 其中 define $x_0 = 1$</p><p>所以，$h(x) = \theta^t * x$</p><h2 id="gradient-descend-1">4.2. gradient descend</h2><p>$\frac{\partial}{\partial x} h(x) =  x $</p><script type="math/tex; mode=display">L(x) = \underset{\theta}{minimize} = \frac{1}{2m} (\sum{h(x) - y})^2</script><script type="math/tex; mode=display">\frac{\partial}{\partial \theta} L(x) =  m(\sum(h(x) -y ))* X</script><script type="math/tex; mode=display">\theta = \theta -m(\sum(h(x) -y ))* X</script><h2 id="feature-scaling">4.3. feature scaling</h2><p>数据进行归一化，数据的差距缩小，使用梯度下降速度更快</p><p>因此，数据训练前，一定需要对数据进行归一化</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251016212727906.png" alt="image-20251016212727906"></p><p>归一化方法</p><script type="math/tex; mode=display">minmax = \frac{x - min}{min-max} 缩放到（0，1）\\stand = \frac{x - u}{\sigma}，符合正太化分布 \\</script><p> 鲁棒归一化</p><script type="math/tex; mode=display">robust = \frac{x- median(x)}{IQR(x)}\\median(x) 是 x 的中位数 \\IQR(x) = Q_3 - Q_1</script><h2 id="learn-rate">4.4. learn rate</h2><p>确定模型收敛情况：</p><ol><li><strong>绘制图形观察</strong></li><li>自收敛测试， 当一次 iteration 收敛到一定值时，自动停止</li></ol><p>测试不同的 $\alpha $ , 观测收敛情况</p><h2 id="more-feature-1">4.5. more feature</h2><ol><li>使用更多的 feature ， $ h(x) = \theta_0 + \theta_1 <em> feature_1 + \theta_2</em> feature_2$</li><li>使用 polynomial feature 拟合， 使用 feature 的多项式拟合, $ h(x) = \theta_0 + \theta_0 <em> feature_1 + \theta_2 </em> feature_1^2 + \theta_3 * \sqrt{feature_1}$</li></ol><h2 id="normal-equation">4.6. normal equation</h2><p>用于求解Loss 函数的最小值$\theta$ , </p><div class="table-container"><table><thead><tr><th>gradient descend</th><th>normal equation</th></tr></thead><tbody><tr><td>需要 learn rate</td><td></td></tr><tr><td>需要many iterations</td><td>直接计算</td></tr><tr><td>使用面广</td><td>只适用于较小的feature ,</td></tr></tbody></table></div><script type="math/tex; mode=display">\theta = (X^T * X)^{-1} X^T*y</script><p>难点在于$X^T <em> X$ ， X 是 m </em> n 矩阵， $X^T <em> X$ 矩阵维度为$n</em>n $ ，与特征维度有关， 矩阵求逆的复杂度$O(n^3)$， 仅适用于较小feature</p><h3 id="X-t-X-non-invertible">4.6.1. $X^t* X$ non-invertible</h3><ol><li>redundant feature ，重复相关的feature ，删除相关的feature</li><li>number &lt;= feature ，特征数量较少， 增加数据/减少特征/正则化 </li></ol><h1 id="五">5. 五</h1><h2 id="operation">5.1. operation</h2><ol><li><code>~</code> 非 相当于 <code>!</code></li><li><code>sprintf(&quot;string %0.2f&quot;, a)</code> 格式化自负床</li></ol><h3 id="生成矩阵">5.1.1. 生成矩阵</h3><ol><li><code> </code> 或者’,’ 分割行 [1 2 3]</li><li>‘；’ 分割列 [1; 2; 3]</li><li><code>v = 1 : 6</code>， 生成【1，6】数组</li><li>ones(2， 3)  , zeros(2, 3), rand(2,3), randn(2,100)</li><li>eye(2)</li></ol><blockquote><p> hist(data, n), 绘制n 各方格立方图</p><p>help eye</p></blockquote><h3 id="data">5.1.2. data</h3><ol><li>size(data, dim) ，</li><li>length(vector), length(data), 返回最大matrix</li><li>load ‘xxx.mat’, save ‘xxx.mat’ xxx， <strong>文件名只能使用 ‘’</strong></li><li>who 显示变量， whos 显示变量详细</li><li>A() ， 使用() 取出元素， A（[1,2], :) 取出1，2 所有元素</li><li>数组拼接 A = (A, B) , 列拼接， A= （A;B）行拼接</li></ol><h3 id="compute-1">5.1.3. compute</h3><ol><li>$<em>$ 矩阵乘法， $.</em>$ 点乘，</li><li>find(A) 矩阵中为1 的元素，</li><li>max(A, []， dim), 默认列方向， sum(A,dim), prod(A)</li><li>float() 抹去小数点， ceil(A) 进位</li></ol><h3 id>5.1.4.  </h3><p>plot(x, y, ‘color’) , xlabel, ylabel, title(), figure(1), hold on , subplot(1, 2, 1), axis([x1, x2, y1, y2]), imageesc(), colorbar, colormap gray</p><h3 id="control">5.1.5. control</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">for i &#x3D; i :10passendif 表达式elseif 表达式elsewhile 表达式endfunction [y1, y2] &#x3D; name(x)y &#x3D; x;y &#x3D; x;end <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>addpath</p><h1 id="classification">6. classification</h1><p>$y 取值于 {0， 1， 2}$固定值</p><p>预测值$\in [0, 1]$， 使用threshold 区分区间确定类型</p><p>regression问题</p><ol><li><p>预测曲线受极值影响</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251019204259717.png" alt="image-20251019204259717"></p></li><li><p>$y \notin [0, 1]$， </p></li></ol><p>因此使用， Logistic Regression </p><h2 id="logistic-sigmoid-function">6.1. logistic / sigmoid function</h2><script type="math/tex; mode=display">g(x) = \frac{1}{1+e^{-x}}</script><p>函数图像，g(x) $\in$ [0,1]</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251019205241683.png" alt="image-20251019205241683"></p><p>h(x) 定义，在输入x 情况，预测为 y = 1的概率，$p(y = 1| x, \theta)$</p><p> y = 0 的概率为 1- h(x)</p><h2 id="decision-boundary">6.2. decision boundary</h2><p>决策边界 由 $\theta$ 参数决定， 计算出$\theta$ 获得决策边界</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251019210727035.png" alt="image-20251019210727035"></p><h2 id="cost-function-1">6.3. cost function</h2><script type="math/tex; mode=display">L(x) = \frac{1}{2m} \sum_{i=1}^{m}cost(h_\theta(x), y)</script><p>cost function 尽可能为 convex function ，便于之后梯度优化</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251019212137633.png" alt="image-20251019212137633"></p><p>regression 中 $cost(h(x), y) = (h(x)- y)^2$</p><p>classification 中， 使用 MSE ，不是一个convex function ，不利于之后优化</p><script type="math/tex; mode=display">cos(h_\theta(x), y) = \begin{cases}    -log(h_\theta(x)) & \text{if } y = 1 \\    -log(1 - h_\theta(x)) & \text{if } y = 0 \end{cases}</script><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251019212533349.png" alt="image-20251019212533349"></p><h2 id="gradient-descend-2">6.4. gradient descend</h2><p>cost function 等价为</p><script type="math/tex; mode=display">cost(h(x), y) = -y* log(h(x)) -(1-y) log(1-h(x))\\ L(\theta) = -\frac{1}{2m}[\sum_{i=1}^{m}y* log(h(x)) +(1-y) log(1-h(x)) ]</script><p>求导后的结果，求导过程省略，太麻烦了, 求导结果 和 regression cost function 求导结果一致</p><script type="math/tex; mode=display">\frac{\partial}{\partial_\theta} L(\theta) = \sum_{i=1}^{m} (h_\theta(x) - y) x</script><p>梯度下降公式</p><script type="math/tex; mode=display">\theta = \theta - \alpha * \sum_{i=1}^{m} (h_\theta(x) - y) x</script><h2 id="advanced-optimization">6.5. advanced optimization</h2><ol><li>gradient descent</li><li>conjugate descent</li><li>BFGS</li><li>L-BFGS </li></ol><p>优点： </p><ol><li>自动选择$\alpha $</li><li>优化速度更快</li></ol><p>缺点： 内部复杂</p><h3 id="编写cost-function">6.5.1. 编写cost function</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">function [jVal, gradient] &#x3D; costFunction(theta)% 需要返回函数值，和梯度下降值jVal &#x3D; (theta(1) - 5)^2;gradient &#x3D; zeros(2,1);gradient(1) &#x3D; 2*(theta(1) - 5);end% 编写优化函数options &#x3D; optimset(&#39;GradObj&#39;, &#39;on&#39;, &#39;MaxIter&#39;, 100); % 优化选择参数initialTheta &#x3D; zeros(2,1); % 初始值[optTheta, functionVal , exitFlag] &#x3D; fminunc(@costFunction, initiatTheta, options);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="more-class">6.6. more class</h2><p>one vs all</p><p>分类三种类别 1， 2， 3 拆分为三个分类</p><ol><li>1 - rest</li><li>2 - rest</li><li>3 - rest</li></ol><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251019221901670.png" alt="image-20251019221901670"></p><p>then , max $h_3(x)$ 作为最终结果</p><h1 id="七">7. 七</h1><h2 id="overfit">7.1. overfit</h2><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251019223154219.png" alt="image-20251019223154219" style="zoom: 80%;"></p><p>使用test 验证是否出现了过拟合</p><p>一个原因： 数据量 &lt; 特征数量</p><ol><li>人为减少特征数量</li><li>使用正则化，保留特征，减少$ \theta values$</li></ol><h2 id="regulation">7.2. regulation</h2><p>参数$\theta$ 使用更小的值， </p><ol><li>模型更简单</li><li>减少过拟合</li></ol><p>在损失函数中  增加对 $\theta$ 的约束</p><p>$ L(\theta) = \frac{1}{2m} [\sum_{i=1}^{m}(h_{\theta}(x^{(i)}- y^{(i)})^2 + \lambda * \sum_{j = 1}^{n} \theta_j^2)]$</p><h3 id="使用normal-function">7.2.1. 使用normal function</h3><p>公式如下：$ y = x * \theta^t$</p><p>求解公式 :</p><script type="math/tex; mode=display">\theta = (X^T*X + \lambda * \begin{pmatrix}                            0 & 0 & \dots& 0 \\                            0 & 1 & \dots& 0 \\                            \vdots &\vdots & 1 & \vdots \\                            0 & 0 & 0 & 1                            \end{pmatrix}    )^{-1} * X^Ty</script><h2 id="八">7.3. 八</h2><h3 id="神经网路">7.3.1. 神经网路</h3><p>线性回归缺点： 当 特征维度较高时， 特征数量较多</p><p>线性回归只适合较为简单的函数，维度较高的函数，二次项组合数量较多</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251104211423785.png" alt="image-20251104211423785"></p><p>neural networks：接收一定信息，通过一定算法训练，能够处理接受的信息</p><h3 id="neuron-model">7.3.2. neuron model</h3><h4 id="神经元">7.3.2.1. 神经元</h4><p> <img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251104213924342.png" alt="image-20251104213924342"></p><ol><li>input: 输入数据</li><li>神经元处理： h(x), 使用激活函数 （sigmoid/ logistic)</li><li>output: 输出结果</li></ol><h4 id="神经网络">7.3.2.2. 神经网络</h4><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251104214724745.png" alt="image-20251104214724745"></p><ol><li>输入层： 输入数据</li><li>中间层： 中间处理过程</li><li>输出层：输出结果</li></ol><p>每一层之间使用转移矩阵进行连接，例如输入层X, 中间层A</p><script type="math/tex; mode=display">A = \theta^1* X \\\theta^1 \in R^{3,4}</script><h4 id="中间层组合">7.3.2.3. 中间层组合</h4><p>一层神经元可以表示一个神奇的表达式</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251104220903475.png" alt="image-20251104220903475"></p><p>多个简单层组合，表示更为复杂的层</p><script type="math/tex; mode=display">\lambda * A = \lambda * \alpha</script><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251104223025190.png" alt="image-20251104223025190"></p><h1 id="九">8. 九</h1><h2 id="代价函数">8.1. 代价函数</h2><p>神经网络有K个输出， 所有 需要 $Y_k$ 进行标识</p><p><img src="/2025/10/15/python/mechine_learn/mechine-learn/image-20251105211214283.png" alt="image-20251105211214283"></p><p>所以，交叉熵增加输出维度 K</p><script type="math/tex; mode=display">J(\theta) = -\frac{1}{m}[\sum_{i=1}^m\sum_{k=1}^k y_k^{(i)}* log(h_\theta(x^{(i)})_k) + (1- y_{k}^{(i)} )log(1-(h_\theta(x^{(i)})_k))] + 多所有权重进行正则化</script><p>所有权重正则化公式：</p><script type="math/tex; mode=display">\frac{\lambda}{2m}\sum_{l=1}^{l-1} \sum_{i = 1}^{s_l}\sum_{j=1}^{s(l+1)}(\theta_{i,j}^{(l)})^2</script><p>表示 对 第l 层， 第L层中$\theta$  维度为(sl, sl+1)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>selenium</title>
      <link href="/2025/09/20/python/selenium/selenium/"/>
      <url>/2025/09/20/python/selenium/selenium/</url>
      
        <content type="html"><![CDATA[<h1 id="selenium">1. selenium</h1><h2 id="基础组成">1.1. 基础组成</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium import webdriverfrom selenium.webdriver.common.by import By# 配置属性url &#x3D; &quot;https:&#x2F;&#x2F;web.com&quot;driver &#x3D; webdriver.Chrome()# 请求访问driver.get(url)driver.implicityly_wait(0.5) # 允许查找时长为0.5s# 查找组件text &#x3D; driver.find_element(by &#x3D; By.ID, value &#x3D; )submit_button &#x3D; driver.find_element(by &#x3D; By.Id, value &#x3D; &quot;button&quot;)# 操作组件text.send_keys(&quot;text&quot;)sumbit_button.click()# 结束driverdriver.quit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="test使用方法">1.2. test使用方法</h2><p>测试函数名 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def test_one():    assert 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pytest test.pypytest -q test.py # 静默输出，正确不输出，错误输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>策略</th><th>就绪状态</th><th>备注</th></tr></thead><tbody><tr><td>normal</td><td>complete</td><td>默认值, 等待所有资源下载</td></tr><tr><td>eager</td><td>interactive</td><td>DOM 访问已准备就绪, 但诸如图像的其他资源可能仍在加载</td></tr><tr><td>none</td><td>Any</td><td>完全不会阻塞 WebDriver</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> http </tag>
            
            <tag> request </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 多文件</title>
      <link href="/2025/09/18/c/base_study/c++-%E5%A4%9A%E6%96%87%E4%BB%B6/"/>
      <url>/2025/09/18/c/base_study/c++-%E5%A4%9A%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="c-多文件">1. c++多文件</h1><h2 id="使用g-命令">1.1. 使用g++ 命令</h2><ol><li>先 <code>-c</code>生成<code>.o</code>文件，再进行<code>-o</code>链接</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ -c a.cpp b.cppg++ a.o b.o -o test # 输出.exe名称为test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>直接<code>-o</code>编译生成</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ a.cpp b.cpp -o test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>指定头文件位置 <code>-i</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ a.cpp b.cpp -o test -i include<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">target_link_libraries(myproject PRIVATE $&#123;CMAKE_BINARY_DIR&#125;&#x2F;include)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="相关命令">1.2. 相关命令</h2><h3 id="o优化级别">1.2.1. -o优化级别</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-o0 默认不优化-o1 基本优化-02 高级别优化-03 最高级别优化-os 优化代码大小-ofast 开始所有-03优化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="g生成调试信息，配合gdb使用">1.2.2. -g生成调试信息，配合gdb使用</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-o0 -g <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>cmake 关系：使用CMAKE_BUILD_TYPE 控制优化级别</p><div class="table-container"><table><thead><tr><th>Debug</th><th><code>-o0 -g</code></th></tr></thead><tbody><tr><td>Release</td><td>-o2 或 -o3</td></tr><tr><td>RelWithDebInfo</td><td>-o2 -g</td></tr><tr><td>MinSizeRel</td><td>-os</td></tr></tbody></table></div></blockquote><h3 id="启用警告">1.2.3. 启用警告</h3><ul><li><code>-wall</code>  启用常用警告</li><li><code>-Wextra</code> 启用<code>wall</code>中没有的警告</li><li><code>-Werror</code>所有警告视为错误，有警告就会编译失败</li></ul><blockquote><p>cmake 中</p><p>add_compile_options(-Wall -Wextra -Werror)</p></blockquote><h3 id="语言标准">1.2.4. 语言标准</h3><p><code>-std = c++11</code>， 对标准进行选择</p><blockquote><pre class="line-numbers language-CMAKE" data-language="CMAKE"><code class="language-CMAKE">set(CAMEK_CXX_STANDARD 14) # 要求使用14set(CMAKE_CXX_STANDARD_REQUIRED ON) # 强制使用14set(CMAKE_CXX_EXTENSIONS OFF) # 禁用GNU扩展<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="CMakeLists-txt示例">1.3. CMakeLists.txt示例</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">cmake_minimun_required(VERSION 3.10)project(myproject , cxx) # 名称为myproject, 项目为c++ 项目set(CMAKE_CXX_STANDARD 14) # 设置c++ 标准target_include_directories(myproject PUBLIC &quot;CMAKE_CURRENT_SOURCE_DIR&quot;&#x2F;include)# 引入头文件add_compile_options(-Wall -Wextra -Werror) # 添加编译选项add_executable(myproject main.cpp)target_link_libraries(myproject PRIVATE library)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编译方法">1.3.1. 编译方法</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir buildcd buildcmake .. -G &quot;Ninja&quot; &#x2F; &quot;Make&quot; # 生成器的作用生成系统认识的命令，具有跨平台性make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加库">1.3.2. 添加库</h3><h4 id="源文件">1.3.2.1. 源文件</h4><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">set(SOURCES  src&#x2F;*)add_executable(my_app $&#123;SOURCES&#125;)target_include_directories(my_app PUBLIC &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;include&quot;) # 为目标增加头文件搜索路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="库文件">1.3.2.2. 库文件</h4><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># 使用GLOB 获取文件file(GLOB HEADERS &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;include&#x2F;*.h&quot;) # GLOB 获取include下所有.h文件set(HEADERS include&#x2F;*)# 定义库文件add_library(mylib STATICsrc&#x2F;foo.cpp$&#123;HEADERS&#125; # 库的头文件也放入库文件中，组成一个sub)target_include_directories(mylib PUBLIC    &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;include&quot;)# 将mylib 链接到 my_apptarget_link_libraries(my_app PRIVATE mylib) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加子目录">1.3.2.3. 添加子目录</h4><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># 10. 添加子目录 (如果项目有多个 CMakeLists.txt 文件)add_subdirectory(sub_project_dir)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="安装项目位置">1.3.2.4. 安装项目位置</h4><p>install 的 安装路径为<code>CMAKE_INSTALL_PREFIX</code>，通常是软件下载位置，并不是项目所在路径</p><blockquote><p>指定下载路径</p><p>cmake .. -DCMAKE_INSTALL_PREFIX = 下载路径</p></blockquote><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">install(TARGETS my_app mylibRUNTIME DESTINATION binARCHIVE DESTINATION libLIBRARY DESTINATION lib)install(DISTECTORY &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;include&quot;DESTINATION includeFILES_MATCHING PATTERN &quot;*.h&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用pybind11-创建python-库">1.3.3. 使用pybind11 创建python 库</h3><ol><li>创建calculator 库函数</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"># 创建calculator 库函数add_library(MyCalculator STATIC  src&#x2F;calculator.cpp # 所有使用的cpp文件)target_include_directories(MyCalculator PUBLIC &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;include&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>创建cpp链接 c 库函数</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_executable(my_app src&#x2F;main.cpp)target_link_libraries(my_app PRIVATE myCalculator)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>使用pybind11 创建python库</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">add_subdirectory(lib&#x2F;pybind11) # 编译得到目标pybind11::module 库add_library(python_module SHARED python_module.cpp)# 为了查找calculator target_include_directories(my_python_module PRIVATE    &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;src&quot; # 需要 calculator.h)# 链接生成 my_python_module库 target_link_libraries(my_python_module PRIVATE    MyCalculator          # 链接我们自己定义的 C++ 库    pybind11::module      # 链接 pybind11 提供的接口库)# 设置 Python 模块的输出名称和路径，使其符合 Python 的导入约定set_target_properties(my_python_module PROPERTIESPREFIX &quot;&quot;&#96;SUFFIX &quot;$&#123;PYTHON_EXTENSION_SUFFIX&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.10)project(DBGindex1 VERSION 0.1 DESCRIPTION &quot;A Hello World Project&quot;)set(CMAKE_CXX_STANDARD 17)set(CMAKE_CXX_STANDARD_REQUIRED True)file (GLOB_RECURSE SOURCE_FILES src&#x2F;*.cpp) # 获取所有.cpp文件# 查找 Pythonfind_package(Python3 COMPONENTS Development NumPy REQUIRED)# This project will output an executable fileadd_executable($&#123;PROJECT_NAME&#125; $&#123;SOURCE_FILES&#125;)# 添加pthread链接target_link_libraries($&#123;PROJECT_NAME&#125; PRIVATE pthread)# Create a simple configuration headerconfigure_file(config.h.in config.h)# 将 pybind11 添加为子目录,创建一个pybind11::embed 或 pybind11::module 等接口库 add_subdirectory(lib&#x2F;pybind11)# Include the configuration header in the buildtarget_include_directories($&#123;PROJECT_NAME&#125;    PRIVATE        &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;        &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;include&quot;        $&#123;Python3_INCLUDE_DIRS&#125;        $&#123;Python3_NumPy_INCLUDE_DIRS&#125;        &quot;$&#123;CMAKE_SOURCE_DIR&#125;&#x2F;third_party&#x2F;pybind11&#x2F;include&quot;        &quot;&#x2F;home&#x2F;rose&#x2F;soft&#x2F;matplotlib-cpp&#x2F;&quot;)target_link_libraries($&#123;PROJECT_NAME&#125;    PRIVATE        pybind11::module        $&#123;Python3_LIBRARIES&#125;        $&#123;Python3_NumPy_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 多文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/2025/09/16/python/base/python%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/09/16/python/base/python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="函数">1. 函数</h1><h2 id="lambda">1.1. lambda</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">sum_all &#x3D; lambda a : op(a) # 接收参数a，只能有一段对a的操作,返回值为操作值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参数">1.2. 参数</h2><h3 id="可变位置参数">1.2.1. 可变位置参数*</h3><p>收集额外的位置参数, <code>*参数</code> 需放在 普通参数后 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def greet_people(greeting, *names): # 收集第一个参数后的所有参数    passgreet_people(&quot;Hello&quot;, &quot;Alice&quot;, &quot;Bob&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="可变关键字参数">1.2.2. 可变关键字参数**</h3><p>收集额外的关键字参数，<code>**参数</code> 需要放在所有参数之后，包括<code>*</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def configure_device(device_id, *settings, **parameters):    passconfigure_device(&quot;dev001&quot;, &quot;enabled&quot;, &quot;logging_on&quot;, max_retries&#x3D;5, timeout_ms&#x3D;1000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>做一下实验</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">user_prefs &#x3D; &#123;&#39;theme&#39;: &#39;dark&#39;, &#39;font_size&#39;: &#39;large&#39;&#125;display_user_info(**user_prefs) # 相当于 display_user_info(theme&#x3D;&#39;dark&#39;, font_size&#x3D;&#39;large&#39;)# 输出:# kwargs 的类型是: &lt;class &#39;dict&#39;&gt;# kwargs 的内容是: &#123;&#39;theme&#39;: &#39;dark&#39;, &#39;font_size&#39;: &#39;large&#39;&#125;# 用户信息:#   Theme: dark#   Font Size: large# 结合其他关键字参数display_user_info(language&#x3D;&#39;en&#39;, **user_prefs, notifications&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学公式无法显示</title>
      <link href="/2025/09/13/%E6%9C%8D%E5%8A%A1%E5%99%A8/hexo/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
      <url>/2025/09/13/%E6%9C%8D%E5%8A%A1%E5%99%A8/hexo/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="数学公式无法显示">1. 数学公式无法显示</h1><p>转载自<a href="https://blog.csdn.net/crazy_scott/article/details/79293576">hexo下LaTeX无法显示的解决方案_hexo中latex直接空白了-CSDN博客</a></p><h2 id="安装插件">1.1. 安装插件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-math –save # mathjax插件npm uninstall hexo-renderer-marked –savenpm install hexo-renderer-kramed –save  # hexo 的渲染引擎<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="解决语义冲突">1.2. 解决语义冲突</h2><ol><li>博客根目录，<code>node_modules\kramed\lib\rules\inline.js</code>中修改第11行</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_>])/,</span><span class="token literal-property property">escape</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\([`*\[\]()#$+\-.!_>])</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>同一文件，第二十行</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><span class="token literal-property property">em</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\*((?:\*\*|[\s\S])+?)\*(?!\*)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置文件">1.3. 配置文件</h2><p>主题目录下的<code>_config.yml</code>文件</p><ol><li>mathjax 默认false 修改为 true</li><li>更换cdn 的url ，渲染速度更快</li></ol><pre class="line-numbers language-json" data-language="json"><code class="language-json"># MathJax Supportmathjax:  enable: true  per_page: true  #cdn: &#x2F;&#x2F;cdn.bootcss.com&#x2F;mathjax&#x2F;2.7.1&#x2F;latest.js?config&#x3D;TeX-AMS-MML_HTMLorMML  cdn: &#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;mathjax&#x2F;2.7.1&#x2F;MathJax.js?config&#x3D;TeX-AMS-MML_HTMLorMML<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="博客">1.4. 博客</h2><p>如果使用到数学公式，在博客的Front-matter中打开mathjax开关</p><pre class="line-numbers language-none"><code class="language-none">---title: index.htmldate: 2018-2-8 21:01:30tags:mathjax: true--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prism 更换代码块格式</title>
      <link href="/2025/09/13/%E6%9C%8D%E5%8A%A1%E5%99%A8/hexo/prism-%E6%9B%B4%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%BC%E5%BC%8F/"/>
      <url>/2025/09/13/%E6%9C%8D%E5%8A%A1%E5%99%A8/hexo/prism-%E6%9B%B4%E6%8D%A2%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="prism-更换代码块格式">1. prism 更换代码块格式</h1><h2 id="格式介绍">1.1. 格式介绍</h2><p>hexo 中支持 <a href="https://github.com/highlightjs/highlight.js">highlight.js</a> 与 <a href="https://github.com/PrismJS/prism">prismjs</a> 两种代码高亮库</p><p>两种库的下载地址</p><ol><li><a href="https://highlightjs.org/download">highlight</a></li><li><a href="https://prismjs.com/"> Prism</a></li></ol><p>hexo 切换代码高亮样式中,  在<code>highlight</code>与<code>prism</code>中进行切换</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">syntax_highlighter: prismjshighlight:  enable: false  line_number: true  auto_detect: false  tab_replace: &#39;&#39;  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  # 此处与下方的prism_plugin都需要开启  tab_replace: &#39;&#39;prism_plugin:  mode: &#39;preprocess&#39;    # realtime&#x2F;preprocess  theme: &#39;tomorrow&#39;  # 主题都行  line_number: true    # default false  #如果为true就会显示代码号，而且会分两边显示，显得不友好  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>prism 较 highlight 更好用，以下介绍prism <a href="https://www.jianshu.com/p/f395d92a1110">Hexo博客：六、prism代码高亮 - 简书</a></p><h2 id="prism">1.2. prism</h2><ol><li><p>从<a href="https://prismjs.com/"> Prism</a>下载样式</p><ol><li>主题： 自行选择，plugin中自带主题</li><li>语言： 自行选择</li><li>plugins: line_number 一定要选</li></ol></li><li><p>将样式保存在<code>hexo-blog\themes\自己的主题\source\libs\prism\prism.js</code></p><blockquote><p>或使用 <a href="https://www.jianshu.com/p/f395d92a1110">在head 和 footer 中增加js 与 css 的引用</a>， 但是我没有成功，可能是主题不同，文件后缀不同导致</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/09/11/test/"/>
      <url>/2025/09/11/test/</url>
      
        <content type="html"><![CDATA[<p>$y_i = \begin{cases} y_i^<em> &amp; \text{if } y_i^</em> &gt; 0 \\ 0 &amp; \text{if } y_i^* \le 0 \end{cases}$ </p><script type="math/tex; mode=display">隐藏输出\\mathbf{H}*t = \phi(\mathbf{X}\*t \mathbf{W}\*{xh} + \mathbf{H}*{t-1} \mathbf{W}_{hh} + \mathbf{b}_h).\输出\\mathbf{O}_t = \mathbf{H}*t \mathbf{W}*{hq} + \mathbf{b}_q.</script><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport os<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>25美赛</title>
      <link href="/2025/09/09/%E6%9D%82%E9%A1%B9/25%E7%BE%8E%E8%B5%9B%E5%9B%9E%E9%A1%BE/"/>
      <url>/2025/09/09/%E6%9D%82%E9%A1%B9/25%E7%BE%8E%E8%B5%9B%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="review-25">1. review_25</h1><h2 id="两阶段预测">1.1. 两阶段预测</h2><h3 id="LightGBM">1.1.1. LightGBM</h3><p>预测是否有概率获奖，二分类，不能获奖置为0</p><p>原理：基于决策树，采用梯度提升框架，迭代训练一系列的决策树，组合形成一个强学习器。每次迭代前，新的弱学习其会你和前一个模型预测的残差（梯度），从而逐步减少模型的误差。</p><p>主要使用：</p><ol><li>梯度采样，采样梯度较大的样本，较少训练数据量</li><li>基于EFB 特征捆绑，将少数几个特征捆绑，减少训练特征</li><li>提高训练并行策略</li></ol><p>因此成为Light，更轻量化的梯度提升机器学习框架</p><h3 id="random-effects-Tobit-model">1.1.2. random effects Tobit model</h3><script type="math/tex; mode=display">y*_i=β′x_i+ϵ_i</script><p>截断等式中，等式左边预测的并不是获得奖牌数量，因为对于真实获得0奖牌的国家，其因变量对应的$y$可能是负值，因此不能直接使用最小二乘法。</p><p>使用 $y_i = \begin{cases} y_i^<em> &amp; \text{if } y_i^</em> &gt; 0 \\ 0 &amp; \text{if } y_i^* \le 0 \end{cases}$  进行最大似然估计y，求出系数</p><p>因为模型对不同国家的不同时间进行观测， 不同国家具有潜在的异质性，需要对不同的国家增加变量$u_i$，同一国家不同时间段，个体随机效应系数是相同的</p><p>预测奖牌数量，预测过程中没有小于0的值， 因为对第一阶段中能获奖的国家进行预测，本阶段预测的国家奖牌数量均大于1</p><h2 id="量化国家-项目关系">1.2. 量化国家 - 项目关系</h2><h3 id="HHI">1.2.1. HHI</h3><p>Herfindahl-Hirschman Index  起初用于衡量企业的垄断关系，这里用来量化国家在某个项目中的领先地位</p><h3 id="IMP">1.2.2. IMP</h3><p>Monopoly Power Index  ,量化某个项目对于国家的重要程度，</p><p>$IMP = i国占据的HHI系数/ 该国家总的HHI系数$</p><h2 id="great-coach-作用">1.3. great coach 作用</h2><h3 id="HHI-1">1.3.1. HHI</h3><p>判断某个国家在该项目的领先地位变化</p><h3 id="Welch’s-t-检验">1.3.2. Welch’s t 检验</h3><script type="math/tex; mode=display">t = \frac{两部分均值之差}{两部分均值的方差}</script><p>t 值反映两者之间是否存在显著差异， 当波动性超过拒绝值时，可以判断两部分的方差具有波动，标识此处发生断点</p><p>针对教练任教时间，检测领先地位是否有断点出现，检测P值</p><h3 id="投资项目">1.3.3. 投资项目</h3><p>优先选择金牌数量少、这个项目该国家具有一定的基础并且对国家总体项目重要程度，而且这个项目开放，不要有垄断国家的出现。</p><h2 id="结果分析">1.4. 结果分析</h2><ol><li>好的教练对项目的长期提升具有极大的帮助</li><li>限制单个国家的参赛人数，可以降低项目的垄断系数，例如：足球本是资本投入项目，应有某个大国垄断，但是因为一次只有一对参赛，垄断系数较低；相反，田径比赛的垄断系数</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 数模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deepseek 调用方法</title>
      <link href="/2025/09/02/%E6%9D%82%E9%A1%B9/september/"/>
      <url>/2025/09/02/%E6%9D%82%E9%A1%B9/september/</url>
      
        <content type="html"><![CDATA[<h1 id="seqtember">1. seqtember</h1><h2 id="deepseek-调用方法">1.1. deepseek 调用方法</h2><h3 id="API-KEY设置">1.1.1. API_KEY设置</h3><ol><li><p>设置<code>URL = &quot;https://deepseek.com/chat/completions/&quot;</code></p></li><li><p>导入系统变量，借助<code>os</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os.getenv(&quot;变量名称&quot;, default &#x3D; 默认值)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="请求头">1.1.2. 请求头</h3><ol><li><code>authorization</code> :  Bearer  API_KEY， 认证信息</li><li><code>Content-Type: application/json</code>, 请求内容格式，post 仅能使用Json </li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">header &#x3D; &#123;    &quot;authorization&quot;: f&quot;Bearer &#123;API_KEY&#125;&quot;    &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="请求内容payload">1.1.3. 请求内容payload</h3><ol><li><code>model</code>: 选择模型</li><li><code>messages</code>: 发送的内容数组<ol><li><code>role</code>：角色</li><li><code>content</code>: 内容</li></ol></li><li><code>temperature</code>: 设置为 0 ，模型输出更加稳定， 1，模型输出更发散</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">payload &#x3D; &#123;    &quot;model&quot;: deepseek-chat,    &quot;messages&quot;:[        &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;:&quot;命令要求&quot; &#125;，        &#123;&quot;role&quot;: &quot;User&quot;, &quot;content&quot;: &quot;用户输入&quot;&#125;,        &#123;&quot;role&quot;: &quot;&quot;&#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发送请求">1.1.4. 发送请求</h3><p>发送内容，使用<code>post</code>请求</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">resp &#x3D; requests.post(url, header &#x3D; header, payload &#x3D; payload, timeout &#x3D;timeout)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="response-返回内容">1.1.5. response 返回内容</h3><p>返回内容在<code>resp.json()[&#39;choices&#39;][0][&#39;message&#39;][&#39;content&#39;]</code>, 提取出结果并返回</p><p><img src="/2025/09/02/%E6%9D%82%E9%A1%B9/september/image-20250902102742498.png" alt="image-20250902102742498"></p><h2 id="翻译">1.2. 翻译</h2><ol><li><p>将文本块切分成小段，指定分块大小，存放在数组中</p></li><li><p>对分段后每一段进行翻译</p><blockquote><h3 id="for-遍历">1.2.1. for 遍历</h3><ol><li><p><code>for i in 迭代器</code> </p><p>迭代器: 列表等</p></li><li><p>for idx, ck in enumerate(n):</p></li><li><p>for i in range(1, n) :</p><p>范围是[1,n）</p></li></ol></blockquote></li></ol><h2 id="day3">1.3. day3</h2><ol><li><p>输入错误： <code>EOFerror</code></p></li><li><p><code>requests.post</code> 发送请求时，需要包裹在<code>try</code>中</p></li><li><p><code>requests</code>发送数据，解析数据检查</p><ol><li><p>检查requests是否接收</p><p><code>except requests.exception.RequestException as e</code></p></li><li><p>检查网络是否</p><p><code>resp.ok</code></p></li><li><p>数据转换是否成<code>json</code></p><p><code>except ValueError</code></p></li><li><p>是否可以从数据中提取出值</p><p>`except {KeyError, IndexError, TypeError}</p></li></ol></li></ol><h3 id="使用超时重传发送">1.3.1. 使用超时重传发送</h3><p>如果遇到<code>rest</code>请求错误，或者返回的<code>resq</code>状态码有问题，使用退避算法，进行规避<code>n</code>次，超过则返回</p><ol><li>重复遍历<code>n</code>次</li><li>如果遇到<code>请求错误</code>,查看是否超过重复次数，没有，<code>time.sleep</code>一段时间后，再次运行重传</li><li>超过重复请求后，返回错误</li></ol><h2 id="day4">1.4. day4</h2><h3 id="markdown-渲染">1.4.1. markdown 渲染</h3><p>使用<code>rich</code>库</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from rich.console import Consolefrom rich.markdown import Markdownconsole &#x3D; Console()markdown_string &#x3D; &quot;&quot;&quot;&quot;&quot;&quot;markdown &#x3D; Markdown(markdown_string)console<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输出markdown-到word-文件中">1.4.2. 输出markdown 到word 文件中</h3><ol><li><p>首先检查文件目录存在</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import osoutput_dir &#x3D; os.path.dirname(output_file)if output_dir and not os.path.exist(output_dir):   os.makedirs(output_dir)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>pypandoc</code>输出</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pypandoc&quot;&quot;&quot;to: &quot;目标格式&quot;format：&quot;当前格式&quot;outputfile: &quot;输出文件&quot;&quot;&quot;&quot;pypandoc.convert_text(makedown_string, to&#x3D; &#39;docx&#39;, format &#x3D; &#39;markdown&#39;, outputfile &#x3D; output_filepath)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>同时可以尝试检查<code>ImportError , Exception</code>等错误</p></li></ol><h4 id="直接调用pandoc-命令行工具">1.4.2.1. 直接调用pandoc 命令行工具</h4><ol><li><p>创建临时文件.md存储markdown内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">temp_md_file &#x3D; &quot;temp.md&quot;with open(temp_md_file, &#39;w&#39;, encoding&#x3D; &#39;utf-8&#39;) as f:    f.write(m_str)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>subprocess.run</code>执行命令</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import subprocesscommand &#x3D; [&#39;pandoc&#39;, &#39;-f&#39;, &#39;markdown&#39;, &#39;t&#39;,&#39;doc&#39;, &#39;o&#39;, output_filename, temp_md_file]result &#x3D; subprocess.run(command, capture_output &#x3D; True, text &#x3D; True, encoding &#x3D; &#39;utf-8&#39;)if result.returncode &#x3D;&#x3D; 0:    return &quot;转换正确&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后删除临时文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if os.path.exist(temp_md_file):    os.remove(temp_md_file)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="9-8">1.5. 9.8</h2><p>win11 主要文件夹路径</p><p>任务栏：<code>C:\Users\用户名\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\TaskBar</code></p><p>开始菜单：<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs</code></p><p>IE开始菜单<code>C:\Users\用户名\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\User Pinned\StartMenu</code></p><h2 id="9-10">1.6. 9.10</h2><h3 id="path类">1.6.1. path类</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pathlib import Pathp_path &#x3D; Path(路径)## 组合路径config_path &#x3D; p_path &#x2F; &quot;config.txt&quot; .name ## 文件名.suffix ## 文件后缀.stem ## 无后缀的文件名.parent ## 父目录.is_absolute ## 是否为祖先路径.revolve() ## 转换为相对路径## 创建文件## parents&#x3D;True 会创建所有不存在的父目录## exist_ok&#x3D;True 避免目录已存在时报错Path(路径).mkdir(exist_ok &#x3D; True, parents &#x3D; True)Path(路径).touch()  ## 创建空文件p_path.write_text(str) ## 写入文件content &#x3D; file.read_text() ## 读取文件内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-11-vscode-代码补全设置">1.7. 9.11 vscode 代码补全设置</h2><p><a href="https://blog.csdn.net/weixin_51564306/article/details/132461042">开启/关闭VSCode代码提示(补全)_vscode自动提示功能怎么开-CSDN博客</a></p><h2 id="9-21-规划">1.8. 9.21 规划</h2><h3 id="运筹学">1.8.1. 运筹学</h3><p><a href="https://njuwallspider.github.io/IECourseGuide/专业核心课/运筹学Ⅰ/">运筹学Ⅰ - NJU IE学习指南</a></p><ol><li>运筹学的发展与主要内容</li><li>线性规划初步</li><li>线性规划初步</li><li>单纯形法Ⅱ</li><li>LP的应用</li><li>对偶理论</li><li>对偶单纯形法、目标规划</li><li>修正单纯形法、列生成算法</li><li>运输问题</li><li>整数规划</li><li>非线性规划</li><li>图与网络Ⅰ</li><li>图与网络Ⅱ</li></ol><h3 id="日常实习">1.8.2. 日常实习</h3><h3 id="论文复现">1.8.3. 论文复现</h3><h2 id="9-23-面试准备">1.9. 9.23 面试准备</h2><h3 id="项目1">1.9.1. 项目1</h3><h4 id="子图匹配在地理位置算法中台的潜在应用场景有哪些？">1.9.1.1. 子图匹配在地理位置算法中台的潜在应用场景有哪些？</h4><ol><li>路径规划与导航优化</li><li>POI（兴趣点）推荐与关联</li><li>地理数据质量与一致性检查</li></ol><h4 id="子图匹配NP问题”你是如何理解的">1.9.1.2. 子图匹配NP问题”你是如何理解的</h4><ol><li>组合爆炸</li><li>内存消耗</li></ol><p><strong>解决方法：</strong></p><ol><li>优化顶点识别顺序</li><li>优化节点存储</li></ol><h4 id="目标与衡量方面">1.9.1.3. 目标与衡量方面</h4><ol><li><strong>剪枝效果</strong></li><li>候选空间大小</li><li>回溯数量</li></ol><h4 id="基于最小生成树（MST）的顶点匹配顺序优化方法">1.9.1.4. 基于最小生成树（MST）的顶点匹配顺序优化方法</h4><p><img src="/2025/09/02/%E6%9D%82%E9%A1%B9/september/image-20250923202903172.png" alt="image-20250923202903172"></p><h4 id="为什么MST能够帮助尽早过滤假阳性匹配">1.9.1.5. 为什么MST能够帮助尽早过滤假阳性匹配</h4><ol><li><strong>构建最小生成树（MST）是为了得到一个“最优”的匹配顺序</strong>；匹配错误节点尽可能少，之后优化的结构更加精确</li><li><strong>减少回溯</strong>，优先匹配那些“关键”或“脆弱”的边和顶点</li></ol><p><strong>具体使用的剪枝技术：</strong></p><ol><li>度数剪枝</li><li>标签剪枝</li><li>连接性剪枝</li></ol><p><strong>DFS匹配阶段（MS更新与剪枝）</strong></p><ol><li>连接性剪枝</li><li>动态更新剩余度数</li><li>候选集精炼</li></ol><h3 id="项目2">1.9.2. 项目2</h3><h4 id="串联重复识别">1.9.2.1. 串联重复识别</h4><p>一段短的DNA序列基元（称为重复单元，Repeat Unit）以头尾相连的方式重复多次，并紧密排列在一起的结构</p><ul><li><strong>疾病研究</strong></li></ul><h4 id="“效率低、易漏检”，具体是什么原因导致了这些问题？">1.9.2.2. “效率低、易漏检”，具体是什么原因导致了这些问题？</h4><ol><li>算法复杂度过高（效率低），字符串匹配算法限制要求精度高</li><li>对变异容忍度不高</li></ol><h4 id="这种“周期性重复模式的高效定位”的思维方式">1.9.2.3. 这种“周期性重复模式的高效定位”的思维方式</h4><ol><li><strong>轨迹模式识别与预测</strong></li><li><strong>POI周期性访问行为分析：</strong></li></ol><h4 id="评估指标">1.9.2.4. 评估指标</h4><ol><li><strong>精确度 (Precision)：</strong> TP / (TP + FP)。TP为真阳性（正确识别的TRs），FP为假阳性（误报的非TRs）。</li><li><strong>召回率 (Recall)：</strong> TP / (TP + FN)。FN为假阴性（漏报的真实TRs）。</li><li><strong>F1-score：</strong> 2 <em> (Precision </em> Recall) / (Precision + Recall)。综合衡量Precision和Recall。</li></ol><h4 id="MiniDBG">1.9.2.5. MiniDBG</h4><ul><li><strong>MiniDBG的压缩：</strong> MiniDBG通过<strong>合并非分支节点和边</strong>来压缩图。它将任何不分叉（入度为1，出度为1）的节点序列合并成一个更长的节点（称为<strong>Unitig</strong>或<strong>Contig</strong>）。只有在序列出现分叉（入度或出度大于1）时，才创建新的节点。</li><li><strong>带环边 (Cycle/Loop Edge) 的处理</strong><ul><li><strong>传统DBG与循环：</strong> 传统DBG中，重复序列会形成循环（Cycles）。</li><li>MiniDBG的压缩特性使得它能更清晰地识别出代表重复单元的<strong>“简单循环”或“自环”</strong>。</li><li><strong>变异的容忍</strong>：迁移使用拥塞控制算法，在[0,2]之间TRS窗口指数型增长，[2,5]之间具有增长缓慢，10为上线，超出10后判定错误</li></ul></li></ul><h3 id="总结生成自我介绍">1.9.3. 总结生成自我介绍</h3>]]></content>
      
      
      <categories>
          
          <category> GPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> GPT </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件读取方法</title>
      <link href="/2025/09/01/%E6%9D%82%E9%A1%B9/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95/"/>
      <url>/2025/09/01/%E6%9D%82%E9%A1%B9/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="文件读取">1. 文件读取</h1><h2 id="open-函数">1.1. open()函数</h2><ol><li><p><code>open</code>函数配合<code>read() / readline() / readlines()</code></p><p><code>open(file, mode =&#39;r&#39; , encoding = None)</code></p></li><li><p><code>with</code>语句确保文件在使用完毕后自动关闭</p></li></ol><pre class="line-numbers language-pythoN" data-language="pythoN"><code class="language-pythoN">with open(&#39;example.txt&#39;,&#39;r&#39;, encoding &#x3D; &#39;utf-8&#39;) as f:    content &#x3D; f.read()  # 读取整个文件    line1 &#x3D; f.readline() # 读取第一行    lines &#x3D; f.readlines() # 读取所有，作为一个列表    for i, line in enumerate(f):        print(i, line)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件读取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.9</title>
      <link href="/2025/09/01/%E6%9D%82%E9%A1%B9/http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/"/>
      <url>/2025/09/01/%E6%9D%82%E9%A1%B9/http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="244d83837a11ec57396d06956477c3738a6002c4ab690697099b24bd4275a98a">4fbb2435fd3b6574fd4f7bd14582288411baa04027e1f23082c91553eb7a7a05e3b0e49892ffdd71c2419110ba5359048af23fa01c58111c09a6966cbef35ebb15db969fa2b6f6823fd0b1204dfe43d1e1b922e8b109bf7ac9584ba717fcf352217038f1ed9accc5ff43a75bcb868cdb7f3711f76e615dd5bb3a294e0247eea77735cdb7d843e8688457219c5ba524f38ca10771fc9b1b0b3967bb8dbcf5a54084f1ef3ff2b337d683314b3910987499dcc04fb5148d2ea5d9c448ff1db739329006c95387327c2f2a2e787e7bfc8641616b6defc0bb4f2d38f63fe9ee50c91f236c360a4d032e040a95d82ccd733811dd77984141a1fb09d06941cab79125d24e2a5788b933d466b4240c3653f11d43453778161873ea34b016345e880dcb549f809fd5d360b4d7bb56ae24b12c1008954b891a93373ba1c83f96f54e7b0ac7a8e65417045b03ed7bbdc15da9b02baed219352bc4cdadbbfe6a8da0bedee95dd4d4c93598b9663bd8682e064bd7a7088769b162d0ccee868181b48423d5f633eb54478e9580b5bc8daaf636d0cf5558ad9fb09a338689ec4647762de1a3807932f4f029d167bd181b4ea2cb4c31a251d8654804e7bfb305de13092a5d2bac51366c85938785e33a7216e83fc4d4f5bcc4284386220e58c7791ca37a01025ea168eec94d6b9304971a27c05e232443d53082b7a43d83bbadcf33b68db8917d7d13304754d7ece34413a3a3f301bac9476c96441636b01dbf910990c52db3be7ba1dfb5ef4cd74fa101ca56fe1f7ccedb53c67b85528efc3db3966b84f16bc55d179c44d77c70c41f111fa4e5eb6acf34e6c9bf6e38ccfdc3e48d08221213479d0db5c9191dadfe88b2dfa515056ea47377a92acbd8fdb50ca5115eeaf41c16ea13f487ce6534d77ba3af53411b30cc5433ef2a59c415f063560399de908edca304692417ecc1323dd7ffa1f9d0fa0e846266f7b2afd1297c34bd8842a14db4ead011cc6f26cef1573a7a6e94ec8350ec506a80cb8ad78c031caaed4ae7341a319664b1bf8cf06e3a4f90db1eeee1c94ea2f07d4052dd08b89d404750e2e3dccdeb99d8fe99e172cbcd42a6c3038f17064958f61a9d19215d5ebd4d3edd2d50c9724ffdaa20960bebddc86168d137c7479c0306ed39f12d9f5538f1543fe5640a49ac31330d4ae0fa9a5650c1582eaf048e3b7be89dd434ac0828431aee1324e4c0e7c9c20ab98687b68ca56b94fafdd2887d835b7da6fb9e3cd801a4e82d66e78da9d65fbaaf51317700ba9cff5e74036967dbef7e6f12efbff9cb4ac6a5a67be54229f35f15e336673fcf79b45881b9a0ea5a7c30aded00740ca45b7bae63ad8f4c8c30e606bd9cfc9ea6f64931ade6835e2833e5246c36e74a8d73c662f3d628122c7bdf473b3fe3977bb5dc669ebfc34731d633dd92b435f1d228511d4de47ef3542db55e4f3205c5e027855ea55ea68013a64defaf82a9ef26244b378211c441495d22d3a506813c0f7bbaf64cfd64f08c21d33c3c59e61d14fa7fbe754f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2025/08/30/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA1/"/>
      <url>/2025/08/30/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA1/</url>
      
        <content type="html"><![CDATA[<h1 id="图论-搜索">1. 图论 搜索</h1><p><strong>感谢<a href="https://programmercarl.com/0101.对称二叉树.html#思路">代码随想录</a></strong></p><h2 id="图论基础">1.1. 图论基础</h2><h3 id="邻接矩阵">1.1.1. 邻接矩阵</h3><p>邻接矩阵使用二维数组保存信息，矩阵中每个节点代表一个元素</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct Node&#123;    int data;&#125;Node;typedef vector&lt;vector&lt;Node&gt;&gt; Graph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="邻接表">1.1.2. 邻接表</h3><p>邻接表—— 一个节点连接中存在弧 节点的首指针</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 弧节点信息typedef struct arc&#123;int info;struct arc* next;&#125;arc, *acrlink;&#x2F;&#x2F; 节点信息，包含弧节点首指针typedef struct Node&#123;    int info;    arclink* firstArc;&#125;Node,Nodelink;&#x2F;&#x2F; 使用数组存放typedef vector&lt;Node&gt; Graph;&#x2F;&#x2F; 使用链表存放typedef link&lt;Node&gt; Graph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有向图">1.1.3. 有向图</h3><p>有向图的边$(a, b)$， 其中只存放 a-&gt;b的边</p><h3 id="无向图">1.1.4. 无向图</h3><p>无向图的边(a, b),  a 节点中存放一条a-&gt;b的边， b节点存放一条 b-&gt;a的边</p><h3 id="连通分量">1.1.5. 连通分量</h3><p>无向图中 能够从一个节点到所有的节点的 <strong>最大子图</strong></p><p><img src="/2025/08/30/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA1/20240511102449.png" alt="123 是连通分量， 12不是连通分量"></p><h3 id="强连通分量">1.1.6. 强连通分量</h3><p>有向图中， 增加了方向，依旧是连通分量成为强连通分量</p><h3 id="弱连通分量">1.1.7. 弱连通分量</h3><p>有向图中，增加了方向，不是连通分量 ； 减少方向，是连通分量，是弱~；</p><p><img src="/2025/08/30/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA1/20240511115235.png" alt="img"></p><h2 id="岛屿数量">1.2. 岛屿数量</h2><ol><li>每次遍历可以得到一个连通分量， 遍历总次数 = 所有连通分量= 岛屿数量</li><li>使用visited 数组标识 已访问节点</li></ol><h3 id="深度搜索dfs">1.2.1. 深度搜索dfs</h3><ol><li><p>中止条件：</p><ol><li>节点访问过 ，<code>visited[i][j]  = true</code></li><li>节点没有相连，<code>g[i][j] = 0</code></li></ol></li><li><p>处理逻辑：</p><ol><li><p>开始对其节点遍历，将其标识为<code>true</code></p></li><li><p>对所有相邻节点遍历</p><blockquote><p>图中相邻节点是其上、下、左、右坐标</p></blockquote></li><li><p>对节点遍历之前需要对节点坐标进行检查</p></li></ol></li><li><p>返回值，没有返回值</p></li></ol><h3 id="广度搜索BFS">1.2.2. 广度搜索BFS</h3><ol><li><p>取出队列首元素，将其所有相邻节点加入队列中，依次遍历，直到队列中元素为空</p></li><li><p>使用<code>visited</code> 数组标识遍历过的节点</p><ol><li><p>在加入队列时，标记已访问</p><blockquote><p>加入队列时没有标记， 出队列时标记，下一个访问当前节点会再次放入队列中，多次遍历</p><p><img src="/2025/08/30/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA1/20250124094043.png" alt="img"></p></blockquote></li></ol></li></ol><h2 id="岛屿的最大面积">1.3. 岛屿的最大面积</h2><p>一次遍历 = 一个连通分量=  一个岛屿， 统计每次遍历过程中的最大遍历节点数量</p><blockquote><p>写<code>if-else</code>时， 尽可能把结果都包含在内，没有操作时再不写</p><ol><li>有节点遍历时，节点数量 +1</li><li>没有节点遍历时，节点数量初始为0</li></ol></blockquote><ol><li><code>dfs</code><ol><li>优先处理节点，进入函数后，首先操作本节点， <code>count</code>初始为0</li><li>优先处理相邻节点，须在进入下一节点时，就将下一个节点处理，count 初始为1</li></ol></li><li><code>bfs</code>，只有在加入队列时处理，处理的是当前节点，初始化为0</li></ol><h2 id="孤岛的最大面积">1.4. 孤岛的最大面积</h2><p>孤岛 = 四周没有与图的边沿相连</p><ol><li>将所有与陆地相连的岛都置为海洋</li><li>计算剩下岛的面积</li></ol><p>两个边沿， 从四个边沿开始遍历，遍历的节点置为0，使用grid作为标识，此时可不用visited</p><ol><li><code>[0][i]</code>, <code>[n-1][i]</code></li><li><code>[i][0]</code>, <code>[i][m-1]</code></li></ol><h2 id="水流问题">1.5. 水流问题</h2><p><a href="https://programmercarl.com/kamacoder/0103.水流问题.html#思路">求出能流向低处的节点</a></p><ol><li>暴力求解，求当前节点能否到达 边界</li><li>逆推， 从边界向上推，看左边界能到的哪些节点<code>firstBoard</code>，以及有边界<code>secondBoard</code></li><li>左右边界都能到达，为逆推结果</li></ol><h2 id="建造最大岛屿">1.6. 建造最大岛屿</h2><p><a href="https://programmercarl.com/kamacoder/0104.建造最大岛屿.html#思路">海洋中造出一块岛， 连接其他岛屿，组成最大面积</a></p><ol><li><p>首先统计每个岛屿的面积，并为每个岛屿附上标识，并建立标识对应的面积</p><blockquote><p>建立标识后，可以标识当前节点已被访问，可以用这个标识代替<code>visited</code></p></blockquote></li><li><p>统计 0 值附近所有岛屿面积的和，不同的岛屿需要去重</p></li><li><p>比较出最大值</p></li></ol><h2 id="岛屿的周长">1.7. 岛屿的周长</h2><p><a href="https://programmercarl.com/kamacoder/0106.岛屿的周长.html#思路">岛屿与海相邻的周长</a></p><p>岛的陆地是一个正方形，每一条边，与海洋相连都是陆地周长，因此可以<strong>使用图论的方法</strong>，而不是总时搜索</p><ol><li><p>陆地地界的边沿是有一块海洋，边长加1</p><blockquote><p>矩阵边沿也是海洋，也要统计</p></blockquote></li><li><p>每两块相邻的陆地都需要减去2个边沿，=  每相邻一块陆地，需要减去一个边沿</p><p>统计所有陆地<code>sum</code>,总边数<code>4*sum</code> ，统计相邻陆地数<code>cover</code>,减去边沿<code>cover</code></p><p>陆地边沿 = <code>sum*4 - cover</code></p></li></ol><h2 id="字符串接龙">1.8. 字符串接龙</h2><p><a href="https://kamacoder.com/problempage.php?pid=1183">字符串作为路径，广度搜索</a></p><p><img src="/2025/08/30/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA1/20250317105155.png" alt="字符串接龙是无向图"></p><ol><li>无向图中可以使用<code>广度搜索</code>，找打目标节点，即为<code>最短路径</code></li><li>遍历时需要使用<code>visited</code>标识节点，避免循环，此时<code>visited</code>可以使用<code>set</code>标识，也可以使用<code>map</code>，同时标识走到这里的最短路径</li><li>对字符串的替换是对图可行路径的查找，找到了在集合中，标识找到了一条可行路径</li></ol><h2 id="邻接表遍历">1.9. 邻接表遍历</h2><p>邻接表中是以，节点作为数组元素，同时还有节点后指向 一个链表，指向与节点相连的节点</p><p><code>vector&lt;list&lt;int&gt;&gt; g(n+1)</code>，以数组序号作为节点元素，数组的<code>list</code>作为相邻链表</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 深搜和广搜中都需要对相邻节点的列表进行遍历&#x2F;&#x2F; list的遍历方法&#x2F;&#x2F;1. 指针for(auto it &#x3D; list.begin() ; it !&#x3D;  list.end() ; i++)&#123;&#125;&#x2F;&#x2F; 使用遍历for(auto i : list)&#123;&#125;&#x2F;&#x2F; 不能使用类似vector 的for(int i &#x3D; 0 ; i &lt; vector.size() ;i++)&#123;&#125;，list不能使用下标去访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="算法">2. 算法</h1><h2 id="并查集">2.1. 并查集</h2><p>含义： 一个集合中的元素指向同一个根节点， 根节点指向自身</p><ol><li>初始化，所有节点指向自身</li><li>插入时，将节点 -&gt; 该集合的<code>根节点</code><ol><li>如果是集合 插入 集合， 需要将集合 的<code>根节点</code> 指向 另一个集合的 <code>根节点</code></li></ol></li><li>比较时，比较两个元素的根节点是否相同</li><li>查找， 迭代查找根节点(指向自身的 节点)<ol><li>并查集的缩小： 在查找到根节点时， 将当前元素的<code>父节点</code>指向<code>根节点</code>，减少深度，加快查询</li></ol></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">n &#x3D; 1000;vector&lt;int&gt; father &#x3D; vector&lt;int&gt;(1000, 0);void init(vector&lt;int&gt;&amp; father)&#123;    for(int i &#x3D; 0 ; i&lt; father.size() ; i++)&#123;        father[i] &#x3D; i ;    &#125;&#125;void find(vector&lt;int&gt; father, int u  )&#123;    if( u &#x3D;&#x3D; father[u]) return u;    else&#123;       int u_father &#x3D; find(father[u]);        father[u] &#x3D; u_father;        &#x2F;&#x2F; 简化为 father[u] &#x3D; find[u]        return u_father;    &#125;&#125;bool isSame(vector&lt;int&gt; father, int u,  int v)&#123;  int u_father &#x3D; find(u);    int v_father &#x3D; find(v);    return u_father &#x3D;&#x3D; v_father;&#125;void join(vector&lt;int&gt; father, int u , int v)&#123;    int u_father &#x3D; find(u);    int v_father &#x3D; find(v);    if(u_father &#x3D;&#x3D; v_father) return ;    &#x2F;&#x2F; 注意这里插入时，插入的是根节点，不是将u,v 插入    else father[v_father] &#x3D; u_father;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="无向图中是否有路径">2.2. 无向图中是否有路径</h2><ol><li>将所有的节点加入并查集中</li><li>查看节点<code>i, j</code> 是否重复出现在并查集中，如果是，那就有路径</li></ol><h2 id="无向图中冗余连接">2.3. 无向图中冗余连接</h2><ol><li>如果边<code>i, j</code> 冗余，=》 顶点<code>i,j</code>之前就插入在并查集中，具有相同的根</li><li>删除最后一个并查集相同根 的 两个节点组成的边</li></ol><h2 id="有向图中的冗余连接">2.4. 有向图中的冗余连接</h2><p>与<a href="#无向图中冗余连接">无向图</a> 不同，有向图冗余边有以下情况：</p><ol><li>入度为2 的节点， 一定会有两个边，删除其中1条<ol><li>如果删除只有还是一个树 ， 这条边可以删除， = 所有节点可以组成并查集</li><li>如果不能构成树，那一定是一个环， 这个边就不是应该删除的边，应是零一条边</li></ol></li><li>如果没有入度为1的节点，一定是有环图<ol><li>将节点依次加入并查集中，删除最后一个形成环的节点</li></ol></li></ol><blockquote><p>删除冗余的最后一条边</p><ol><li>成环的最后一条边 -&gt; 最后使得并查集冗余的边</li><li>节点度为2的边，二选一，选择最后一个插入列表的进行判断</li></ol></blockquote><h2 id="最小生成树">2.5. 最小生成树</h2><h3 id="prim">2.5.1. prim</h3><p>算法步骤：</p><p>初始化： <code>minDist</code>中<code>默认权重</code>不要超过 <code>最大值</code>，否则无法选择节点</p><ol><li>选择距离最小生成树最小的节点</li><li>将节点加入树中</li><li>更新其他节点到最小生成的距离</li></ol><p>使用数据结构<code>minDist</code> 保存节点到当前生成树的最短路径，</p><blockquote><ul><li>最终， <code>minDist</code>中保存着最小生成树的权值</li><li>isTree 记录当前节点是否在树中</li><li>parent 记录与其相连的节点， 记录生成树边</li></ul></blockquote><h3 id="kruscal">2.5.2. kruscal</h3><p>对所有边操作，之前邻接表，邻接矩阵都是对顶点的描述，这里需要定义关于边的数据结构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct edge&#123;    int e1;    int e2;    int w;&#125;Edge ; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>将所有边保存</li><li>按照权重对边，从小到大<strong>排序</strong></li><li>对所有边遍历<ol><li>在同一个并查集中，跳过</li><li>在不同集合中，加入结果，并加入在同一个并查集中</li></ol></li></ol><h2 id="拓扑排序">2.6. 拓扑排序</h2><p><a href="https://programmercarl.com/kamacoder/0047.参会dijkstra朴素.html#思路">topology_sort</a></p><p>对于一个给定的有向图，转换为线性的排序； 图中有环时，不能做线性排序 </p><p>=&gt; 节点入度为<code>0</code> 的时候，没有依赖，选择作为结果</p><blockquote><ul><li><code>拓扑排序</code>可以用于<code>有向图</code> 无环判断</li><li><code>无向图</code>的环判断可以使用<code>并查集</code>判断</li></ul></blockquote><ol><li><p>统计所有边入度， a-&gt;b， 统计<code>b</code>节点的度</p></li><li><p>选择度为0 的节点，加入待处理集中，可以使用<code>queue</code>作为待处理</p></li><li><p>删除节点<code>i</code>，并将其加入结果集中</p><blockquote><p>删除节点<code>i</code>，是删除与其相邻的节点，此时入度为0 ，只有<code>i-&gt;j</code>的边，将节点<code>j</code>入度 -1 即可</p></blockquote></li></ol><h1 id="最短路径">3. 最短路径</h1><h2 id="单源最短路径Dijkstra">3.1. 单源最短路径Dijkstra</h2><p>选择 节点<code>i</code> 到<strong>原点</strong>的最近距离</p><blockquote><p>prim 寻找节点<code>i</code>到<strong>生成树</strong>的最近距离，原理相同，不过<code>minDist</code>存放值不同1</p></blockquote><ol><li><p>选择距离源点最近的节点</p><blockquote><p>dijkstra 的源点到 源点的距离为<code>0</code>，初始化源点为0</p><p>prim 初始树没有生成，初始节点均为<code>INT_MAIX-1</code>(方便选择第一个节点)</p></blockquote></li><li><p>将节点插入结果集中，标志为已访问</p></li><li>更新节点相邻节点 的 <code>minDist</code></li></ol><p>借助三个数组：</p><ol><li><code>minDist[j]</code>: <code>j</code>到源点的最小值</li><li><code>visited[j]</code>： <code>j</code>是否已找到最小值</li><li><code>parent[j]</code>: 与<code>j</code>相连的父节点，每次更新最小值时，更新</li></ol><h3 id="使用边进行Dijkstra">3.1.1. 使用边进行Dijkstra</h3><p>其中有两处修改</p><ol><li><p>使用邻接表代替邻接矩阵</p></li><li><p>使用堆排序选择 距离源点最近的节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cur &#x3D; q.top() ;&#x2F;&#x2F; 最小的距离节点q.pop();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>替换掉使用<code>for</code>对<code>minDist</code>的遍历，查找最小距离节点</p></li><li><p>遍历中，使用对边遍历，代替对节点遍历，</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while(!q.empty()) &#x2F;&#x2F; 所有的边都保存在q中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>修改之后使用的数据结构：</p><ol><li><p><code>priority_queue&lt;Arc, vector&lt;Arc&gt; , greater&lt;Arc&gt;&gt;</code> 对边权重的小顶堆</p><blockquote><p>小顶堆中a &lt; b，需要使用 &gt;</p><ol><li><p>重定义Arc中的<code>&gt;</code> ，使其能够 <code>&gt;</code>比较运算</p></li><li><p>使用greater<arc> ，使用<code>&gt;</code></arc></p><p>也可以重定义一个比较类，替换2</p></li></ol><p>比较类写法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Arc&#123;public:    int node;    int w;    &#x2F;&#x2F; &gt; 紧跟在operator之后    &#x2F;&#x2F; 参数使用 const + &amp;    &#x2F;&#x2F; 函数需要使用const     bool operator&gt;(const Arc&amp; other) const&#123;        return this-&gt;w &gt; other.w;    &#125;&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></li></ol><h2 id="Bellman-ford算法">3.2. Bellman-ford算法</h2><p>可以用于解决具有负权边的结果 ， 对边进行缩放，此时可以只存储边</p><blockquote><p>dijskra不能处理具有负权边的结果， 使用的是贪心算法，选择当前最近的边，对 负权边忽视最优结果</p></blockquote><p>Bellman-ford算法类似于动态规划的算法， <code>minDist[i] = min(minDist[i] ,  minDist[j-1] + value)</code>, </p><p>通过<code>n-1</code> 次迭代， 一定能找到最小边</p><ol><li><p>遍历<code>n-1</code>次</p></li><li><p>对所有边进行一次修改，每次修改更新最小边</p><p>如果<code>from</code> 节点 = <code>INT_MAX</code> ，没有到达<code>from</code> 节点，此时不修改<code>MinDist</code>结果</p></li></ol><h3 id="动态规划思想">3.2.1. 动态规划思想</h3><p><code>dp[k][j]</code> 是最多 <code>k</code>条边经过的最短路径，有两种计算结果</p><ol><li>刚好<code>k</code>次到达最短路径，<code>dp[k-1][v] +  weight</code>， <code>v</code>是能到达 <code>j</code>的节点</li><li>前<code>k-1</code>次已经到达最短路径， <code>dp[k-1][j]</code></li></ol><blockquote><p> <code>dp[k][j] = min(dp[k-1][j] , min(dp[k-1][v]))</code></p></blockquote><h3 id="Bellman-ford-队列优化算法">3.2.2. Bellman-ford 队列优化算法</h3><p>边<code>i-j</code> 中，只有<code>minDist[i]</code> 的权重发生改变，相邻的<code>minDist[j]</code>才需要发生改变， 与<code>i</code>相邻的所有节点都需要更新，此时使用<code>邻接表</code>存储图效果最好</p><p>此时，使用队列<code>queue</code>存放节点<code>i</code>， 作为待处理节点</p><p>同一节点可能未处理之前，可能被修改对此，因此使用<code>visited</code>数组，标识节点是否在队列中，在队列中不需要重复加入</p><blockquote><p>注意： 优化算法只对较少边的情况进行优化， 如果边的数量较多时，优化算法因为<code>queue</code>操作不适合优化</p></blockquote><h3 id="Bellman-ford-判断负权回路">3.2.3. Bellman-ford 判断负权回路</h3><p><a href="https://programmercarl.com/kamacoder/0095.城市间货物运输II.html#思路">判断是否有回路，且值为负数权重</a></p><ol><li>由<a href="#Bellman-ford算法"><code>Bellman_ford</code>算法原理</a> 中， 松弛<code>n-1</code>次后， <code>minDist</code>结果不再发生改变</li><li>所有再多遍历一次，如果在第<code>n</code>后，还发生改变，那么一定出现了<code>负权回路</code></li></ol><h3 id="有限制的最短路径">3.2.4. 有限制的最短路径</h3><p><a href="https://programmercarl.com/kamacoder/0096.城市间货物运输III.html#思路">从<code>i- j</code> 限制经过<code>k</code>个节点</a>  = 可以经过<code>k+1</code>条边</p><p><code>minDist</code>经过<code>k</code>轮松弛，得到最大长度为<code>k</code>的最短路径， 因此原题 = 经过<code>k+1</code>次最短路径得到的结果</p><p>但是由于算法采用了滚动数组， 导致第<code>i</code>条边应在第<code>i</code>轮更改，却在之前轮数中，修改，因此需要保留上一轮的数据，下一轮必须使用上一轮进行修改，保证结果正确性。</p><ol><li>使用缓存数组 存放 上一组中的最短路径</li><li>下一组计算时，需使用上一组的数据进行修改</li></ol><h4 id="DP-求解">3.2.4.1. DP 求解</h4><ol><li><p><code>dp[i][j]</code> 标识经历<code>i</code>条边，到达第<code>j</code>点的最短路径</p></li><li><p><code>dp[i][j]</code>的计算方式</p><ol><li>不经历 第<code>i</code>条边，可以到达<code>j</code>点， <code>dp[i-1][j]</code></li><li>经历第<code>i</code>条边，遍历所有<code>from-&gt;j</code>的边, 因<code>from</code>是到达的第<code>i-1</code>条边， 结果为<code>dp[i-1][from] + w</code></li></ol><p>两者最选择，取最小值</p></li><li><p>初始化，起始节点第<code>0</code>轮一定为0，其余初始化为<code>INT_MAX</code>,便于遍历</p></li><li><p>遍历顺序： 第一轮迭代次数 = 经历<code>k</code>条边，第二轮遍历所有节点即可</p></li></ol><h4 id="使用queue优化">3.2.4.2. 使用queue优化</h4><p>最主要问题： 统计迭代次数，并且使用上一次的计算结果算本次的更新结果</p><ol><li>使用<code>old_minDist</code>, <code>q_size</code>在每次迭代之前，统计上一次的迭代结果</li><li>结束上一次迭代中待更新的所有节点后，停止本次迭代， 迭代数量-1， 统计下一个迭代</li></ol><h2 id="多源最短路径算法Floyd">3.3. 多源最短路径算法Floyd</h2><p>算法可以同时计算出<code>多个起源</code>到<code>各个终点</code>的距离，使用动态规划的思想</p><ol><li><p><code>dp[i][j][k]</code> 节点<code>i</code> -&gt; <code>j</code>经过经过<code>[0,k]</code>中节点的最短路径</p></li><li><p><code>dp[i][j][k]</code> 中<code>i-&gt;j</code>最短路径有两种计算方法：</p><ol><li><p>经过<code>k</code>节点， 即分为两段<code>i-&gt;k-&gt;j</code>， 计算公式为<code>dp[i][k][k-1] + dp[k][j][k-1]</code></p></li><li><p>不经过<code>k</code>节点，从<code>k-1</code>节点经过，计算公式为<code>dp[i][j][k-1]</code></p><p>从中选择最优方案，<code>min(1, 2)</code></p></li></ol></li><li><p>初始化： </p><ol><li>dp 有<code>k=0</code>时计算，初始<code>dp[i][j][0]</code>，经过0个节点，即为初始图路径值</li><li><code>dp[i][j][0]</code>其余边初始为最大值，便于比较出最小值</li></ol></li><li><p>遍历顺序：</p><ol><li><code>k</code>层计算依赖于<code>k-1</code>，所有优先计算出<code>k-1</code>层，<code>k</code>在第一层，从小向大遍历</li></ol></li></ol><h1 id="搜索算法">4. 搜索算法</h1><h2 id="A-算法">4.1. A*算法</h2><ol><li>设计启发函数，由启发函数计算值为节点的选取增加权重</li><li>每次选择节点时，依照权重选择节点</li></ol><p>使用A*算法优化广度搜索算法(还可以优化Dijkstra算法)，</p><blockquote><p>广度搜索算法，每次出队相当于取出节点，在这里为出队的节点增加权重，每次出队按照权重低的出队</p></blockquote><ol><li>建立优先队列，从小到大排序，每次取出权重最小的节点</li><li>每次加入队列时，计算启发函数作为权重值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++基础</title>
      <link href="/2025/08/28/c/base_study/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/08/28/c/base_study/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="c-基础">1. c++基础</h1><h2 id="Union联合体">1.1. Union联合体</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">union&#123;linkNode link;NetNode net;&#125;LinkOrNet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结构体中有两个变量，但是只能有一个变量占据内存</p><p>c++17 中替代方案variant</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;variant&gt;varient&lt;linkNode, NetNode&gt; a; LinkNode b;a&#x3D; b; &#x2F;&#x2F; 自动追踪<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="string">1.2. string</h2><h3 id="构造函数">1.2.1. 构造函数</h3><ol><li><p><code>char*</code>转换<code>string(const char* s, size_type n)</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char c &#x3D; &#39;a&#39;;string s(&amp;c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>char</code>转换<code>std::string(size_type n, char c)</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char c &#x3D; &#39;a&#39;;string s(4, c); &#x2F;&#x2F; 生成4个c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>子字符串构建<code>string(s, start_pos, len)</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s &#x3D; &quot;aaaaaaaaaaa&quot;;string s1(s, 3, 4); &#x2F;&#x2F; 从3 开始字符串长度4&#x2F;&#x2F;类似切割字串string s2 &#x3D; s.substr(3, 4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>迭代器构造<code>string(start_pos, end_pos)</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char c[] &#x3D; &quot;aaaaa&quot;;string s1(c, c+3); &#x2F;&#x2F; 起始位置为c， 终止c+3;vector&lt;char&gt; v &#x3D; &#123;&#39;a&#39;, &#39;b&#39;&#125;;string s2(v.begin(), v.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="查找函数find-s-start-pos">1.2.2. 查找函数find(s,  start_pos)</h3><h3 id="字符串比较-s-t">1.2.3. 字符串比较 s , t</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s &#x3D;&#x3D; t &#x2F;&#x2F; string中具有运算符重载<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划">1. 动态规划</h1><p><strong>感谢<a href="https://programmercarl.com/">代码随想录</a></strong></p><p>解题思路</p><ol><li>确定<code>dp</code>数组及其下标的含义</li><li>确定<code>dp</code>数组</li><li>确定如何初始化 ，和<code>dp</code>数组的遍历顺序</li><li>举例推导<code>dp</code>数组</li></ol><p>验证dp数组的Bug时</p><ol><li>打印程序日志</li><li>自行推导<code>dp</code>数组</li><li>检查<code>dp</code>数组与程序中哪里出现错误，对错误地方重点检查</li></ol><h2 id="斐波拉契数列">1.1. 斐波拉契数列</h2><ol><li><code>dp</code>是数列的值</li><li><code>dp[i] = dp[i-1]+ dp[i-2]</code>;</li><li>初始化<code>0，1</code>即可</li><li><strong>注意</strong>：题目中要求计算<code>n</code>的值，对应<code>f(n)</code>的值，不是<code>n-1</code></li></ol><h2 id="跳台阶最省力方法">1.2. 跳台阶最省力方法</h2><ol><li><code>dp[i]</code>是第i层台阶使用的力气，dp需要从<code>dp[i-1]</code> 与 <code>dp[i-2]</code>之间选择体力最小的值</li><li>题目中，从第0，1阶开始跳，初始值可以为0；</li><li>从前向后遍历</li></ol><h2 id="路径问题">1.3. 路径问题</h2><h3 id="深度搜索">1.3.1. 深度搜索</h3><h3 id="dp算法">1.3.2. dp算法</h3><ol><li><p><code>dp[i][j]</code>是到达i,j 的所有方法</p></li><li><p>因为只能i, j只能左边<code>dp[i-1][j]</code>和上面<code>dp[i][j-1]</code>共同决定，所以dp由两数之和决定</p></li><li><p>第一行和第一列只能由一种方法到达，初始化为1；</p></li><li><p>从前向后遍历</p></li><li><blockquote><p>因为dp是由上方和左边+1组成，可以使用一维累加数组完成dp数组的效果</p></blockquote></li></ol><h3 id="使用图论">1.3.3. 使用图论</h3><p>移动需要走M+n-2中方法，且其中需要走m-1中向下的步数，结果为$C_{m+n-2}^{m-1}$ </p><p><img src="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20201209113602700-20230310120944078.png" alt="62.不同路径"></p><p>由于阶乘数字较大，先求分子分母阶乘会超过long long 类型，所以边计算分子边计算分母</p><ol><li>如果能够整除分母，且分母没有除完，选择除以分母</li><li>并且分子分母相加相减方向相同，尽快除以分母</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int high &#x3D; m-1;int low &#x3D; m+n-2;int denominator &#x3D; high;long long numerator &#x3D; 1;&#x2F;&#x2F; 求分母for(int i &#x3D; 1 ; i&lt;&#x3D; high ;i++) &#123;    numerator*&#x3D; low;    while(denominator&gt;0 &amp;&amp; numerator%denominator&#x3D;&#x3D;0)&#123;        numerator&#x2F;&#x3D; denominator;        denominator--;    &#125;    low--;&#125;return numerator;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="有障碍的路径规划">1.4. 有障碍的路径规划</h2><ol><li><code>dp[i][j]</code>表示i, j 位置的路径选择方法， 所以当有障碍物时，无法到达这里，此时<code>dp[i][j]=0</code>,其余位置照常计算</li></ol><blockquote><p>牢牢记住dp的定义，如有异常情况，将dp值写出</p></blockquote><h2 id="整数拆分">1.5. 整数拆分</h2><p>整数从i 拆分后分为i, n-i;</p><p>最大值取值有两个选择：</p><ol><li>$i*( n-i )$，不进行下一轮的划分</li><li>$ i* 对(n-i)划分后的最大乘积$，因为i会从0-i 都会分割一次，所以只用对(n-i）进行划分，因为在遍历过程中都会遍历到</li><li>其中2中的第二部分为问题1的子集，使用dp求解</li></ol><p><code>dp[i] = max(dp[i],max(i*j,  j*dp(i-j)))</code></p><p>因为dp[i] 被计算多次，最后需选择最大值，所以对dp[i]求最大值</p><h2 id="二叉搜索树数量">1.6. 二叉搜索树数量</h2><ol><li><p>n个数组成二叉搜索树，以j为中间节点<code>1....j ....n</code></p><p>j左边有<code>j-1-1+1= j -1</code>个数字，构成二叉搜索树，数量为<code>dp[j-1]</code><br>j右边有<code>n - j-1+1 =n-j</code>个数字,构成二叉搜索树，数量为<code>dp[n-j]</code></p></li><li><p>左右子树为树的子问题, <code>dp[i] += dp[j-1]*dp[i-j]</code></p></li><li>初始化dp[0] =1;</li><li>遍历顺序为从前向后，遍历</li></ol><h1 id="背包问题">2. 背包问题</h1><h2 id="0-1背包">2.1. 0-1背包</h2><ol><li>每种物品只能选择一个</li></ol><p><code>dp[物品i][重量w]</code> 表示当前 <code>物品i</code> 与<code>前面的物品[0-(i-1)]</code> 在<code>重量为w</code>情况下的最大价值</p><p>dp，当<code>重量j</code>足够放下<code>物品i</code>计算途径有两种</p><ol><li>放入，总重量为<code>j - w[i]</code> 时的最大价值，加上 <code>物品i</code> 的<code>价值v</code></li><li>不放入，总重量为上一个<code>物品i-1</code>在<code>重量j</code>情况下选择结果的最大值 </li></ol><p><code>dp[i][j]</code>从以上选择最大结果，<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]])+value[i]</code></p><ol><li>初始化，对于第一个放入物品情况初始化</li><li>遍历，从前向后遍历，重量可以等于总重量</li></ol><h2 id="数组分为两个相同的数组">2.2. 数组分为两个相同的数组</h2><ol><li>数组分的数组和界限为<code>sum/2</code>，等价为背包所能装的<code>总的质量</code><ol><li><code>每一个数字</code> =<code>放入的物品</code>，放入进去相当于有了重量</li><li>放入进去后，物品的总价值累加，等于sum/2 时，背包正好被放满</li></ol></li></ol><h2 id="压石机">2.3. 压石机</h2><p><a href="https://programmercarl.com/1049.最后一块石头的重量II.html#思路">使最后一块石头重量最小</a></p><p>两两组合使得质量最小 =  将石头分为两堆， 第一堆减去第二堆尽可能小  = 两石堆的质量差距相同</p><p>回到<a href="#数组分为两个相同的数组">问题2</a>中</p><p>现在将二维dp数组使用一维滚动数组代替</p><ol><li>先遍历物品，再遍历质量，因为dp[0-i]之前的数据是上一轮迭代结果，dp[i]需使用之前的数据，所有从后先前迭代</li><li>先遍历质量，再遍历物品，遍历得到当前质量j 下放下物品的最大价值，需计算出之前的数据，才能计算下一个质量下的最优值，所以必须从后向前迭代</li></ol><p>第二种遍历方式错误，会造成物品选择两次</p><h2 id="目标和">2.4. 目标和</h2><p><a href="https://programmercarl.com/0494.目标和.html#算法公开课">目标和</a></p><ol><li>将目标和转换为 <strong>数据求和等于某个值</strong>n</li><li>相当于将数值放入其中，可以得到值n</li></ol><p>和为<code>x</code>, 差的和为<code>sum -x</code> ,所以 <code>x- sum+x = target</code>，求出<code>x = (target+sum)/ 2</code>， 所以目标和为<code>(target+sum)/ 2</code></p><ol><li><p><code>dp[i][j]</code>是目标和为j 时选择i ，有多少组合方法</p></li><li><p>dp的组合方式</p><ol><li>选择i ， 则方法总数为上一个数字总和为j - num[i], 即<code>·dp[i-1][j-nums[i]]</code></li><li>不选择i，则方法总数为上一数字总和为<code>j</code> ,即<code>dp[i-1][j]</code></li></ol><p>总方法=<code>1+2</code></p></li><li><p>初始化： </p><ol><li>对于第一个数字，只有一种j 有一种方法，其余方法数为0；</li><li>对于剩余数字，当j = 0时，总数为0数字的2*n;</li></ol></li></ol><h2 id="0-1字串">2.5. 0-1字串</h2><p><a href="https://programmercarl.com/0474.一和零.html#思路">0-1</a></p><p>一个字符串<code>strs= [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;]</code>,求出有m个0， n个1的最大子集元素个数</p><p>此时题目相当于m,n相当于背包的重量，总重量小于m、n两个维度，字符串相当于物品，字符串0、1个数相当于每个物品的质量。</p><p>此时可以使用0-1背包</p><p>推荐使用滚动数组解决0-1背包问题</p><ol><li>初始化时将初始值置为0</li><li>优先物品遍历，质量遍历时使用倒序遍历</li></ol><h1 id="完全背包问题">3. 完全背包问题</h1><ol><li><p>背包物品数量有无穷多个，可以重复选择</p></li><li><p><code>dp[i][j]</code>公式含义： 第<code>i</code>个物品，在重量<code>j</code>条件下物品的最大价值</p></li><li><p><code>dp[i][j]</code>计算方式</p><ol><li>选择<code>i</code>, 预留重量<code>j- weight[i]</code>， 且背包中仍有<code>i</code>（区别0-1背包）， <code>dp[i][j- weight[i]]</code></li><li>不选择<code>i</code>, 不预留质量，不选择<code>i</code>,背包中只有<code>i-1</code>物品的最大值， <code>dp[i-1][j]</code></li></ol><p><code>dp[i][j] = max(dp[i][j- weight[i]], dp[i-1][j])</code></p></li><li><p>初始化</p><ol><li>对<code>i = 0</code>初始化</li><li>对<code>j = 0</code> 初始化</li></ol></li></ol><h2 id="零钱兑换">3.1. 零钱兑换</h2><p>此时求得是总的组合数，不是最大价值，<code>dp[i][j]</code> 是由<code>i</code> 是否选择两种情况组合的和</p><ol><li><code>dp[i][j] = dp[i][j- weight[i]] + dp[i-1][j]</code></li><li>初始化<ol><li>第一行初始化，如果可以整除，则有组合方式，初始化为1</li><li>第一列初始化，重量&gt;1 ,则重量=0时，只有一种组合方式，初始为1</li></ol></li></ol><blockquote><p>&lt; int &lt; unsigned int  &lt; long long &lt; unsigned long long </p><div class="table-container"><table><thead><tr><th></th><th>int</th><th>unsigned int</th><th>long long</th><th>unsigned long long</th></tr></thead><tbody><tr><td><cstdint></cstdint></td><td>int32_t</td><td>uint32_t</td><td>int64_t</td><td>uint64_t</td></tr><tr><td>范围</td><td>2,147,483,647</td><td>4,294,967,295</td><td>9,223,372,036,854,775,807</td><td>18,446,744,073,709,551,615</td></tr><tr><td>十进制</td><td>2e9</td><td>4e10</td><td>9.2e18</td><td>1.8e19</td></tr></tbody></table></div></blockquote><h3 id="使用一维dp数组">3.1.1. 使用一维dp数组</h3><ol><li>使用滚动数组 <code>dp[j] = dp[j] + dp[j- weight[i]]</code><ol><li>不选择时<code>nochoose = dp[j]</code></li><li>选择时 <code>choose = dp[j-weight[i]]</code></li></ol></li><li>初始化<ol><li>dp[0] 只有一种组合方式，初始化为1</li></ol></li><li>遍历顺序<ol><li>先遍历物品，在遍历质量，是组合<ol><li>且遍历质量时，需<strong>顺序遍历</strong>，此时可以放置多个同一物品，需使用到之前的数据，</li></ol></li><li>先遍历质量，再遍历物品，是排列数量</li></ol></li></ol><div class="table-container"><table><thead><tr><th>先遍历物品，再遍历质量</th><th>先遍历质量，再遍历物品</th></tr></thead><tbody><tr><td>先放物品<code>i</code> ，再放入物品<code>i+1</code>，有放入顺序，排除顺序不同的情况，计算的是组合数</td><td>先计算出当前质量下所有物品的最大值，表示质量<code>j</code>所有组合情况，没有顺序问题，是排列数</td></tr></tbody></table></div><h2 id="求出排列数量">3.2. 求出排列数量</h2><p><a href="https://programmercarl.com/0377.组合总和Ⅳ.html#算法公开课">求出排列数量</a>有两种思路</p><ol><li><p>完全背包的排列问题：</p><ol><li><p>先遍历质量，再遍历物品， 可以得到排列数量</p></li><li><p>爬楼梯</p></li><li><p>爬到第<code>i</code> 层的值，等于之前能够爬到<code>i</code>的所有选择之和</p><p>$ dp[i] = {dp[i- 能到i的跳跃次数]} 总和$</p></li><li><p>题目中用于跳跃到n的次数= 数组中用于相加等于n 的所有元素</p></li></ol></li></ol><h2 id="爬楼梯-完全背包排列问题">3.3. 爬楼梯 = 完全背包排列问题</h2><p>爬n阶台阶，每次能爬m 阶，两种思路解决</p><ol><li><p>n阶台阶 =  背包总容量，m阶台阶是每次选择的物品质量，<code>价值 = 重量 = j</code>。dp[j]是装满<code>j</code>层的方法总数</p><p><code>dp[i] += dp[i-j]</code></p><p>完全背包问题，优先遍历质量，再遍历物品</p></li><li><p>爬到<code>i</code> 层是之前<code>i-m</code> 层所有爬楼方法的总和, </p><p><code>dp[i]  += dp[i-j]</code></p></li></ol><h2 id="零钱兑换的最小方法数">3.4. 零钱兑换的最小方法数</h2><p><a href="https://programmercarl.com/0518.零钱兑换II.html">零钱兑换</a></p><ol><li><code>dp[j]</code>  兑换<code>j</code>所需的金币数量</li><li><code>dp[j]</code> 由其 <code>dp[i- coins[i]]</code>兑换到当前值 的最小方法决定<ol><li><code>dp[j] = min(dp[j], dp[j- coins[i]])</code></li></ol></li><li>初始化，需比较最小值，需将<code>dp[j]</code> 初始化为<code>UINT64_MAX</code> <ol><li><code>dp[0]</code> 方法数为0，初始化为0</li></ol></li><li>此时不是求总的组合数 / 排列数，任意顺序遍历均可</li></ol><h2 id="完全平方数">3.5. 完全平方数</h2><p><a href="https://programmercarl.com/0279.完全平方数.html#算法公开课">完全平方数</a></p><ol><li>dp与上一相同</li></ol><h2 id="字串拆分">3.6. 字串拆分</h2><p><code>i</code> 是需要达到的楼梯，</p><p><code>0-(i-1)</code>是能够到达<code>i</code>之前所有的楼梯，对这些元素遍历，并检查 <code>j - i</code> 之间能否跳到<code>i</code></p><p><code>dp[i] = dp[j] &amp;&amp; (i-j)能否到达</code></p><blockquote><p>切分<code>(i-j)</code> ，切记<code>i.j</code>均是加1 后的结果， 那么<code>j = j&#39;+1</code>，起始位置为<code>j&#39;+1</code> ,即为<code>j</code>, 总长度为<code>i&#39; - j+1</code>= <code>i -1-j+1</code> = <code>i-j</code></p><p>切分范围为(j, i-j)</p></blockquote><h3 id="回溯遍历，使用数组保存状态">3.6.1. 回溯遍历，使用数组保存状态</h3><p>使用memory保存状态，之后可以直接使用</p><h1 id="多重背包问题">4. 多重背包问题</h1><p>多重背包问题 = 物品展开的0-1背包问题</p><div class="table-container"><table><thead><tr><th>重量</th><th>价值</th><th>数量</th><th></th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>2</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>3</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>2</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>重量</th><th>价值</th><th>数量</th><th></th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr></tbody></table></div><p>相当于先遍历物品，再遍历物品的个数，再遍历背包(遍历物品个数在内部也一样)</p><blockquote><p>物品<code>i</code> ， 质量为<code>j</code>, 最大数量为<code>k</code></p><p><code>dp[i][j]</code> 对于总重量<code>j</code>有两种计算方式</p><ol><li>不装： <code>dp[i-1][j]</code></li><li>装k个：<code>dp[i-1][j-k*weight[i]] +  k*value[i]</code></li><li>初始化：<ol><li><code>j = 0</code> 一列全部为0</li><li><code>i =</code></li></ol></li></ol><p>初始化，与取值都是错误的，二维数组很复杂</p></blockquote><p>建议使用滚动数组</p><p>物品<code>i</code> ， 质量为<code>j</code>, 最大数量为<code>k</code></p><p><code>dp[j]</code> 是物品<code>i</code>对于总重量<code>j</code>有两种计算方式</p><ol><li>不装： <code>dp[j]</code></li><li>装k个：<code>dp[j-k*weight[i]] +  k*value[i]</code></li></ol><p>如果先遍历物品再遍历质量时，此时每次放入一个，<strong>不再需要乘上系数<code>k</code></strong></p><h1 id="打家劫舍问题">5. 打家劫舍问题</h1><ol><li><p><code>dp[i]</code> 是第<code>i</code> 家可以打劫到的最大金额</p></li><li><p><code>dp[i]</code>可以选择偷 / 不偷</p><ol><li><p>偷的话，需要偷<code>i-2</code>之前房屋的金额，加上第<code>i</code>家的前</p><p><code>dp[i-2]+ nums[i]</code></p></li><li><p>不偷的话，第<code>i-1</code>家可以被偷，所以第<code>i</code>的情况 = 第<code>i-1</code>家是否被偷的情况</p><p><code>dp[i] = dp[i-1]</code></p></li></ol><p><code>dp[i] = max(d[i-2]+ nums[i],  dp[i-1])</code></p></li><li><p>初始化，需要初始化第0，1 家</p><ol><li>dp[0] = nums[0], dp[1] = max(dp[0] , dp[1]);</li></ol></li><li><p>遍历顺序，从前向后</p></li></ol><h2 id="成环的打家劫舍">5.1. 成环的打家劫舍</h2><p><a href="https://programmercarl.com/0213.打家劫舍II.html#思路">成环</a></p><p>成环后，将首尾分开讨论</p><ol><li><p>不偷头，那么最后一间可以被偷</p><p><img src="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20210129160842491-20230310134008133.jpg" alt="不偷第一家"></p></li><li><p>不偷尾，那么第一间房间可以被偷</p><p><img src="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20210129160821374-20230310134003961.jpg" alt="不偷最后一家"></p></li></ol><p>求两次的能偷的最大价值，比较，返回最大值</p><h2 id="二叉树的打家劫舍">5.2. 二叉树的打家劫舍</h2><p><img src="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20210223173849619.png" alt="二叉树"></p><p>树的后序遍历，统计孩子们偷钱，再由中间节点统计</p><ol><li>截至条件：<ol><li>到NULL节点，偷的最大值为0</li><li>到叶子节点，偷的最大值是当前值</li></ol></li><li>处理逻辑<ol><li>根节点偷<ol><li>跳过左右孩子，计算从左右孙子偷到的金额</li></ol></li><li>根节点不偷<ol><li>计算左右孩子偷盗的金额</li></ol></li><li>选择哪一个值更大，选择偷拿个</li><li>使用记忆化存储，使用<code>map&lt;root, val&gt;</code>,保存已访问节点的最大值，后续访问节点时，直接返回保存值</li></ol></li></ol><h3 id="树形的dp">5.2.1. 树形的dp</h3><p><code>dp[i]  取决于 i 的左右节点的dp[i-&gt;left], dp[i-&gt;right]</code></p><ol><li>截至条件，所以函数需要返回孩子节点的选择状态&lt;不偷，偷&gt;<ol><li>到NULL节点，返回<0,0></0,0></li></ol></li><li>处理逻辑：<ol><li>当前节点偷，choose  = val + 左右孩子不偷</li><li>当前节点不偷，可以考虑左右节点是否偷，nochoose = max(左孩子选择)+max(右孩子选择)</li></ol></li></ol><h1 id="股票问题">6. 股票问题</h1><blockquote><p>同一个<code>i</code>有两种状态， 状态之间互相推导</p></blockquote><ol><li><p>第<code>i</code>天有两种状态， 持有股票 / 不持有股票， 分别设置为 <code>dp[i][0]/ dp[i][1]</code></p></li><li><p>第<code>i</code>天持有股票，可由两种方式推导</p><ol><li><p>第<code>i-1</code> 持有股票</p></li><li><p>第<code>i-1</code>不持有股票，第<code>i</code>天购购入(因为之前没有购入股票，一切为0)</p></li><li><blockquote><p><code>dp[i][0] = max(dp[i-1][0],  - price[i])</code></p><p>如果之前卖出了股票，就成了由不持有股票状态<code>dp[i-1][1]-price[i]</code></p></blockquote></li></ol><p>第<code>i</code>天不持有股票，由两种方式推导</p><ol><li><p>第<code>i-1</code>不持有股票</p></li><li><p>第<code>i-1</code>天持有股票， 第<code>i</code>购入股票</p></li><li><blockquote><p><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - price[i])</code></p></blockquote></li></ol></li><li><p>dp公式初始化，所有由第一天的状态组成，初始化</p><ol><li>第一天持有股票<code>dp[0][0] = -price[0]</code></li><li>第一天不持有股票 <code>dp[0][1] = 0</code></li></ol></li><li><p>遍历顺序，从前向后遍历</p></li></ol><h2 id="有限次购买股票">6.1. 有限次购买股票</h2><p><strong>问题：</strong><code>dp</code>数组由多种不同的状态，且不同状态之间互相推导</p><p><strong>解决方法：</strong> 找出所有可能的状态，并推导不同状态之间的公式</p><p>最多有<code>n</code>次购买股票，可以设置五种状态</p><div class="table-container"><table><thead><tr><th>0</th><th>没有操作</th><th><code>dp[i][0]</code></th></tr></thead><tbody><tr><td>1</td><td>第一次持有股票</td><td><code>dp[i][1]</code></td></tr><tr><td>2</td><td>第一次不持有股票</td><td><code>dp[i][2]</code></td></tr><tr><td>3</td><td>第二次持有股票</td><td><code>dp[i][3]</code></td></tr><tr><td>4</td><td>第二次不持有股票</td><td><code>dp[i][4]</code></td></tr></tbody></table></div><ol><li><p>第一次持有股票 </p><ol><li><p>第<code>i-1</code>第一次持有股票</p></li><li><p>第<code>i</code>天没有操作状态购入股票</p></li></ol></li><li><p>第一次不持有股票</p><ol><li>第<code>i-1</code>天不持有股票</li><li>第<code>i-1</code>天 持有股票后，第<code>i</code>天卖出股票</li></ol></li><li><p>第二次持有股票</p><ol><li>第二次持有股票</li><li>第<code>i-1</code>天第一次不持有股票，第<code>i</code>天购入股票</li></ol></li><li><p>第二次不持有股票</p><ol><li>第二次不持有股票</li><li>第<code>i-1</code>天持有股票， 第<code>i</code>天卖出股票</li></ol></li></ol><p>初始化：在第0天</p><ol><li>第一次购入股票， 为<code>-price[0]</code></li><li>第一次不持有股票，相当于第一天买了又卖了， 0</li><li>第二次购入股票，相当于第一天买入又卖出，再买入， 为<code>-price[0]</code></li><li>略</li></ol><p>dp结果： 只买一次股票包含在买两次股票结果中，所以第二次卖出股票为最终结果</p><h2 id="限制k次购买股票">6.2. 限制k次购买股票</h2><p><a href="https://programmercarl.com/0188.买卖股票的最佳时机IV.html#算法公开课">k次购买</a></p><p><code>k</code>次购买有<code>2k</code>中持有与不持有状态，+1中首次误操作状态</p><ol><li><code>dp[i][j+1]</code>次状态有 <code>dp[i-1][j]</code> ， 上一种状态<code>dp[i-1][j]</code>转换组成<ol><li>由于奇数次状态为持有股票状态，需要购入股票，由上一状态 <code>- price[i]</code>得到</li><li>偶数次状态为不持有股票状态，卖出股票， 总的价格增加，由上一状态<code>+ price[i]</code>得到</li></ol></li><li><code>dp[i][j]</code>公式<ol><li>$dp[i]][j] = max(dp[i-1][j] , dp[i-1][j-1] + (-1)^j*prices[i])$</li><li>方便计算，可以将奇偶公式分开枚举</li></ol></li></ol><h2 id="含有冷冻期的股票购买">6.3. 含有冷冻期的股票购买</h2><p><a href="https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html#思路">卖出股票后一天时冷冻期，冷冻期后时不持有股票状态</a></p><p>尝试描述购买股票过程中有多少种状态，画出其状态转化图， 有四种状态，</p><ol><li>持有股票状态 ， <code>dp[i][1]</code></li><li>不持有股票状态,  <code>dp[i][2]</code></li><li>冷冻期,  <code>dp[i][3]</code></li><li>当天卖出股票状态(此时状态与2不同)  <code>dp[i][4]</code></li></ol><p><img src="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20250829214353940.png" alt="image-20250829214353940"></p><ol><li>当前持有股票，<ol><li>可由前一天持有股票<code>dp[i-1][1]</code>得到，</li><li><code>i-1</code> 天不持有股票，买入股票得到， <code>dp[i-1][2] -  price[i]</code></li><li><code>i-1</code>冷冻期中后一天，买入股票， <code>dp[i-1][3] - price[i]</code></li></ol></li><li>当前不持有股票<ol><li><code>i-1</code>是冷冻期， <code>dp[i][3]</code></li></ol></li><li>当前是冷冻期<ol><li><code>i-1</code>当天售出股票， <code>dp[i-1][4]</code></li></ol></li><li>当天售出股票<ol><li><code>i</code>持有股票，卖出， <code>dp[i-1][1] + price[i]</code></li></ol></li></ol><p>初始化：</p><ol><li>持有股票时， 因买入股票， 初始为<code>-price[0]</code></li><li>其余状态不持有股票，初始不买不入，初始为0</li></ol><p>遍历顺序：从前向后遍历</p><h2 id="含手续费的股票售出">6.4. 含手续费的股票售出</h2><p><a href="https://programmercarl.com/0714.买卖股票的最佳时机含手续费（动态规划）.html#算法公开课">卖出时缴纳手续费</a></p><ol><li>还是两种状态， 持有股票，不持有股票， 由持有股票售出股票-&gt; 不持有股票，需缴纳手续费</li><li>dp转换公式<ol><li><code>dp[i][0] = max(dp[i-1][0] , dp[i-1][1] - price[i])</code></li><li><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + price[i] -fee)</code> ，售出时缴纳手续费</li></ol></li><li>初始化： 略</li><li>选择结果： 可以卖出，也可以不卖出，选择最大值情况</li></ol><h1 id="子序列问题">7. 子序列问题</h1><blockquote><p>字串问题操作数 =  不同结果的操作选择</p><ol><li>找到所有可能的操作</li><li>当前情况可以由哪些操作得到，上一操作状态又是什么</li><li>使用<code>max, min</code> 选择最合适的操作</li></ol></blockquote><p>可以近似于 爬楼梯问题， 能爬到 <code>num[i]</code> 位置的最大长度</p><ol><li><p><code>dp[i]</code>表示为 <code>i之前包括i内以nums[i]</code>为结尾的序列， 单调增序列的最大长度,</p></li><li><p><code>for 0: j</code> 中，能够爬到 <code>if(nums[j] &lt; nums[i])</code>中， 长度最大值</p><p><code>if(nums[j]  &lt;  nums[i] )  dp[i] = max(dp[i], dp[j] +1)</code></p></li><li><p>初始化，所有序列初始为1</p></li></ol><h2 id="最长连续子序列">7.1. 最长连续子序列</h2><p><a href="https://programmercarl.com/0674.最长连续递增序列.html#思路">子序列连续-递增</a></p><p>要求连续，所以只能从<code>j-1</code>跳到<code>j</code>的位置，所以只需要比较<code>nums[j-1] &lt; nums[j]</code>， 不需要从<code>[0,j-1]</code>全部与<code>nums[j]</code>比较</p><h2 id="最长重复子序列">7.2. 最长重复子序列</h2><ol><li><p><code>dp[i][j]</code> 表示 以<code>i-1</code> 结尾的A数组  与 以<code>j-1</code>结尾的B 数组 最长公共子序列</p><blockquote><p>因为<code>dp[i][j]</code> 时比较了了<code>i-1</code> 与<code>j-1</code>的序列结果， 所以表示以<code>i-1</code>为结尾的子序列</p></blockquote></li><li><p><code>if(A[i-1] == B[j-1])  dp[i][j] = max(dp[i-1][j-1]+1)</code>  , 比较的当前位置，因为<code>i, j</code>比实际<code>i,j</code>大1， 所以<code>if</code>中减去了1</p></li><li><p>初始化 <code>i=0 , j=0</code> 各种情况都是错误，初始化为0</p></li></ol><p>遍历顺序： <code>dp[i][j]</code>需要从1 开始遍历</p><h3 id="一维dp数组">7.2.1. 一维dp数组</h3><ol><li><p><code>dp[j]</code>表示与<code>j-1</code>结尾的相同的最大长度</p><blockquote><p> 因为是从上一个<code>i-1</code>复制下来得到，遍历过程中不能修改<code>j-1</code>的<code>dp</code>，否则影响后续计算</p></blockquote></li><li><p>·<code>if(A[i-1] == B[j-1])  dp[j] = max(dp[j-1]+1)</code></p></li><li><p>遍历顺序： <code>i</code>从头开始， <code>j</code>必须从后开始</p></li></ol><h2 id="最长公共子序列">7.3. 最长公共子序列</h2><ol><li><code>dp[i][j]</code> 表示以<code>i-1</code> 结尾的序列与 以<code>j-1</code>为结尾的序列，最长的公共子序列</li><li><code>dp[i][j]</code> 有两种计算方式<ol><li><code>A[i-1] == B[j-1]</code> ，长度+1,  <code>dp[i-1][j-1]+1</code></li><li><code>A[i-1] ！= B[j-1]</code> ,需要看<code>i-1</code>和<code>j</code>  /   <code>i</code> 与<code>j-1</code> 是否有最长的公共子序列，从两者中选择最大值</li></ol></li><li>初始化：<ol><li><code>i=0, j=0</code>情况，因为序号为<code>0</code>为空串， 与另一条序列的公共序列一定为0</li></ol></li><li>遍历顺序： 从前向后</li></ol><h2 id="最大连续子序和">7.4. 最大连续子序和</h2><p><a href="https://programmercarl.com/0053.最大子序和（动态规划）.html#算法公开课">最大子序和</a></p><p>连续子序和，可以由上一个序列延续获得， 也可以上一序列中断， 由当前序列继续计算</p><ol><li><p><code>dp[i]</code> ，以<code>i</code>为结尾的最长子序和</p></li><li><p><code>dp[i] = max(dp[i-1]+ nums[i], nums[i])</code></p></li><li><p>初始化，<code>dp[0]</code> 可以选择自身开始，或者从0开始</p><blockquote><p>题目要求子序长度 &gt;0 ，所以必须从自身开始</p></blockquote></li><li><p>遍历顺序： 从前向后遍历</p></li></ol><h2 id="判断子序列">7.5. 判断子序列</h2><p>子序列a  对应 序列b 的子序列长度</p><p><code>dp[i][j]</code>是子序列a与序列b相同子序列长度</p><ol><li><p>相同时 ， <code>dp[i][j] = dp[i-1][j-1] + 1</code>;</p></li><li><p>不相同时，删除<code>j</code>节点，观察 <code>dp[i][j-1]</code>能到达的最大长度</p><blockquote><p>此时，只能删除<code>j</code>节点，删除<code>i</code>节点后，就不是原来的序列了</p></blockquote></li></ol><h2 id="不同的子序列">7.6. 不同的子序列</h2><p><a href="https://programmercarl.com/0115.不同的子序列.html#算法公开课">完整的序列<code>t</code></a>在<code>s</code>的子序列中出现的次数</p><ol><li><p><code>dp[i][j]</code>, 以<code>i-1</code>结尾的序列t ，在以<code>j-1</code>为结尾的序列<code>s</code>中子序列出现次数</p></li><li><p>有两种计算情况</p><ol><li><p><code>s[i-1] == t[j-1]</code> ，看<code>i-1, j-1</code> 时匹配的结果， 同时还可以删除<code>i-1</code>看匹配结果(<code>i-1</code>可能由重复情况)</p><blockquote><p>相同情况时，选择用<code>s[i]</code> 与 <code>t[j]</code>比较，因为<code>s[i]</code>前一位可能等于后一位，所有也需要向前移动一位比较</p></blockquote></li><li><p>不相同时，删除<code>i-1</code>看匹配结果，<code>dp[i-1][j]</code></p></li></ol></li><li><p>初始化，<code>i = 0 , j=0</code>都是异常情况</p><ol><li><code>i =0</code> , s为空串， <code>j</code>与<code>s</code>相同结果为0</li><li><code>j=0</code>时，<code>j</code>是空串，<code>s</code>中删除到最后，一定有一串与<code>j</code>相同，初始化为1</li></ol></li><li><p>遍历顺序： 从前向后遍历</p></li></ol><h2 id="删除操作">7.7. 删除操作</h2><p><a href="https://programmercarl.com/0583.两个字符串的删除操作.html#算法公开课">两个字串删除n次后，序列相同</a></p><h3 id="最长相同子序列长度">7.7.1. 最长相同子序列长度</h3><ol><li>求出两字串最长公共子序列，长度n；</li><li>字串a,b删除除了公共子序列外的其他元素，删除后结果相同，删除长度 = 删除操作此处</li></ol><h3 id="删除操作DP">7.7.2. 删除操作DP</h3><ol><li><p><code>dp[i][j]</code>是以<code>i-1</code>为结尾的串a，以<code>j-1</code>为结尾的字串b需要删除的最小次数</p></li><li><p><code>dp[i][j]</code>有两种情况，相同结尾，不同结尾</p><ol><li><p><code>a[i-1] == b[j-1]</code>， 不需要删除操作，操作次数 = <code>dp[i-1][j-1]</code></p></li><li><p><code>a[i-1] ！= b[j-1]</code>，需要删除 a,b的最后一个，或者两个都删除</p><ol><li>删除<code>i-1</code> , <code>dp[i-1][j]+1</code></li><li>删除<code>j-1</code>,  <code>dp[i][j-1]+1</code></li><li>两个都删除， <code>dp[i-1][j-1]</code>+2 </li></ol><p>使用<code>max</code>对三种方案进行选择， 3 包含在1， 2中，可以省略3</p></li></ol></li><li><p>初始化，<code>i=0, j=0</code>异常情况，需初始化</p><ol><li><code>i=0</code>， 字串<code>a = NULL</code>, 字串<code>b[j]</code> 需删除 <code>j</code>次</li><li>j = 0 ，同上</li></ol></li><li><p>遍历顺序： 从前向后</p></li></ol><h2 id="编辑距离">7.8. 编辑距离</h2><p>字串编辑有三种操作，字串<code>a[i]</code>, <code>b[j]</code>, 最后一位不同</p><ol><li>删除，删除a 的最后一位<code>a[i]</code>，<code>b</code>没有改变</li><li>增加，在<code>b[j-1]</code>后增加一位<code>a[i]</code>与a相同， 增加一位<code>a[i]</code>与删除一位<code>a[i]</code>的操作力度相同</li><li><p>替换， </p></li><li><p><code>dp[i][j]</code> 表示以<code>i-1</code>为结尾的串a，以<code>j-1</code>为结尾的字串b需要操作的最小次数</p></li><li><p><code>dp[i][j]</code>有两种情况，相同结尾，不同结尾</p><ol><li><p><code>a[i-1] == b[j-1]</code>， 不操作，记录之前的操作次数= <code>dp[i-1][j-1]</code></p></li><li><p><code>a[i-1] ！= b[j-1]</code>， 进行以上三种操作</p><ol><li>删除， <code>dp[i-1][j]+1, dp[i][j-1]+1</code></li><li>增加， <code>dp[i-1][j]+1, dp[i][j-1]+1</code></li><li>替换， <code>dp[i-1][j-1]+1</code></li></ol><p>使用<code>max</code>对操作进行选择</p></li></ol></li><li><p>初始化，<code>i= 0, j =0</code>的情况，处理同上</p></li><li><p>遍历顺序，从后向前遍历</p></li></ol><h1 id="回文">8. 回文</h1><h2 id="回文子串">8.1. 回文子串</h2><h3 id="DP算法">8.1.1. DP算法</h3><p><a href="https://programmercarl.com/0647.回文子串.html#算法公开课">求回文字串的数量</a></p><ol><li><p><code>dp[i][j]</code>表示 <code>[i,j]</code>之间的字符是否为回文字串， 然后统计数组dp中有多少个 <code>true</code>,, = 有多个回文字串</p></li><li><p>两种情况</p><ol><li><code>a[i] =  a[j]</code>, <ol><li><code>[i, j]</code>之间相同 /  相邻，一定是回文子串</li><li><code>[i,j]</code>之间不相邻，<code>dp[i+1][j-1]</code>是回文串，则<code>true</code></li></ol></li><li>不相同，不是回文串，跳过</li></ol></li><li><p>初始化</p><ol><li><code>dp[i][j]</code>全初始化为<code>false</code></li></ol></li><li><p>遍历顺序</p><p>从左下角开始遍历， 即 下-&gt; 上，左-&gt; 右遍历</p><p><img src="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20210121171032473-20230310132134822.jpg" alt="647.回文子串"></p></li></ol><h3 id="双指针-中心扩散">8.1.2. 双指针  中心扩散</h3><p>回文串 由 中间1个 /  2个向左右扩散，统计扩散数量，不能扩散时，返回得到扩散的最大数量</p><ol><li>中间 1 个向左右 扩散</li><li>中间 2 个向左右扩散</li><li>相加得到结果</li></ol><h2 id="最长回文子串">8.2. 最长回文子串</h2><p><a href="https://programmercarl.com/0005.最长回文子串.html#思路">最长回文字串</a></p><p>字串要求 是连续的</p><h2 id="最长回文子序列">8.3. 最长回文子序列</h2><p><a href="https://programmercarl.com/0516.最长回文子序列.html#思路">最长回文序列</a></p><p>回文序列可以不连续</p><ol><li><p><code>dp[i][j]</code>，表示<code>[i,j]</code> 之间最大的回文序列长度</p></li><li><p><code>dp[i][j]</code>两种情况</p><ol><li><code>a[i] == a[j]</code>，子序列长度加2 ， <code>dp[i+1][j-1]+2</code></li><li><code>a[i] != a[j]</code>，那就是前一个区间的最大长度，可以缩短<code>i/ j</code>，<code>max(dp[i-1][j], dp[i][j-1])</code></li></ol></li><li><p>初始化</p><ol><li><p>由性质 <code>i == j</code>时候， <code>dp[i+1][j-1]+2</code></p><p>因为<code>i+1 &gt; j-1</code>无意义，所以<code>i==j</code>需要单独初始化</p></li><li><p>其余初始化为0</p></li></ol></li><li><p>遍历顺序： 下- &gt; 上， 左-&gt; 右</p><blockquote><p>遍历时， <code>i == j</code>时，已经初始化，且公式计算不到，所以<code>j</code>只需要从<code>i+1</code>开始遍历</p><p><code>dp[i+1][j-1]+2</code>,所以 `i &lt;= s.size()-2, i &gt;=0</p></blockquote><p><img src="/2025/08/27/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20230102172155.png" alt="遍历顺序"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法">1. 贪心算法</h1><p><strong>感谢<a href="https://programmercarl.com/0101.对称二叉树.html#思路">代码随想录</a></strong></p><p>贪心算法——由局部最优推导出全局最优</p><h2 id="饼干分配">1.1. 饼干分配</h2><p>按照常识推导，但所用知识需要逻辑正确</p><p>大胃口  吃 大饼干，如果胃口大了，可以换小胃口             大饼干不能喂小胃口，如果饼干小了， 不能喂更小的饼干</p><p>小饼干去喂小胃口，如果饼干小了，换大饼干                    小胃口不能吃小饼干，胃口大了，不能换大胃口</p><h2 id="贪心">1.2. 贪心</h2><p><a href="https://programmercarl.com/0376.摆动序列.html#思路">贪每一个波峰或波谷</a></p><ol><li>有变化： pre&lt; 0 &amp; cur &gt; 0 或 pre&gt; 0 &amp; cur&lt; 0</li></ol><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20201124174327597.png" alt="376.摆动序列"></p><ol><li>平台,只记录最右边，pre&lt;=0 &amp; cur&gt;0</li></ol><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20230106170449.png" alt="img"></p><ol><li><p>平台上升， 平台期仍保持原有状态</p><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20230108171505.png" alt="img"></p></li></ol><h2 id="最大连续和">1.3. 最大连续和</h2><p>当连续和 &lt; 0 时，后续增加会减小数值，应从当前位置继续开始</p><blockquote><p>注意： count计算后便与result比较，而不是先归零</p></blockquote><h2 id="买卖股票的最佳时机">1.4. 买卖股票的最佳时机</h2><p>总利润 = 每一条的利润</p><p>贪心：每次贪正利润</p><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/2020112917480858-20230310134659477.png" alt="122.买卖股票的最佳时机II"></p><h2 id="跳跃游戏">1.5. 跳跃游戏</h2><p><a href="https://programmercarl.com/0055.跳跃游戏.html#思路">跳跃游戏</a></p><p>从i 能够到达x  = 从i的跳跃范围能够到达x，且i只能在跳跃范围内移动</p><h2 id="跳跃游戏2">1.6. 跳跃游戏2</h2><p><a href="https://programmercarl.com/0045.跳跃游戏II.html#思路">最短跳跃游戏</a></p><p>x 是第i-1次跳跃位置， cover(i-1) </p><p>如果i大于了cover(i-1)，则需要选择cover(i-1)中能跳跃的最大位置作为新一跳的界限，并增加一步</p><h2 id="k次取反最大数组和">1.7. k次取反最大数组和</h2><ol><li>选择将负数反转</li><li>选择最小的绝对值进行反转</li></ol><blockquote><p>或者每次选择最小值，反转，但是更复杂</p></blockquote><h2 id="加油站">1.8. 加油站</h2><p><a href="https://programmercarl.com/0134.加油站.html#算法公开课">加油，能够循环的起点</a></p><ol><li>首先排除不能循环的情况；</li><li>一定能够循环<ol><li>从0开始的区间为负值情况，则起点错误，从下一个起点开始，直到找到能够值不为负的区间</li></ol></li></ol><p>同时，从后向前相加，如果能加从0开始的最小和，相加为正数时，则为开始起点</p><h2 id="糖果分发">1.9. 糖果分发</h2><p><a href="https://programmercarl.com/0135.分发糖果.html#算法公开课">分发糖果</a>：要求分高的同学的糖果一定比两边分低的同学糖果数量多</p><blockquote><p>注意贪心比较的方向， 所有的结果都能比较得到</p></blockquote><ol><li><p>依次比较左右孩子，</p><blockquote><p>遍历顺序，在于是否使用之前的数据（类似于dp)，如果使用到，之前的数据需要先比较</p></blockquote><ol><li>依次比较左孩子，<ol><li>要求： 右边的孩子大于左边所有孩子，需要使用到左边比较数据</li><li><strong>从左向右遍历</strong>， 可以使用到上一次比较的结果</li></ol></li><li>依次比较右孩子，<ol><li>要求： 左边的孩子大于右边所有孩子，需要用到右边比较的数据</li><li><strong>从右向左遍历</strong>， 遍历时，选择max(本轮比右孩子多的糖果，从左边得到的糖果)</li></ol></li></ol></li></ol><h2 id="柠檬水找零">1.10. 柠檬水找零</h2><p><a href="https://programmercarl.com/0860.柠檬水找零.html#算法公开课">柠檬水</a></p><p>优先将面额较大的零钱找出，因为小零钱更加万能</p><h2 id="根据身高重建序列">1.11. 根据身高重建序列</h2><p>讨论两个维度 ，首先固定一个维度，再讨论下一个维度</p><ol><li>按照身高从大到小排序，以此作为插入顺序，同时需要规定k值小的排在前面</li><li>高身高的优先插入后，后面小身高的插入不会影响k值</li></ol><p><code>vector</code> 与 <code>list</code>插入的区别， <code>vector</code>插入时涉及底层扩容，比list插入效率低</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v;list&lt;int&gt; l;v.insert(v.begin()+pos, val);  &#x2F;&#x2F; 可以直接使用pos插入auto it &#x3D; l.begin();it &#x3D; next(it, pos);l.insert(it, val); &#x2F;&#x2F; 必须使用迭代器指定位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="射击气球">1.12. 射击气球</h2><p><a href="https://programmercarl.com/0452.用最少数量的箭引爆气球.html#思路">射击气球</a></p><p>贪心算法，一定要举出贪心的例子，来验证算法，</p><p>首先需要排序，根据排序顺序选择判断结果</p><ol><li>将右边界排序，记录最左边右端节点，但有其他值超过节点时，需射出一箭</li></ol><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20250827111033620.png" alt="image-20250827111033620"></p><ol><li><p>将左边界排序，记录最右端节点，如果其他值查过节点时，需要射出一箭</p><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20250827111332960.png" alt="image-20250827111332960"></p></li></ol><h2 id="无重叠区间">1.13. 无重叠区间</h2><p><a href="https://programmercarl.com/0435.无重叠区间.html">无重叠区间</a></p><ol><li><p>使用右边界，每一个不相交的区间是保留下的区间，其余都需删除</p><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20250827112819769.png" alt="image-20250827112819769"></p></li><li><p>左排序时，统计有重复区域的区间，然后删除</p><p><img src="/2025/08/26/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20250827113408417.png" alt="image-20250827113408417"></p></li></ol><h2 id="划分字母区间">1.14. 划分字母区间</h2><p><a href="https://programmercarl.com/0763.划分字母区间.html#思路">区间</a></p><p>当区间[a,b]之间字符的最大值以达到时，这个区间为字母区间，并将a置为新的区间开始b+1</p><h2 id="合并区间">1.15. 合并区间</h2><p><a href="https://programmercarl.com/0056.合并区间.html#其他语言版本">合并区间</a></p><p>合并区间，从左向右比较，只能使用左排序</p><h2 id="最小单调递增数字">1.16. 最小单调递增数字</h2><p>如果有<code>n1 n2 n3</code>情况，<br>如果<code>n2 &gt; n3</code>， 则其最大的递增序列为<code>(n2-1) 9</code><br>如果<code>n1 &gt; n2</code>， 最大为<code>(n1-1) 9 9</code></p><p>如果序列比较n-1与n，则for循环最小值为1</p><h2 id="监控二叉树">1.17. 监控二叉树</h2><ol><li><p><strong>优先从叶子节点开始监控</strong>，因为叶子节点监控数量为指数级</p><p>有三种节点状态</p><blockquote><ol><li>无监控</li><li>有监控</li><li>有摄像头</li></ol></blockquote><p>对叶子节点进行监控，则空节点需设置为有监控状态</p></li><li><p>状态返回</p><ol><li>left 与right 都是监控状态，则mid需返回无监控1</li><li>left，right有一个是无监控1， 则mid需设置有摄像头3，并增加一个摄像头</li><li>left, right有一个有摄像头，则mid返回有监控2</li></ol></li></ol><h2 id="友军数量">1.18. 友军数量</h2><p><a href="https://programmercarl.com/0649.Dota2参议院.html#思路">杀死后面的参议员</a></p><p>贪心思想： 前面杀死后面的所有参议员</p><blockquote><p>使用flag 标识，前方时候有敌军</p></blockquote><ol><li>前方有敌军，自身被杀死<ol><li>但是多了一个友军,flag+1</li></ol></li><li>前方没有敌军，自身还活着，友军数量+1 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2025/08/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2025/08/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法">1. 回溯算法</h1><p><strong>感谢<a href="https://programmercarl.com/0077.组合优化.html#算法公开课">代码随想录</a></strong></p><h2 id="组合问题">1.1. 组合问题</h2><ol><li>终止条件，满足题目条件</li><li><p>处理逻辑</p><ol><li>对当前所有可能结果遍历</li><li>调用函数</li><li>结果回溯，弹出函数修改的结果</li><li>在处理中，不合理的情况暂停，减枝</li></ol></li><li>函数参数选择</li></ol><h2 id="组合问题2">1.2. 组合问题2</h2><p><a href="https://programmercarl.com/0216.组合总和III.html#其他语言版本">组合问题</a></p><p>回溯算法： 宽度是for循环的数量，深度是满足条件回溯算法的深度</p><ol><li>终止条件：深度为K, 总和为n</li><li>处理逻辑：<ol><li>对于总和数&lt; 1，没有结果，剪枝</li></ol></li><li>参数，可以函数调用时导入K-1, n-i，进行递归和回溯</li></ol><h2 id="电话号码排列">1.3. 电话号码排列</h2><p><a href="https://programmercarl.com/0017.电话号码的字母组合.html">排列问题</a></p><p>使用index 标识树的深度，或者其他方式也行</p><ol><li>终止条件：达到指定深度</li><li>处理逻辑：<ol><li>对字串中的所有char 进行遍历</li></ol></li></ol><h2 id="组合问题-1">1.4. 组合问题</h2><p>组合中不同排序结果相同，使用startIndex标识开始位置，不同排序结果只记录一次</p><h2 id="组合总数">1.5. 组合总数</h2><p><a href="https://programmercarl.com/0040.组合总和II.html">组合去重</a></p><p>数据中有重复数据，题目要求每个数据在每次只能用一遍，重复数据可以在同一结果集中出现，但是由于元素重复，需要对重复数据去重</p><p>去重条件<code>candidates[i] == candidates[i-1] &amp;&amp; used[i-1]==false</code>，这一部分不是剪枝，必须去除这一部分</p><p><img src="/2025/08/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/20221021163812.png" alt="img" style="zoom:50%;"></p><h2 id="切分回文子串">1.6. 切分回文子串</h2><p><a href="https://programmercarl.com/0131.分割回文串.html#优化">切分回文子串</a></p><ol><li>终止条件： 切分线到达最后，切分结束</li><li>处理逻辑：<ol><li>切分出来的是回文子串则继续切分，否则返回，不再切割</li><li>判断方法：<ol><li>字串直接判断</li><li>DP首先计算出DP数组，<code>DP[i,j]</code> 数组标识<code>[i,j]</code>这范围内是否为回文子串， 回文子串<code>dp[i][j] = s[i] == s[j] &amp;&amp; dp[i+1][j-1]</code></li></ol></li></ol></li></ol><h2 id="复原IP地址">1.7. 复原IP地址</h2><p><a href="https://programmercarl.com/0093.复原IP地址.html#总结">复原Ip地址</a></p><ol><li>终止条件： 分割点数 == 3， 并且最后一个分割字串符合条件</li><li>处理逻辑：<ol><li>如果切分出来的是符合逻辑的IP, 继续切割</li><li>剪枝：<ol><li>当剩余字符数<code>s.size() - 1-(i+1)+1 = s.size()-i-1</code> 超过所需字符数 <code>3*(3- PointNum)</code> ，剪枝</li><li>少于所需字符数（3-point) ,剪枝</li></ol></li></ol></li><li>传递参数： 切割位置，切割的点数</li></ol><h2 id="分割子集">1.8. 分割子集</h2><p>搜集子集是将所有<strong>搜索路径上所有结果</strong><br>组合和分割将<strong>叶子节点中符合条件的结果</strong>加入其中</p><p>如果题目要求集合中元素顺序，则下一个节点从i+1开始，如果当前节点可以重复使用从i开始；</p><p>节点中有重复元素，需要对重复元素去重，同一层中不能以当前节点继续，但是同一树仍可以继续使用</p><h2 id="子集去重">1.9. 子集去重</h2><p>有重复元素，去重</p><ol><li>对数据集排序</li><li>使用<code>num[i]!=num[i-1]</code> 对同层数据去重</li><li>对于需要使用已加入栈中的数据时，需要使用used对数据去重</li></ol><p><a href="https://programmercarl.com/0090.子集II.html#思路">子集去重</a></p><p><a href="https://programmercarl.com/0040.组合总和II.html">组合去重</a></p><h2 id="递增子集去重">1.10. 递增子集去重</h2><p><a href="https://programmercarl.com/0491.递增子序列.html#思路">递增序列去重</a></p><p>递增序列中去重，当前序列中有重复元素，不能使用sort对数组排序。</p><p>使用set对当前层数组去重，每一个函数中创建一个set, 对函数中的当前层有效。同一树枝上因为从i+1开始，不用去重，且set已更新，不影响下一层数据</p><ol><li>处理逻辑：<ol><li>符合条件的加入到path中</li></ol></li></ol><h2 id="排列问题">1.11. 排列问题</h2><p><a href="https://programmercarl.com/0046.全排列.html#算法公开课">排列</a></p><ol><li>终止条件： 到达满足条件</li><li>处理逻辑：<ol><li>遍历对整个数组遍历，因为不同顺序集合不同，此时不需要<code>startIndex</code>;</li><li>使用<code>used</code>标识这条链路上哪个元素被使用， 将<code>used</code>作为参数；</li></ol></li><li>参数： 数组，标识数组<code>used</code></li></ol><h2 id="排列问题去重">1.12. 排列问题去重</h2><p>因为排列问题需要从0开始，下一层中可能会使用到上一层的数据，需要使用used对检查是否在树枝，或同一层上；</p><p>判断条件：</p><ol><li><p><code>nums[i] == nums[i-1]</code>并且 <code>used[i-1] = false</code>表示同一层中上一个被使用</p><p>​    下一层中上一个被使用，<code>used[i-1] =true</code>, 可以被接着使用。</p></li><li><p>同时，还需要使用used[i] 检查当前元素是否在树枝上使用过，使用过则跳过</p></li><li><p>或者使用set代替第一条对数据去重</p></li></ol><h2 id="重新安排路径">1.13. 重新安排路径</h2><p><a href="https://leetcode.cn/problems/reconstruct-itinerary/">搜索机票</a></p><p>将票数据转换为图<code>map&lt;string, map&lt;string, int&gt;&gt;</code></p><ol><li>终止条件： 节点数 = 机票数量+1</li><li>处理逻辑：<ol><li>对result最后一个节点的所有相连进行搜索</li><li>每搜索一次，删除一条机票，删除方式将第二个map数量-1，当= 0 时，不能从当前机票起飞</li></ol></li></ol><p>此题是欧拉路径，最好使用<code>Hierholzer</code> 算法，搜索算法可能进入贪心死循环</p><h2 id="N皇后">1.14. N皇后</h2><p><a href="https://programmercarl.com/0051.N皇后.html#思路">N皇后</a></p><ol><li>终止条件： 加在最后一行棋盘</li><li>处理逻辑：<ol><li>对棋盘上每一行进行遍历</li><li>符合条件的加入棋盘</li><li>进入下一轮</li><li>回溯，退出上一轮的修改</li></ol></li></ol><h2 id="数独">1.15. 数独</h2><p><a href="https://leetcode.cn/problems/sudoku-solver">37. 解数独 - 力扣（LeetCode）</a></p><ol><li>终止条件： 所有节点遍历结束，返回true;</li><li>处理逻辑：<ol><li>遍历宽度为1-9</li><li>遍历深度为所有节点遍历结束，因为是二维，不确定向那个方向移动，使用<code>!=&#39;.&#39;</code>条件对已完成的跳过，实现对下一个移动方向的选择</li></ol></li></ol><p>详细代码注释如<a href="D:\code\leetcode\37.解数独.cpp">代码及注释</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2025/08/23/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%91/"/>
      <url>/2025/08/23/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树">1. 树</h1><p><strong>感谢<a href="https://programmercarl.com/0101.对称二叉树.html#思路">代码随想录</a></strong></p><h2 id="深度遍历">1.1. 深度遍历</h2><h3 id="递归">1.1.1. 递归</h3><pre class="line-numbers language-none"><code class="language-none">1. 递归结束条件2. 当前递归操作3. 对那些节点进行递归4. 确定参数和返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈实现">1.1.2. 栈实现</h3><p>深度遍历中存在先进后出，所以此处使用栈</p><ol><li>先序遍历，栈中先进后出，出栈顺序为3，2<ol><li>中间节点</li><li>右节点</li><li>左节点</li></ol></li><li>中序遍历，当左节点与栈同时为空时，遍历结束<ol><li>将所有左节点压入栈中</li><li>左节点为空时，将栈中节点弹出，处理中间节点</li><li><code>cur= cur-&gt;right</code>， 处理右节点</li></ol></li><li>后序遍历，参照1， 然后reverse</li></ol><h3 id="NULL-bool表示">1.1.3. NULL/ bool表示</h3><p>先序遍历，中左右，</p><ol><li>加入栈中顺序为右左中，标识当前节点需处理时在栈后加入一个NULL</li><li>如果访问到NULL节点，需将下一节点弹出</li></ol><h2 id="反转二叉树">1.2. 反转二叉树</h2><p><a href="https://programmercarl.com/0226.翻转二叉树.html">反转二叉树</a></p><p>中序遍历不能反转二叉树，较为困难</p><h2 id="对称二叉树">1.3. 对称二叉树</h2><p><a href="https://programmercarl.com/0101.对称二叉树.html#思路">对称二叉树</a></p><ol><li>确定返回条件</li><li>当前节点比较左右字树是否相同</li><li>比较的是节点的内侧(left的右， right的左)，节点的外侧</li></ol><h2 id="树的最大深度">1.4. 树的最大深度</h2><p><a href="https://programmercarl.com/0104.二叉树的最大深度.html">树的最大深度</a></p><ol><li>后序遍历： 回溯，从后面的节点结算，得到当前节点的结果</li><li>前序遍历： 迭代，先计算当前节点，再依次计算后续节点，计算下一个节点时需要回溯</li></ol><h2 id="树的最小深度">1.5. 树的最小深度</h2><p><a href="https://programmercarl.com/0111.二叉树的最小深度.html">二叉树的最小深度</a></p><p>当节点的左右节点为都为NULL时，节点为叶子节点</p><ol><li><p>终止条件：节点为叶子节点时</p></li><li><p>后序遍历，</p><blockquote><p>注意：此时depth != 左右子树最小的节点，有可能左右子树有空子树</p><p>解决方法： 空子树设置深度初始值为最大值</p></blockquote></li></ol><h2 id="返回树的所有路径">1.6. 返回树的所有路径</h2><p><a href="https://programmercarl.com/0257.二叉树的所有路径.html#思路">树的所有路径</a></p><ol><li>路径的终止条件为达到叶子节点： 左右节点均为NULL;</li><li>此时对left与right递归时需要对left, right做检查，同时中间节点的初始需要放在if判断之前；</li></ol><p>两种方法回溯：</p><ol><li>使用vector存放路径，回溯时弹出最后一个元素；</li><li>使用参数对路径修改，回溯时参数不变，等于回溯；</li></ol><h2 id="左叶子之和">1.7. 左叶子之和</h2><p><a href="https://programmercarl.com/0404.左叶子之和.html#思路">左叶子之和</a></p><ol><li>终止条件：<ol><li>当前节点为空</li><li>是叶子节点</li></ol></li><li>当前逻辑：<ol><li>获取左子树的做叶子之和</li><li>当左子树为左叶子时，单独计算</li><li>获取右子树的左叶子之和</li></ol></li><li>求和相加，返回</li></ol><h2 id="路径之和">1.8. 路径之和</h2><p>递归函数是否有返回值，分为三种情况</p><ol><li>需要对树的所有路径遍历且不用处理递归返回值， 递归函数没有返回值void</li><li>需要对树的所有路径遍历且需要对递归返回值进行处理，递归函数有返回值int</li><li>之搜索一条符合条件的路径，则需要返回返回值，返回值通常为bool</li></ol><h3 id="找到路径即可">1.8.1. 找到路径即可</h3><p><a href="https://programmercarl.com/0112.路径总和.html#思路">找到路径即可</a></p><ol><li>终止条件为找到叶节点<ol><li>如果符合条件，返回true</li><li>不符合条件，返回false;</li></ol></li><li>如果左子树已经满足条件，返回true，不再搜索</li><li>对右子树进行搜索</li></ol><h3 id="找到所有可能的路径">1.8.2. 找到所有可能的路径</h3><p><a href="https://programmercarl.com/0112.路径总和.html#思路">找到所有可能的路径</a></p><ol><li>终止条件为找到叶节点<ol><li>符合条件，加入结果集中</li></ol></li><li>找完左子树，再找右子树</li></ol><h2 id="前序-中序创建二叉树">1.9. 前序/中序创建二叉树</h2><ol><li><p>终止条件：</p><ol><li>数组为空时，返回NULL</li><li>数组为1个时，返回节点r</li></ol></li><li><p>处理逻辑：</p><ol><li>pre的第一个节点作为root节点</li><li>从中序in中找到与root相同的节点，以此为分割点，找到left ,right数组的长度</li><li>前序left, right与中序长度相同，所有区间为左开右闭</li></ol><p>|      | left                                       | right                                     |<br>| —— | ————————————————————— | ————————————————————- |<br>| pre  | [leftPreorder+1, leftPreorder+1+left_size] | [ leftPreorder+1+left_size,rightPreorder] |<br>| In   | [ leftInorder, break_point]                | [break_point+1, rightInorder]             |</p></li><li><p>参数中包含数组分割节点</p></li></ol><h2 id="创建最大树">1.10. 创建最大树</h2><ol><li>终止条件：可为叶子节点，也可以是NULL</li><li>处理逻辑：<ol><li>找到最大值索引，</li><li>使用索引分割两区间</li></ol></li></ol><h2 id="二叉搜索树">1.11. 二叉搜索树</h2><p><a href="https://programmercarl.com/0700.二叉搜索树中的搜索.html">二叉搜索树</a></p><p>左子树 &lt; 中间 &lt; 右子树 </p><p>由中间值比较，确定对左子树/ 右子树一棵树进行搜索</p><h2 id="验证二叉搜索树">1.12. 验证二叉搜索树</h2><p>左子树的所有值 &lt; 中间 &lt; 右子树的所有值， 所以不能单独比较 左节点 &lt; 中间 &lt; 右节点</p><p>使用中序遍历，左中右，比较结果</p><ol><li>中序遍历，得到数组，检查数组是否是从小到大</li><li>中序遍历，保存遍历过程的做大值，保证遍历中的最大值&lt; 当前值</li></ol><h2 id="二叉树的最小差">1.13. 二叉树的最小差</h2><p>二叉树所有数的最小值是相邻两个遍历节点的差值最小</p><ol><li><p>中序遍历，得到数组后，求数组相邻数据的差值</p></li><li><p>中序遍历，保存上一个节点pre， 每次使用cur与pre做差值</p><blockquote><p>在中序结束后，将pre = cur， 将cur保存为下一变量的前一个节点</p></blockquote></li></ol><h2 id="找到最近公共祖先">1.14. 找到最近公共祖先</h2><p><a href="https://programmercarl.com/0236.二叉树的最近公共祖先.html#思路">最近公共祖先</a>从下向上查询路径，后序遍历</p><ol><li>终止条件：<ol><li>节点为NULL， 返回NULL</li><li>找到确定节点，返回true ,将result修改为当前路径；</li></ol></li><li>处理逻辑：<ol><li>如果p，q是不同树，那么更新result结果；</li><li>如果只有q，在路径上，不更新result;(因为可能出现q是p的父节点，由终止条件2修正)</li></ol></li></ol><h2 id="二叉搜索树的最近公共祖先">1.15. 二叉搜索树的最近公共祖先</h2><p><a href="https://programmercarl.com/0235.二叉搜索树的最近公共祖先.html#思路">二叉搜索树</a></p><p>二叉树有序，所以p,q的祖先节点位于[p,q]之间，且最近公共祖先是其遍历中的第一个，也只有这一个满足[p,q]条件</p><h2 id="二叉搜索树的插入">1.16. 二叉搜索树的插入</h2><p><a href="https://programmercarl.com/0701.二叉搜索树中的插入操作.html#思路">插入</a></p><ol><li>终止条件： 遇到空节点，新建一个节点，并加入在parent节点左/右</li><li>操作逻辑： <ol><li>val大于节点，进入右子树</li><li>val小于节点，进入左子树</li></ol></li></ol><blockquote><p>也可以不使用parent节点，终止条件中返回创建的节点，在操作时将返回的节点插入</p></blockquote><h2 id="二叉搜索树的删除">1.17. 二叉搜索树的删除</h2><p><a href="https://programmercarl.com/0450.删除二叉搜索树中的节点.html#算法公开课">删除</a></p><p>终止条件：删除时如果左右子树都在，需要将左子树放在右子树的最左节点的最左侧</p><h2 id="二叉树的修剪">1.18. 二叉树的修剪</h2><p><a href="https://programmercarl.com/0669.修剪二叉搜索树.html#思路">二叉树的修剪</a></p><ol><li>终止条件： 如果root==NULL时，返回NULL;</li><li>处理逻辑： <ol><li>中： 如果root &lt; left ,修建左子树，将左子树合适节点代替root返回，反之亦然</li><li>左： 对左子树修剪，返回结果赋值给root的左子树</li><li>右：同上</li></ol></li></ol><h2 id="有序数组-gt-二叉搜索树">1.19. 有序数组-&gt;二叉搜索树</h2><p><a href="https://programmercarl.com/0108.将有序数组转换为二叉搜索树.html#算法公开课">有序数组构建二叉搜索树</a></p><ol><li>终止条件： 节点为空</li><li>处理逻辑：<ol><li>有序数组的中间位置为根节点</li><li>左子树，调用区间构建左子树</li><li>右同上</li></ol></li></ol><h2 id="二叉搜索树求和">1.20. 二叉搜索树求和</h2><p><a href="https://programmercarl.com/0538.把二叉搜索树转换为累加树.html#算法公开课">二叉搜索树转换为累加树</a></p><ol><li>终止条件： ~</li><li>处理逻辑： <ol><li>二叉树有序，选择右中左遍历</li><li>每次遍历时，需使用pre保存前一节点的累加和</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈-队列</title>
      <link href="/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88-%E9%98%9F%E5%88%97/"/>
      <url>/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈">1. 栈</h1><p><strong>感谢<a href="https://programmercarl.com/0101.对称二叉树.html#思路">代码随想录</a></strong></p><h2 id="栈模拟队列">1.1. 栈模拟队列</h2><p><a href="https://programmercarl.com/0232.用栈实现队列.html#算法公开课">模拟队列</a></p><p><img src="https://file1.kamacoder.com/i/algo/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2"></p><p>使用两个栈模拟队列</p><ol><li>入队时， 直接入队</li><li>出队时， 将输入栈的数据放入输出栈中，将顺序倒置为先入先出</li><li>判空时，需要判断两个栈是否为空</li></ol><h2 id="栈队列排除元素">1.2. 栈队列排除元素</h2><p><a href="https://programmercarl.com/0844.比较含退格的字符串.html#思路">含有退格的字符串</a></p><blockquote><p>题目中遇到<code>i</code>元素， 需要退回<code>i-1</code>的元素时，可以使用栈弹出<code>i-1</code>元素</p></blockquote><h3 id="双指针法">1.2.1. 双指针法</h3><p>slow , fast 从后向前比较</p><ol><li>元素相同，同时向前</li><li>遇到<code>#</code> ，slow / fast 向前</li><li>否则， 返回false</li></ol><h1 id="队列">2. 队列</h1><h2 id="队列模拟栈">2.1. 队列模拟栈</h2><p><img src="/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88-%E9%98%9F%E5%88%97/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225.用队列实现栈"></p><p>可以使用一个队列实现栈的模拟</p><ol><li>入栈时，直接入队</li><li>出栈时，需要将前置数据依次排出，并放置在队首，<strong>出队时需要保留最后一个元素出队</strong></li></ol><h2 id="滑动窗口最大值">2.2. 滑动窗口最大值</h2><p><a href="https://programmercarl.com/0347.前K个高频元素.html#思路">滑动窗口最大值</a></p><p><code>deque</code> 用法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;deque&gt;deque&lt;int&gt; d;d.front(), d.back();d.push_back(), d.pop_back();d.push_front(), d.pop_front();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建排序队列，将可能的最大值放入队列中，定义新的队列弹出方法</p><ol><li>入队，入队值如果大于栈顶值，将栈顶出栈，直到入队值小于栈顶值</li><li>出队，队首值如果等于移除的数据，将输出出栈</li><li>保持第一个值是最大值a，且比a小的值是在a之后入栈的，所以出队时a之前的数据已经弹出完毕</li></ol><h2 id="优先队列">2.3. 优先队列</h2><p><a href="https://programmercarl.com/0347.前K个高频元素.html#思路">前k个高频词汇</a></p><p><code>priority_queue</code>需要自定义排序类型</p><ol><li>使用` bool operator()(const int&amp; a, const int&amp; b)自定义比较类型</li><li>快排中left&gt; right，从大到小，优先队列反过来</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class mycomparison&#123;    public:    bool operator()(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;        return a.second &gt; b.second;    &#125;&#125;;priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt; , mycomparison&gt; q;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用小顶堆，优先排除较小元素，将较大元素保留在优先队列中。</p><h1 id="单调栈">3. 单调栈</h1><h2 id="右侧最高气温">3.1. 右侧最高气温</h2><p><a href="https://programmercarl.com/0739.每日温度.html">最高气温</a></p><p>查找右边 比 当前元素更小的元素</p><ol><li>右边比自身大，找到了，当前元素出栈</li><li>右边比自身小，没找到，入栈</li></ol><p>栈中元素为待查找的元素，找到了就出栈</p><h2 id="nums1元素在nums2中下一个最大元素">3.2. nums1元素在nums2中下一个最大元素</h2><p><a href="https://programmercarl.com/0496.下一个更大元素I.html">nums1元素在nums2中下一个最大元素</a></p><ol><li>先计算<code>num2</code>中下一个更大元素的结果，保存在<code>map</code>中</li><li><code>num1</code>从<code>map</code>中取得结果</li></ol><h2 id="循环数组的下一最大元素">3.3. 循环数组的下一最大元素</h2><p><a href="https://programmercarl.com/0503.下一个更大元素II.html#算法公开课">循环数组的下一最大元素</a></p><p><code>nums</code>是一个循环数组，最后一个元素接在第一个元素</p><blockquote><ol><li>对数组循环时， 使用 <strong><code>% nums.size()</code></strong> 对数组循环遍历</li><li>遍历次数增加一倍，从<code>1</code>遍历到 <code>2*n</code></li></ol></blockquote><h2 id="接雨水">3.4. 接雨水</h2><p><a href="https://programmercarl.com/0042.接雨水.html#思路">接雨水</a></p><p>左边和右边高度高于中间时，中间出现凹槽， 可以接到雨水</p><h3 id="暴力求解">3.4.1. 暴力求解</h3><p>当前节点<code>j</code></p><ol><li><p>左边<code>[0,j-1]</code>最大高度<code>lheight</code>,右边<code>[j+1 , end]</code>最大高度<code>rheight</code>，每次暴力求解这两个指针</p></li><li><p>计算高度差，使用列方向计算求和</p><p><img src="/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88-%E9%98%9F%E5%88%97/20210402091208445.png" alt="列方向求和" style="zoom:75%;"></p></li></ol><h3 id="动态规划">3.4.2. 动态规划</h3><ol><li><code>j</code>左边最大高度 = <code>j-1</code>左边最高高度，或者<code>height[j-1]</code></li><li>右边计算公式为 <code>rheight[j] =  max(rheight[j+1] , height[j+1])</code></li></ol><p>先计算出<code>dp</code>， 代替<a href="#暴力求解">暴力求解</a> 中的双指针</p><h3 id="单调栈-1">3.4.3. 单调栈</h3><p>单调递增栈中，栈底 &gt; 栈头</p><p>如果出栈<code>j</code>， 栈头元素&gt; <code>j</code>, 即将入栈元素 &gt; <code>j</code>， 出现凹槽，计算这个凹槽</p><p>宽 = <code>入栈元素 - 栈顶元素</code>， 高度 = <code>min(入栈， 栈顶) - 出栈元素(凹槽)</code></p><p><img src="/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%A0%88-%E9%98%9F%E5%88%97/20210223092629946.png" alt="行计算"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表-字符串</title>
      <link href="/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表">1. 哈希表</h1><p><strong>感谢<a href="https://programmercarl.com/">代码随想录</a></strong></p><h2 id="快乐数">1.1. 快乐数</h2><p><a href="https://programmercarl.com/0202.快乐数.html#思路">快乐数</a></p><p>查找数字是否重复出现，使用哈希表存储</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;set&gt;set&lt;int&gt; s;s.insert(a); &#x2F;&#x2F; 插入数据if(s.find(a)!&#x3D; s.end())&#123;    &#x2F;&#x2F; 查找数据是否在s中    &#x2F;&#x2F;如果出现 !&#x3D; s.end(), 没出现 &#x3D;&#x3D; s.end()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两数之和">1.2. 两数之和</h2><p><a href="https://programmercarl.com/0001.两数之和.html#算法公开课">两数之和</a></p><ol><li>map存放在之前的数据，也是当前查询中匹配的数据</li><li>map中key对应数值，value对应索引</li><li>unordered_map中使用Hash存储， map中使用红黑树存储</li></ol><h2 id="三数之和">1.3. 三数之和</h2><p><a href="https://programmercarl.com/0015.三数之和.html#思路">三数之和</a></p><ol><li><p>使用三个指针，查找指针对应的数据之和是否为0</p></li><li><p>指针去重，结果中不能包含统一的数据，所以在取得结果后再去重，而不是先去重再计算结果</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(i&gt; 0 &amp;&amp; nums[i]&#x3D;&#x3D; nums[i-1])&#123;continue;&#x2F;&#x2F;对已有结果去重&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>vector<int><strong>{</strong>1， 2，3<strong>}</strong>，使用{}作为临时vector</int></p></li><li><code>for( ; ; )</code> 中第一个式子只对第一次循环有效，循环中赋初值需放在循环内</li></ol><h2 id="两次hash统计">1.4. 两次hash统计</h2><p><a href="https://programmercarl.com/1207.独一无二的出现次数.html#思路">独一无二出现次数</a></p><p>出现次数只出现一次，返回<code>true</code></p><ol><li><p>先统计<code>数字</code>出现次数</p><blockquote><p>数字中如果有负数，计算次数时， 数组索引需增加最小值</p></blockquote></li><li><p>统计 <code>出现次数</code>的次数</p><blockquote><p>出现次数为0 的次数，直接跳过</p></blockquote></li></ol><h1 id="字符串">2. 字符串</h1><h2 id="反转字符串">2.1. 反转字符串</h2><p><a href="https://programmercarl.com/0541.反转字符串II.html#思路">反转字符串2</a></p><ol><li>对于有规律的计数时，使用i = i+ num， </li><li>reverse(begin()+i， begin+k)，反转范围为[i,k）</li></ol><h2 id="花式反转">2.2. 花式反转</h2><p><a href="https://programmercarl.com/0151.翻转字符串里的单词.html#思路">先反转整体，再反转局部</a></p><ol><li>去除空格时，sum值代表字符串的长度</li><li>当s 遍历到结尾时，也是一个反转条件</li></ol><h2 id="KMP算法">2.3. KMP算法</h2><p>获得next数组</p><ol><li>初始化为0</li><li>如果s[i] 与s[j] 相同，最长的 j +1；</li><li>否则与next[j-1]的字串进行比较；</li></ol><p>比较</p><ol><li>如果s[i] 与t[j] 相同， j++ ，比较下一位</li><li>否则返回到最长的公共子串的下一位， 即next[j-1]比较</li></ol><blockquote><p>next初值赋值为1 时，相当于next 向右移动了一位，此时不相同时，取next[j]即可</p></blockquote><h2 id="重复子串">2.4. 重复子串</h2><p><a href="https://programmercarl.com/0459.重复的子字符串.html">重复子串</a></p><p><img src="/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%AD%97%E7%AC%A6%E4%B8%B2/20220728104931.png" alt="图二"></p><p><strong>结论： 如果s是由重复序列组成，那么s+s中一定具有s</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论0</title>
      <link href="/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA0/"/>
      <url>/2025/08/22/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%9B%BE%E8%AE%BA0/</url>
      
        <content type="html"><![CDATA[<h1 id="history">1. history</h1><h2 id="岛屿">1.1. 岛屿</h2><h2 id="图查找算法">1.2. 图查找算法</h2><h3 id="并查集的实现-并查集理论基础-代码随想录">1.2.1. 并查集的实现   并查集理论基础 | 代码随想录</h3><ol><li>并查集，是将一个集合内所有数据放入一个连通图中，即为father[u]= v；</li><li>查询一个并查集，是查询根节点是否相同，find(u)== find(v)</li><li>初始化，所有的并查集都指向自身</li><li>路径压缩，节点在find过程中都执行根节点</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 使用数据存放并查集vector&lt;int&gt; father(n, 0);void init()&#123;    for(int i &#x3D; 0;i&lt; father.size();i++)&#123;        father[i]&#x3D; i;    &#125;&#125;int find(int u)&#123;    if(father[u]&#x3D;&#x3D;u) return u;    else &#123;        father[u]&#x3D;find(father[u]);&#x2F;&#x2F; 路径压缩，指向根节点    &#125;    return father[u];&#125;int is_same(int u, int v)&#123;    int a &#x3D; find(u);    int b &#x3D; find(v);    if(a &#x3D;&#x3D; b) return 1;    else return 0;&#125;void join(int u, int v)&#123;    int a &#x3D; find(u);    int b &#x3D; find(v);    if(a &#x3D;&#x3D; b) return ;    father[u]&#x3D; v;    return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="prim算法">1.2.2. prim算法</h3><ol><li>选择最小边e,v（e是树中，v是树外的数据）</li><li>将节点v加入树中</li><li>更新与v的节点的权重<ol><li>此处记录树的连接关系，记录当前节点的父亲</li></ol></li></ol><h3 id="kruskal-算法">1.2.3. kruskal 算法</h3><ol><li>完成并查集</li><li>对边的权重排序</li><li>选择最小边<ol><li>如果在并查集中，跳过</li><li>不在并查集中，加入节点树种</li></ol></li></ol><h3 id="拓扑排序">1.2.4. 拓扑排序</h3><ol><li>计算节点入度</li><li>选择入度为0 的节点，加入处理队列q, 并将入度替换为-1</li><li>处理队列q<ol><li>cur指向的所有节点，入度减1</li><li>如果入度等于1，加入处理队列q, 并将入度替换为-1</li><li>记录出队元素cur.</li></ol></li></ol><blockquote><p>出队元素不等于总元素数量时， <strong>判断有向图中 存在环</strong></p></blockquote><h3 id="dijkstra算法">1.2.5. dijkstra算法</h3><p><strong><u>权值不能为负数，prim算法权值可以是负数，负数情况使用ford算法</u></strong></p><ol><li>选择最小边并且该节点没有被访问过</li><li>标记该节点，已经被访问过</li><li>更新非访问节点到源点的最小距离，同时当前节点的父亲</li></ol><h3 id="使用边权重的dijkstra算法">1.2.6. 使用边权重的dijkstra算法</h3><p>使用边的权值进行计算</p><ol><li>建立小顶堆</li><li>从小顶堆中选择最小的边</li><li>标记边连线的点已经被访问过了</li><li>更新edge相连的顶点的权重</li></ol><h1 id="附录">2. 附录</h1><h2 id="建立小顶堆">2.1. 建立小顶堆</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;queue&gt;class mycomparison&#123;    bool operator(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;        return a.second&gt; b.second;    &#125;&#125;priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int,int&gt;&gt; , mycomparison&gt; p;&#x2F;*a&gt; b时 ，是小顶堆；a&lt; b时， 是大顶堆；*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对vector数组进行排序">2.2. 对vector数组进行排序</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;algorithm&gt;vector&lt;int&gt; edges;sort(edges.begin() , edges.end(), [](const edge&amp; a, const edge&amp; b)&#123;return a&lt; b;&#125;);&#x2F;*a&lt; b， 升序排序；a&gt; b， 降序排序；默认情况是升序排序；*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="哈希表">2.3. 哈希表</h2><h3 id="数组作为哈希表">2.3.1. 数组作为哈希表</h3><h3 id="stl中的哈希表">2.3.2. stl中的哈希表</h3><p>此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><h2 id="回溯算法">2.4. 回溯算法</h2><p>算法的模板</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void backtracking(参数)&#123;    if(终止条件）&#123;        存放结果;       return;    &#125;    for(选择:本层集合中的元素)&#123;        处理节点;        backtracking(路径， 选择列表); &#x2F;&#x2F;递归        回溯，撤销处理结果;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>vector<int> a </int></p><p>a.push_back(int b) 压入数据， a.pop_back(), 弹出数据</p><p>还可以采用insert， + ，压入数据，使用erase(begin()+ i ,end())弹出数据</p></blockquote><p>使用切割时候，需要注意下一次开始为本次切割后的下一次位置，此处回溯时候不需要还原，其余元素均需要还原。还原时候注意还原的位置。</p><p><a href="https://programmercarl.com/0131.分割回文串.html#算法公开课">回溯问题</a></p><h3 id="分割字符串方法">2.4.1. 分割字符串方法</h3><ol><li>函数传递，参数<code>s + start + end</code></li><li>使用string 切割，<code>string s = s.substr(start, end)</code></li></ol><h3 id="两阶vector初始化方法">2.4.2. 两阶vector初始化方法</h3><p><code>is_palind_rome.resize(s.size(), vector&lt;bool&gt;(s.size(), false));</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/10/c/STL/"/>
      <url>/2025/07/10/c/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构">1. 数据结构</h1><h2 id="list">1.1. list</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;list&gt;List&lt;int&gt; mylist;list&lt;string&gt; names&#x3D; &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;list&lt;int&gt; list(my_list.begin(), mylist.end());list&lt;int&gt; tenZeros(10);&#x2F;&#x2F; 初始化十个数，默认为0list&lt;int&gt; tenSeverns(10,7); &#x2F;&#x2F; 初始化十个7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加元素">1.1.1. 添加元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mylist.push_back(10);mylist.push_front(10);&#x2F;&#x2F; 在这个迭代器之前插入元素auto it &#x3D; mylist.begin();mylist.insert(it+1, 15);&#x2F;&#x2F; 在这个迭代器后插入一串元素mylist.insert(it, vec.begin() ,vec.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="访问">1.1.2. 访问</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mylist.enpty()mylist.front()mylist.back()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="删除元素">1.1.3. 删除元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mylist.pop_front(); &#x2F;&#x2F;有返回吗mylist.pop_back();auto it &#x3D; mylist.begin();it &#x3D; mylist.erase(it);mylist.erase(mylist.begin()+1, mylist.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历">1.1.4. 遍历</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(auto it &#x3D; mylist.begin(); it !&#x3D; mylist.end() ;it++)&#123;(*it) ++; &#125;for(auto num : mylist)&#123;    num++;&#125;for(auto&amp; num :mylist)&#123;num ++; &#x2F;&#x2F;修改值时使用引用   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合并">1.1.5. 合并</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mylist.sort(); &#x2F;&#x2F; 默认从小到大排序mylist.sort([](int a, int b)&#123;    return a&gt;b;&#125;);&#x2F;&#x2F;a&gt;b 从大到小排序&#x2F;&#x2F; 合并 ,要求list1, list2都需要排序list1.merge(list2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="唯一化">1.1.6. 唯一化</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mylist.unique();&#x2F;&#x2F; 自定义相等mylist.unique([](int a, int b)&#123;return abs(a-b)&lt;2;&#125;);&#x2F;&#x2F; 反转 revList.reverse();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拼接">1.1.7. 拼接</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::list&lt;int&gt; listA &#x3D; &#123;1, 2&#125;;std::list&lt;int&gt; listB &#x3D; &#123;3, 4, 5&#125;;listA.splice(listA.end(), listB); &#x2F;&#x2F; listA: &#123;1, 2, 3, 4, 5&#125;, listB: &#123;&#125;listX.splice(listX.end(), listY, it_y); &#x2F;&#x2F; listX: &#123;10, 20, 30&#125;, listY: &#123;40, 50&#125;listP.splice(listP.end(), listQ, first_q, last_q);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vector">1.2. vector</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;vector&lt;int&gt; myv;&#x2F;&#x2F; 从数组中创建vectorarr &#x3D; &#123;1,2,3,4&#125;;myv &#x3D; vector&lt;int&gt; (arr, arr+ sizeof(arr)&#x2F; sizeof(arr[0]));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入数据">1.2.1. 插入数据</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">myv.push_back(value);myv.emplace_back(value1, value2);&#x2F;&#x2F; value1 ,value2 可以组成结构体数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="访问元素">1.2.2. 访问元素</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">myv[0] ;try&#123;    myv.at(0);    &#x2F;&#x2F; 对数据边界检测，返回Out_of_range 异常&#125;catch &#123;const out_of_range&amp; e&#125;&#123;    cerr&lt;&lt; e.what()&lt;&lt;endl;&#125;auto it &#x3D; myv.front(); &#x2F;&#x2F; 返回引用，指针？值引用？auto it &#x3D; myv.back();int* data&#x3D; myv.data();&#x2F;&#x2F; 返回数据数组指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序">1.2.3. 排序</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;sort(my.begin() , my.end());&#x2F;&#x2F; 从小到大排序sort(my.begin(), my.end(), [](int a, int b)&#123;return a&gt;b;  &#125;);sort(my.begin(), my.end(), greater&lt;int&gt;());&#x2F;&#x2F; 从大到小排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合并-1">1.2.4. 合并</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; merge(v1.size() + v2.size());&#x2F;&#x2F; v1，v2完成排序，合并结果在merge中merger(v1.begin, v1.end() ,v2.begin(), v2.end(), merge.begin());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="stack-and-queue">1.3. stack and queue</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stack&gt;stack&lt;int&gt; mys &#x3D; stack&lt;int, vector&lt;int&gt;&gt; (vec); &#x2F;&#x2F; 指定底层容器有什么效果mys.push();mys.top();mys.pop();mys.size();mys.empty();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;queue&gt;queue&lt;int&gt; myq ;queue&lt;int, list&lt;int&gt;&gt; myq(vec);myq.push();myq.front(); &#x2F;&#x2F; 对头使用front, 栈顶使用topmyq.back(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="deque">1.4. deque</h2><p>使用方法与vector类似，存储使用块与链表链接，比vector的性能好</p><h2 id="map">1.5. map</h2><p>数据有序排列</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;map&gt;map&lt;string, age&gt; mymap &#x3D;&#123;&#123;&quot;a&quot;,20&#125;&#125;;mymap[&quot;b&quot;]&#x3D;20;auto [it, inserted] &#x3D; mymap.insert&#123;&#123;&quot;c&quot;,10&#125;&#125;;mymap.emplace(&quot;c&quot;,10);&#x2F;&#x2F; 如果插入已存在，inserted值为false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="访问-1">1.5.1. 访问</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mymap[&quot;a&quot;]; &#x2F;&#x2F; 没有自动创建元素mymap.at[&quot;b&quot;];&#x2F;&#x2F; 没有抛出异常out_of_rangeauto it &#x3D; mymap.find(key);if(it !&#x3D; mymap.end())&#123;    return 0;&#125;&#x2F;&#x2F; 对键进行计数，map默认最多有1个键值if(mymap.count(key))&#123;    &#125;for(auto&amp; pair: mymap)&#123;    pair.first; &#x2F;&#x2F; key是第一个元素    pair.second; &#x2F;&#x2F;value是第二个元素&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="unordered-map">1.5.2. unordered_map</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;unordered_map&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用Hash表映射</p><h3 id="multimap">1.5.3. multimap</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">multimap&lt;string, int&gt; mymap;&#x2F;&#x2F; 不可以使用[], at()&#x2F;&#x2F;find()， 返回一个迭代器&#x2F;&#x2F;equal_range(key), 返回一个pair, 包含两个迭代器，表示所有具有该键的元素的范围（[first, last)）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="unordered-multimap">1.5.4. unordered_multimap</h3><p>使用方法与multimap相同</p><h2 id="pair">1.6. pair</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;utility&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="set">1.7. set</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;set&gt;set&lt;int, [](int a, int b)&#123;    return a&gt;b&#125;&gt; set1 &#x3D; &#123;1,2,3,4&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="使用红黑树，自定义操作符">1.8. 使用红黑树，自定义操作符</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct person&#123;    int age;        bool operator&lt;(const Person&amp; other) const&#123;        if(age !&#x3D; other.age)&#123;            return age&lt; other.age;        &#125;    &#125;        friend ostream&amp; operator&lt;&lt;(ostream&amp;&amp; os, const person&amp; p)&#123;        os&lt;&lt;p.age&lt;&lt;endl;        return os;    &#125;&#125;map&lt;person, int&gt; mymap;struct PointCompare &#123;    bool operator()(const Point&amp; p1, const Point&amp; p2) const &#123;        if (p1.x !&#x3D; p2.x) &#123;            return p1.x &lt; p2.x;        &#125;        return p1.y &lt; p2.y;    &#125;&#125;;std::map&lt;Point, std::string, PointCompare&gt; pointMap;&#x2F;&#x2F; 这里不能使用out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="priority-queue">1.9. priority_queue</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 只能使用仿函数类型class mycomparison&#123;    public:    bool operator()(const int&amp; a,const int&amp; b)const&#123;        if(a&gt;b)&#123;            return true;        &#125;else&#123;            return false;        &#125;    &#125;&#125;;priority_queue&lt;int&gt; q;&#x2F;&#x2F; 大顶堆，数据大的在顶端priority_queue&lt;int, vector&lt;int&gt;, mycomparison&gt; min_pq; &#x2F;&#x2F;小顶堆，小数据在顶端<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="numeric">1.10. numeric</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;numeric&gt;int sum &#x3D; std::accumulate(numbers.begin(), numbers.end(), 0);&#x2F;&#x2F; 默认求和int product &#x3D; std::accumulate(numbers.begin(), numbers.end(), 1, std::multiplies&lt;int&gt;());&#x2F;&#x2F; 默认求积#include &lt;algorithm&gt;auto min_it &#x3D; min_element(number.begin(), number.end(), mycomparison);auto max_it &#x3D; max_element(number.begin(), number.end(), mycomparison);auto minmax &#x3D; minmax_element(number.begin(), number.end(),mycomparison);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习</title>
      <link href="/2025/05/24/python/deeplearn/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/05/24/python/deeplearn/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习">1. 深度学习</h1><h2 id="数据读取">1.1. 数据读取</h2><h3 id="标签转换为数据迭代器">1.1.1. 标签转换为数据迭代器</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from torch.utils import data# 传入多个数据，类似数据压缩 data_arrays，对数据进行解压缩dataset &#x3D; data.TensorDataset(data_arrays)# 创建迭代器，batch_sizedata.DataLoader(dataset, batch_size, shuffle&#x3D;is_train)# iter返回一个迭代器对象， next读取迭代器的下一个数据next(iter(data))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从torchvision-datasets读取">1.1.2. 从torchvision.datasets读取</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from torchvision import transformsfrom torch.utils import dataimport torchvisiondef load_data(batch_size, resize &#x3D; None): # 定义数据处理方式       trans &#x3D; [transforms.ToTensors()]    if resize:        trans.insert(0, transforms.Resize(resize))    trans &#x3D; transforms.Compose(trans)# 使用Compose转换        # 选择数据导出模式    &#39;&#39;&#39;    root - 数据保存地址    train - 训练数据    transforms 转换模式    download 是否选择下载    &#39;&#39;&#39;    mnist_train &#x3D; torchvision.datasets.FashionMNIST(    root &#x3D; &quot;..&#x2F;data&quot;, train &#x3D; True, transforms &#x3D; trans, download &#x3D; True)        &#39;&#39;&#39;    batch_size: 每个批次包含多少个样本。shuffle: 是否在每个 epoch 开始时打乱数据（训练集通常为 True，测试集通常为 False）。num_workers (可选): 用于数据加载的子进程数量，可以加快数据读取速度。    &#39;&#39;&#39;    data &#x3D; data.DataLoader(mnist_train, batch_size, shuffle &#x3D; True,                          num_workers &#x3D; 3)       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列数据">1.1.3. 序列数据</h3><p>对于总长度T， 时间$\tau$ ,将数据分为</p><script type="math/tex; mode=display">y_t = X_t \\x_t = [x_[t-\tau]... x_{t-1}] \\但是x_t 相对Y_t少了\tau个，可以舍弃，也可以填充0</script><pre class="line-numbers language-python" data-language="python"><code class="language-python">tau &#x3D; 4features &#x3D; torch.zeros((T - tau, tau))for i in range(tau):    features[:, i] &#x3D; x[i: T - tau + i]labels &#x3D; x[tau:].reshape((-1, 1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>读取数据</li><li>词元化（转换为单词或字符）</li><li>转换为词元与数字的映射</li><li>将映射作用在序列数据上，转换为向量表示</li><li><a href="#squence">数据预处理代码</a></li></ol><h3 id="文本序列数据">1.1.4. 文本序列数据</h3><ol><li>读取数据到string中</li><li>使用split(\t) 分割为英法双语，然后使用.split(‘ ‘)将单词分割</li><li>然后将单词词元，建立词表</li><li>使用词表，转换为向量，对向量进行阶段或填充，然后在向量末尾增加<eos>，再统计序列中有效的单元数量valid_len</eos></li><li>指定批量大小，转换为小批量迭代器</li></ol><p><a href="#读取文本序列数据">读取文本序列代码</a></p><h2 id="模型">1.2. 模型</h2><h3 id="线性模型linear">1.2.1. 线性模型linear</h3><p>第一个指定输入特征形状，即2，第二个指定输出特征形状</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from torch import nnnet &#x3D; nn.Sequential(nn.Linear(2, 1))loss &#x3D; nn.MSELoss()trainer &#x3D; torch.optim.SGD(net.parameters(), lr&#x3D;0.03)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="展平层">1.2.2. 展平层</h3><p>将(batch_size, channel, height, weight) 转换为(batch_size, channel<em> height</em>weight)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">nn.Flatten(start_dim &#x3D; 1, end_dim &#x3D;-1) # 默认保留第一维batch_sizenn.LogSoftmax(dim&#x3D;1) # 作用于最后一个维度，进行归一化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="MLP">1.2.3. MLP</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from torch import nnnet &#x3D; nn.Sequential(nn.Flatten(),nn.Linear(784, 256),nn.ReLU(),nn.Linear(256, 10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CNN">1.2.4. CNN</h3><p>不变性：无论使用什么方法找到这个物体，都与物体的位置无关</p><p>原因：与像素点计算的卷积核都是相同的，不随着位置的改变而改变</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;param1: 输入通道param2: 输出通道parma3: 卷积核大小param4: 参数&#39;&#39;&#39;conv2d &#x3D; nn.Conv2d(1,1, kernel_size&#x3D;(1, 2), bias&#x3D;False)&#39;&#39;&#39;卷积核大小 &#x3D; input_channels* kernel_size, 每一个卷积核计算的出来都是一个二维图形卷积核数量 &#x3D; output_channels&#39;&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="填充padding">1.2.4.1. 填充padding</h4><p>卷积核最好选择奇数</p><p>填充高度与宽度满足$p_h = k_h -1 , p_w = k_w -1$,  在上下填充的高度与宽度分别为 ${p_h}/{2} , p_w/2$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">conv2d &#x3D; nn.Conv2d(1,1, kernel_size&#x3D;(3, 3),padding &#x3D; 1, bias&#x3D;False)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="步幅">1.2.4.2. 步幅</h4><p>输出形状公式为</p><script type="math/tex; mode=display">\lfloor（n_h-k_h-+p_h+s_h)/s_h\rfloor \\p_h = k_h-1 \\所以结果为（n_h+s_h-1)/s_h, \\可以整除情况下，=（n_h+s_h)/s_h</script><pre class="line-numbers language-python" data-language="python"><code class="language-python">conv2d &#x3D; nn.Conv2d(1, 1, kernel_size&#x3D;(3, 5), padding&#x3D;(1, 2), stride&#x3D;(3, 4))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>当以每像素为基础应用时，$1\times 1$卷积层相当于全连接层。</li></ul><h3 id="批量归一化层BatchNorm">1.2.5. 批量归一化层BatchNorm</h3><script type="math/tex; mode=display">\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}.</script><p>对特征维度进行归一化,$\gamma、\beta$ 是拉伸和偏移参数</p><ol><li><p>对特征维度进行归一化</p><pre class="line-numbers language-none"><code class="language-none">mean &#x3D; X.mean(dim &#x3D; 0, keepdim &#x3D; True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>卷积层</p><ol><li>对通道维度进行归一化</li></ol></li><li><p>训练状态下使用小批次的样本均值与方差，测试状态使用的移动平均估算的均值与方差</p></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;param: 输入通道数&#39;&#39;&#39;nn.BatchNorm2d(6)  nn.BatchNorm1d(128)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="残差块">1.2.6. 残差块</h3><p>训练是模型训练出F(X) = H(x)- X</p><p><img src="/2025/05/24/python/deeplearn/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20250423225436209.png" alt="image-20250423225436209"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import torch from torch import nnfrom torch.nn import functional as Fclass Residual(nn.Module):    def __init__(self , input_channels, num_channels, use_1x1conv&#x3D; False, strides &#x3D;1):        super().__init__()        self.conv1 &#x3D; nn.Conv2d(input_channels, num_channels, kernel_size &#x3D; 3, paddding &#x3D; 1, stride &#x3D; strides)        self.conv2 &#x3D; nn.Conv2d(num_channels, num_channels, kernel_size &#x3D; 3, paddding &#x3D; 1, stride &#x3D; strides)        # 修改X的通道数量，与f(x) - x匹配        if use_1x1conv :            self.conv3 &#x3D; nn.Conv2d(input_channels, num_channels, kernel_size &#x3D;1 ,padding &#x3D; 0, stride &#x3D; strides)        else :            self.conv3 &#x3D; none        self.bn1 &#x3D; nn.BatchNorm2d(num_channels)        self.bn2 &#x3D; nn.BatchNorm2d(num_channels)    def forward(self,X):        Y &#x3D; F.relu(self.bn1(self.conv1(X)))        Y &#x3D; self.bn2(self.conv2(Y))        # 修改X输出通道数量        if conv3 :            X &#x3D; self.conv3(X)        # 实现Y &#x3D; f(x) +X        Y &#x3D; Y+ X        Y &#x3D; F.relu(Y) return Y        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="池化层pooling">1.2.7. 池化层pooling</h3><p>汇聚卷积层计算出的信息，降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from torch import nnnn.MaxPool2d((3,3), padding &#x3D;(0,1), stride &#x3D; (0,1))  # 最大池化层nn.AvgPool2d((2, 3), stride&#x3D;(2, 3), padding&#x3D;(0, 1))  # 平均池化层&#39;&#39;&#39;param1 : 输出层形状(1,1), 网络自动计算padding, stride ,k ,转化为(1,1)的输出维度&#39;&#39;&#39;nn.AdaptiveAvgPool2d((1,1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>池化层不需要指出Input_channels, output_channels， <strong>input_channels =output_channels</strong></p><p>例如，Lenet网络</p><p><img src="/2025/05/24/python/deeplearn/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20250423211333286.png" alt="image-20250423211333286"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">net &#x3D; nn.Sequential(    nn.Conv2d(1, 6, kernel_size&#x3D;5, padding&#x3D;2), nn.Sigmoid(),    nn.AvgPool2d(kernel_size&#x3D;2, stride&#x3D;2),    nn.Conv2d(6, 16, kernel_size&#x3D;5), nn.Sigmoid(),    nn.AvgPool2d(kernel_size&#x3D;2, stride&#x3D;2),    nn.Flatten(),    nn.Linear(16 * 5 * 5, 120), nn.Sigmoid(),    nn.Linear(120, 84), nn.Sigmoid(),    nn.Linear(84, 10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环神经网络RNN">1.2.8. 循环神经网络RNN</h3><script type="math/tex; mode=display">隐藏输出\\\mathbf{H}_t = \phi(\mathbf{X}_t \mathbf{W}_{xh} + \mathbf{H}_{t-1} \mathbf{W}_{hh}  + \mathbf{b}_h).\\输出\\\mathbf{O}_t = \mathbf{H}_t \mathbf{W}_{hq} + \mathbf{b}_q.</script><h4 id="深度循环deep-rnn">1.2.8.1. 深度循环deep_rnn</h4><p>RNN相当于Drnn中，$H_{t}^{0} = X_t$</p><script type="math/tex; mode=display">\mathbf{H}_t^{(l)} = \phi_l(\mathbf{H}_t^{(l-1)} \mathbf{W}_{xh}^{(l)} + \mathbf{H}_{t-1}^{(l)} \mathbf{W}_{hh}^{(l)}  + \mathbf{b}_h^{(l)})\\\mathbf{O}_t = \mathbf{H}_t^{(L)} \mathbf{W}_{hq} + \mathbf{b}_q</script><h4 id="双向循环rnn">1.2.8.2. 双向循环rnn</h4><p><img src="/2025/05/24/python/deeplearn/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20250424175214314.png" alt="image-20250424175214314"></p><p><strong>多用于对文本的编码，而不是预测文本</strong></p><h4 id="代码介绍">1.2.8.3. 代码介绍</h4><p>输入X = （time_step ,batch_size, feature), output = (time_step ,batch_size, num_hidden*(1/2)), state = (time_step ,batch_size, num_hidden)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from torch import nnrnn &#x3D; nn.RNN(num_input, num_hiddens)gru_layer &#x3D; nn.GRU(num_inputs, num_hiddens)lstm_layer&#x3D;nn.LSTM(num_inputs, num_hiddens)# drnn&#39;&#39;&#39;X_&#123;batch* num_input&#125;* W_&#123;num_input * num_hidder&#125; num_inputs: 输入的特征数量num_hidden：隐神经元数量 &#x3D; 隐状态的特征数量bidirectional: 双向循环网络&#39;&#39;&#39;lstm_layer &#x3D; nn.LSTM(num_inputs, num_hidden, num_layers, bidirectional&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RNN 利用<strong>时间维度</strong>的参数共享实现了对<em>*时间位置</em>，每一个时间步使用的一套参数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def rnn(inputs, state, params):    # inputs的形状：(时间步数量，批量大小，词表大小)    W_xh, W_hh, b_h, W_hq, b_q &#x3D; params        H, &#x3D; state    outputs &#x3D; []    # X的形状：(批量大小，词表大小)    for X in inputs:        H &#x3D; torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h)        Y &#x3D; torch.mm(H, W_hq) + b_q        outputs.append(Y)    return torch.cat(outputs, dim&#x3D;0), (H,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2025/05/24/python/deeplearn/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20250424173608710.png" alt="image-20250424173608710"></p><h4 id="梯度衰减">1.2.8.4. 梯度衰减</h4><p>减小梯度，避免梯度爆炸，使得梯度始终保持在$\theta$ 以下</p><script type="math/tex; mode=display">\mathbf{g} \leftarrow \min\left(1, \frac{\theta}{\|\mathbf{g}\|}\right) \mathbf{g}.</script><p><a href="#grad_clipping">梯度裁剪代码</a></p><h2 id="激活函数">1.3. 激活函数</h2><p>将模型从线性变为非线性</p><h3 id="relu">1.3.1. relu</h3><script type="math/tex; mode=display">\operatorname{ReLU}(x) = \max(x, 0).</script><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch.relu(X)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="sigmod">1.3.2. sigmod</h3><p>特征图像，曲线在（0，1）中，关于0.5对称</p><script type="math/tex; mode=display">$$\operatorname{sigmoid}(x) = \frac{1}{1 + \exp(-x)}.</script><script type="math/tex; mode=display"><pre class="line-numbers language-python" data-language="python"><code class="language-python">y &#x3D; torch.sigmod(X)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>### tanh特征图像，曲线在（-1，1）中，关于0对称</script><script type="math/tex; mode=display">\operatorname{tanh}(x) = \frac{1 - \exp(-2x)}{1 + \exp(-2x)}</script><pre class="line-numbers language-python" data-language="python"><code class="language-python">y &#x3D; torch.tanh(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="损失函数">1.4. 损失函数</h2><h3 id="均方误差">1.4.1. 均方误差</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss &#x3D; nn.MSELoss()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="交叉熵损失">1.4.2. 交叉熵损失</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss &#x3D; nn.CrossEntropyLoss(reduction&#x3D;&#39;none&#39;) # 返回的是一个张量，反向传播需要计算为标量# 相当于 NLLLoss(LogSoftmax(logits), target)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="NLLLoss">1.4.3. NLLLoss</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss &#x3D; nn.NLLLoss()  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="训练过程">1.5. 训练过程</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">num_epoch &#x3D; 2for epoch in range(num_epoch):    for X, y in data_iter :        l &#x3D; loss(net(X), y)        train.zero_grad()        # 清除训练模型的梯度, 返回的是一个标量        l.backward()          # 反向计算梯度        trainer.step()        l &#x3D; loss(net(features), labels)  # 计算总体梯度    print(f&#39;epoch&#123;epoch&#125;, loss&#123;1:0.2f&#125;&#39;)                    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模型问题">1.6. 模型问题</h2><h3 id="复杂性因素">1.6.1. 复杂性因素</h3><ol><li>可调整参数的数量。当可调整参数的数量（有时称为<strong>自由度</strong>）很大时，模型往往更容易过拟合。</li><li>参数采用的值。当权重的取值范围较大时，模型可能更容易过拟合。</li><li>训练样本的数量。即使模型很简单，也很容易过拟合只包含一两个样本的数据集。而过拟合一个有数百万个样本的数据集则需要一个极其灵活的模型。</li></ol><h3 id="K折交叉验证">1.6.2. K折交叉验证</h3><p>一个epoch中，将训练数据分为K份，在k-1份上进行训练，在第K份上进行验证</p><h3 id="L2正则化">1.6.3. L2正则化</h3><script type="math/tex; mode=display">\begin{aligned}\mathbf{w} & \leftarrow \left(1- \eta\lambda \right) \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right).\end{aligned}</script><p>每次都减小一定的权重，岭回归相对于线性回归增加了L2正则化，LASSO回归相当于增加了L1回归，相当于参数选择</p><ol><li>选择权重参数，然后正则化</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 选择参数组for name, param in net.named_parameters():    # param.requires_grad 确保只包含需要梯度的参数    if param.requires_grad:        # 根据参数名称判断是否是偏置项        if &#39;bias&#39; in name: # 简单的判断，更严格的判断可以是 name.endswith(&#39;.bias&#39;)            params_without_wd.append(param)        else:            params_with_wd.append(param)# 初始化优化器，使用参数组trainer &#x3D; torch.optim.SGD([    &#123;&#39;params&#39;: params_with_wd, &#39;weight_decay&#39;: wd&#125;,    &#123;&#39;params&#39;: params_without_wd, &#39;weight_decay&#39;: 0&#125; # 对偏置项设置 weight_decay 为 0], lr&#x3D;lr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>对所有参数进行正则化</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">trainer &#x3D; torch.optim.SGD([net.parameters(), lr &#x3D; lr, weigth_decay &#x3D; wd])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="暂退法（Dropout">1.6.4. 暂退法（Dropout)</h3><p>随即丢弃部分神经元</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">nn.Dropout(ratio)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="随机初始化">1.6.5. 随机初始化</h3><p>暂退法和随机初始化，都可以减小神经元的对称性</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from torch.nn.init as initclass SimpleMLP(nn.Module):    def __init__(self):        super(SimpleMLP, self).__init__()        self.fc1 &#x3D; nn.Linear(784, 128) # 例如处理 28x28 图像展平后的输入        self.relu &#x3D; nn.ReLU()        self.fc2 &#x3D; nn.Linear(128, 64)        self.relu2 &#x3D; nn.ReLU()        self.fc3 &#x3D; nn.Linear(64, 10) # 例如输出 10 个类别的概率        # 在这里调用自定义初始化函数        self._initialize_weights()    def _initialize_weights(self):        print(&quot;正在进行自定义初始化...&quot;)        for m in self.modules(): # 遍历模型的所有模块 (包括子模块自身)            # print(f&quot;处理模块: &#123;m&#125;&quot;) # 可以打印查看正在处理的模块类型            if isinstance(m, nn.Linear):                # 对线性层的权重使用 He&#x2F;Kaiming 初始化                init.kaiming_normal_(m.weight, mode&#x3D;&#39;fan_in&#39;, nonlinearity&#x3D;&#39;relu&#39;)                # 对线性层的偏置初始化为常数 0                if m.bias is not None: # 检查偏置是否存在                    init.constant_(m.bias, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="附录">1.7. 附录</h2><p><b id="squence"> squence 序列数据预处理 </b></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 读取序列数据d2l.DATA_HUB[&#39;time_machine&#39;] &#x3D; (d2l.DATA_URL + &#39;timemachine.txt&#39;,                                &#39;090b5e7e70c295757f55df93cb0a180b9691891a&#39;)def read_time_machine():  #@save    &quot;&quot;&quot;将时间机器数据集加载到文本行的列表中&quot;&quot;&quot;    with open(d2l.download(&#39;time_machine&#39;), &#39;r&#39;) as f:        lines &#x3D; f.readlines()    return [re.sub(&#39;[^A-Za-z]+&#39;, &#39; &#39;, line).strip().lower() for line in lines]lines &#x3D; read_time_machine()# 词元化def tokenize(lines, token&#x3D;&#39;word&#39;):  #@save    &quot;&quot;&quot;将文本行拆分为单词或字符词元&quot;&quot;&quot;    if token &#x3D;&#x3D; &#39;word&#39;:        return [line.split() for line in lines]    elif token &#x3D;&#x3D; &#39;char&#39;:        return [list(line) for line in lines]    else:        print(&#39;错误：未知词元类型：&#39; + token)print(type(lines[0]))tokens &#x3D; tokenize(lines)# 词元与数值的映射class Vocab:  #@save    &quot;&quot;&quot;文本词表&quot;&quot;&quot;    def __init__(self, tokens&#x3D;None, min_freq&#x3D;0, reserved_tokens&#x3D;None):        if tokens is None:            tokens &#x3D; []        if reserved_tokens is None:            reserved_tokens &#x3D; []        # 按出现频率排序        counter &#x3D; count_corpus(tokens)        self._token_freqs &#x3D; sorted(counter.items(), key&#x3D;lambda x: x[1],                                   reverse&#x3D;True)        # 未知词元的索引为0        self.idx_to_token &#x3D; [&#39;&lt;unk&gt;&#39;] + reserved_tokens        # 单词到索引梭顺序        self.token_to_idx &#x3D; &#123;token: idx                             for idx, token in enumerate(self.idx_to_token)&#125;                for token, freq in self._token_freqs:            if freq &lt; min_freq:                break            if token not in self.token_to_idx:                # 顺序到单词                self.idx_to_token.append(token)                self.token_to_idx[token] &#x3D; len(self.idx_to_token) - 1    def __len__(self):        return len(self.idx_to_token)    def __getitem__(self, tokens):        if not isinstance(tokens, (list, tuple)):            return self.token_to_idx.get(tokens, self.unk)        return [self.__getitem__(token) for token in tokens]    def to_tokens(self, indices):        if not isinstance(indices, (list, tuple)):            return self.idx_to_token[indices]        return [self.idx_to_token[index] for index in indices]    @property    def unk(self):  # 未知词元的索引为0        return 0    @property    def token_freqs(self):        return self._token_freqsdef count_corpus(tokens):  #@save    &quot;&quot;&quot;统计词元的频率&quot;&quot;&quot;    # 这里的tokens是1D列表或2D列表    if len(tokens) &#x3D;&#x3D; 0 or isinstance(tokens[0], list):        # 将词元列表展平成一个列表        tokens &#x3D; [token for line in tokens for token in line]    return collections.Counter(tokens)def load_corpus_time_machine(max_tokens&#x3D;-1):  #@save    &quot;&quot;&quot;返回时光机器数据集的词元索引列表和词表&quot;&quot;&quot;    lines &#x3D; read_time_machine()    tokens &#x3D; tokenize(lines, &#39;char&#39;)    vocab &#x3D; Vocab(tokens)    # 因为时光机器数据集中的每个文本行不一定是一个句子或一个段落，    # 所以将所有文本行展平到一个列表中    corpus &#x3D; [vocab[token] for line in tokens for token in line]    if max_tokens &gt; 0:        corpus &#x3D; corpus[:max_tokens]    return corpus, vocab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b id="grad_clipping"> 梯度衰减</b></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def grad_clipping(net, theta):  #@save    &quot;&quot;&quot;裁剪梯度&quot;&quot;&quot;    if isinstance(net, nn.Module):        params &#x3D; [p for p in net.parameters() if p.requires_grad]    else:        params &#x3D; net.params    norm &#x3D; torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params))    if norm &gt; theta:        for param in params:            param.grad[:] *&#x3D; theta &#x2F; norm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取文本序列数据">1.7.1. 读取文本序列数据</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import osimport torchfrom d2l import torch as d2l# 下载并读出序列d2l.DATA_HUB[&#39;fra-eng&#39;] &#x3D; (d2l.DATA_URL + &#39;fra-eng.zip&#39;,                           &#39;94646ad1522d915e7b0f9296181140edcf86a4f5&#39;)#@savedef read_data_nmt():    &quot;&quot;&quot;载入“英语－法语”数据集&quot;&quot;&quot;    data_dir &#x3D; d2l.download_extract(&#39;fra-eng&#39;)    with open(os.path.join(data_dir, &#39;fra.txt&#39;), &#39;r&#39;,             encoding&#x3D;&#39;utf-8&#39;) as f:        return f.read()raw_text &#x3D; read_data_nmt()print(raw_text[:75])# 处理序列def preprocess_nmt(text):    &quot;&quot;&quot;预处理“英语－法语”数据集&quot;&quot;&quot;    def no_space(char, prev_char):        return char in set(&#39;,.!?&#39;) and prev_char !&#x3D; &#39; &#39;    # 使用空格替换不间断空格    # 使用小写字母替换大写字母    text &#x3D; text.replace(&#39;\u202f&#39;, &#39; &#39;).replace(&#39;\xa0&#39;, &#39; &#39;).lower()    # 在单词和标点符号之间插入空格    out &#x3D; [&#39; &#39; + char if i &gt; 0 and no_space(char, text[i - 1]) else char           for i, char in enumerate(text)]    return &#39;&#39;.join(out)# 词元化，并区分出feature与labeldef tokenize_nmt(text, num_examples&#x3D;None):    &quot;&quot;&quot;词元化“英语－法语”数据数据集&quot;&quot;&quot;    source, target &#x3D; [], []    for i, line in enumerate(text.split(&#39;\n&#39;)):        if num_examples and i &gt; num_examples:            break        parts &#x3D; line.split(&#39;\t&#39;)        if len(parts) &#x3D;&#x3D; 2:            # 之前标点符号之间增加了空格，使用空格分割            source.append(parts[0].split(&#39; &#39;))            target.append(parts[1].split(&#39; &#39;))    return source, targetsource, target &#x3D; tokenize_nmt(text)# 阶段或填充词元def truncate_pad(line, num_steps, padding_token):    &quot;&quot;&quot;截断或填充文本序列&quot;&quot;&quot;    if len(line) &gt; num_steps:        return line[:num_steps]  # 截断    return line + [padding_token] * (num_steps - len(line))  # 填充truncate_pad(src_vocab[source[0]], 10, src_vocab[&#39;&lt;pad&gt;&#39;])# 统计序列数据valid_lendef build_array_nmt(lines, vocab, num_steps):    &quot;&quot;&quot;将机器翻译的文本序列转换成小批量&quot;&quot;&quot;    lines &#x3D; [vocab[l] for l in lines]    lines &#x3D; [l + [vocab[&#39;&lt;eos&gt;&#39;]] for l in lines]    array &#x3D; torch.tensor([truncate_pad(        l, num_steps, vocab[&#39;&lt;pad&gt;&#39;]) for l in lines])    valid_len &#x3D; (array !&#x3D; vocab[&#39;&lt;pad&gt;&#39;]).type(torch.int32).sum(1)    return array, valid_lendef load_data_nmt(batch_size, num_steps, num_examples&#x3D;600):    &quot;&quot;&quot;返回翻译数据集的迭代器和词表&quot;&quot;&quot;    text &#x3D; preprocess_nmt(read_data_nmt()) # 读取序列    source, target &#x3D; tokenize_nmt(text, num_examples)  # 词元化序列    src_vocab &#x3D; d2l.Vocab(source, min_freq&#x3D;2, # 建立词表                          reserved_tokens&#x3D;[&#39;&lt;pad&gt;&#39;, &#39;&lt;bos&gt;&#39;, &#39;&lt;eos&gt;&#39;])    tgt_vocab &#x3D; d2l.Vocab(target, min_freq&#x3D;2,                          reserved_tokens&#x3D;[&#39;&lt;pad&gt;&#39;, &#39;&lt;bos&gt;&#39;, &#39;&lt;eos&gt;&#39;])    src_array, src_valid_len &#x3D; build_array_nmt(source, src_vocab, num_steps)  # 填充或阶段    tgt_array, tgt_valid_len &#x3D; build_array_nmt(target, tgt_vocab, num_steps)    data_arrays &#x3D; (src_array, src_valid_len, tgt_array, tgt_valid_len)    data_iter &#x3D; d2l.load_array(data_arrays, batch_size)   # 创建小批量迭代器    return data_iter, src_vocab, tgt_vocab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端代码的联合使用</title>
      <link href="/2025/05/24/java/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/24/java/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="html-css-javascript">1. html+ css+ javascript</h1><h2 id="html">1.1. html</h2><h3 id="常用插件">1.1.1. 常用插件</h3><ol><li>HTML CSS Support</li><li>Live Server</li><li>Auto Rename Tag</li><li>open in browser</li></ol><h3 id="常用示例">1.1.2. 常用示例</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 这里放置文档的元信息 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>文档标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 连接外部样式表或脚本文件等 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>styles.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>script.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 这里放置页面内容 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>这是一个标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是一个段落。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://www.example.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是一个链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 其他内容 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 这里放置文档的元信息 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>文档标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 连接外部样式表或脚本文件等 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>styles.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>script.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 这里放置页面内容 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>这是一个标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是一个段落。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://www.example.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是一个链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 其他内容 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="css">1.2. css</h2><h3 id="规则">1.2.1. 规则</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">选择器</span> <span class="token punctuation">&#123;</span>    <span class="token property">属性1</span><span class="token punctuation">:</span> 属性值1<span class="token punctuation">;</span>    <span class="token property">属性2</span><span class="token punctuation">:</span> 属性值2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="导入方式">1.2.2. 导入方式</h3><ol><li>内联使用</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>这是一段内联样式文本。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>外部样式表</p><p>写在<head>中 </head></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">h2</span> <span class="token punctuation">&#123;</span>                       <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>                        <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>外部样式表</p><p>使用link连接外部资源，type为“text/css”，href指向样式内容</p></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./css/style.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="选择器">1.2.3. 选择器</h3><div class="table-container"><table><thead><tr><th>选择器</th><th>形式</th></tr></thead><tbody><tr><td>元素</td><td>p</td></tr><tr><td>类</td><td>.highlight</td></tr><tr><td>id</td><td>#header</td></tr><tr><td>通用选择</td><td>*</td></tr><tr><td>子元素</td><td>父元素&gt; 子元素</td></tr><tr><td>后代</td><td><code>ul li</code> 选择了所有在 <code>&lt;ul&gt;</code> 元素内部的 <code>&lt;li&gt;</code> 元素。</td></tr><tr><td>相邻兄弟</td><td><code>元素名 + 元素名</code>，例如，<code>h2 + p</code> 选择了与 <code>&lt;h2&gt;</code> 相邻的 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td>/<em> 通用兄弟选择器 </em>/</td><td>h4 ~ p {             background-color: #1b91ff;         }</td></tr><tr><td>伪类选择器</td><td>用户交互时的属性变化<br>包括鼠标悬停（<code>:hover</code> ）、链接状态（<code>:active</code>）、第一个子元素（<code>:first-child</code>）</td></tr></tbody></table></div><h3 id="属性">1.2.4. 属性</h3><p>了解了如何选中我们想要的元素，接下来，我们来学习 CSS 常用的样式属性。CSS 的属性有上百个，但是这不意味着，我们每个都要学习，更多的属性可以参考 <a href="https://www.runoob.com/cssref/css-reference.html">这里</a></p><h4 id="盒子模型">1.2.4.1. 盒子模型</h4><p>描述了文档中的每个元素都被看作是一个矩形的盒子，这个盒子包含了内容、内边距、边框和外边距。</p><p><img src="/2025/05/24/java/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8/202311141906963.png" alt="img"></p><p>其中，从内到外分别是：</p><div class="table-container"><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>内容（Content）</code></td><td style="text-align:center">盒子包含的实际内容，比如文本、图片等。</td></tr><tr><td style="text-align:center"><code>内边距（Padding）</code></td><td style="text-align:center">围绕在内容的内部，是内容与边框之间的空间。可以使用 <code>padding</code> 属性来设置。</td></tr><tr><td style="text-align:center"><code>边框（Border）</code></td><td style="text-align:center">围绕在内边距的外部，是盒子的边界。可以使用 <code>border</code> 属性来设置。</td></tr><tr><td style="text-align:center"><code>外边距（Margin）</code></td><td style="text-align:center">围绕在边框的外部，是盒子与其他元素之间的空间。可以使用 <code>margin</code> 属性来设置。</td></tr></tbody></table></div><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.demo</span> <span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span> <span class="token comment">/* 设置背景色 */</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span> <span class="token comment">/* 转换成行内块元素 */</span>            <span class="token property">border</span><span class="token punctuation">:</span> 10px solid green<span class="token punctuation">;</span> <span class="token comment">/* 设置边框样式 */</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span> <span class="token comment">/* 设置内边距 */</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 40px<span class="token punctuation">;</span> <span class="token comment">/* 设置外边距 */</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="浮动">1.2.4.2. 浮动</h4><p>标准流，浮动、定位</p><p>使用float控制浮动格式</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.left, .right</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 添加浮动，元素统一向左浮动，向右同理 float:right*/</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>清除浮动格式，在后续的模块中不再浮动，不允许后续模块浮动</p><ol><li>加上一个空的块级元素，使用clear属性</li></ol><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.clearfix::after</span> <span class="token punctuation">&#123;</span>            <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>            <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>父模块属性中使用clearfix</p></li><li><p>使用overflow: hidden 属性</p></li></ol><h4 id="定位">1.2.4.3. 定位</h4><p>相关属性：</p><p>top ,bottom , left ,right</p><p>postion属性值</p><div class="table-container"><table><thead><tr><th>position</th><th>value</th></tr></thead><tbody><tr><td>relative</td><td>相对于正常文档定位</td></tr><tr><td>absolute</td><td>相对最近的已经定位的祖先元素定位，没有，则相对初始包含块定位</td></tr><tr><td>fixed</td><td>固定位置</td></tr></tbody></table></div><h2 id="javascript">1.3. javascript</h2><h3 id="导入方式-1">1.3.1. 导入方式</h3><ol><li>内联方式（inline):</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>外部引入</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myscript.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="基本语法">1.3.2. 基本语法</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> x<span class="token punctuation">;</span> <span class="token comment">// 声明变量</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//声明并初始化变量</span><span class="token keyword">const</span> <span class="token constant">PI</span><span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">//声明一个常量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left"><code>var</code></th><th style="text-align:left"><code>let</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>作用域</strong></td><td style="text-align:left">函数作用域</td><td style="text-align:left">块级作用域</td></tr><tr><td style="text-align:left"><strong>变量提升</strong></td><td style="text-align:left">声明会被提升，赋值不提升</td><td style="text-align:left">存在提升，但有暂时性死区</td></tr><tr><td style="text-align:left"><strong>重复声明</strong></td><td style="text-align:left">允许在同作用域内重复声明</td><td style="text-align:left">不允许在同块级作用域内重复声明</td></tr></tbody></table></div><h4 id="函数">1.3.2.1. 函数</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">funtion <span class="token function">hello</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//闭包是指一个函数能够访问并记住其词法作用域，即使该函数在当前词法作用域之外执行。闭包使得函数可以保持对其创建时的作用域的引用</span><span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> outerVar <span class="token operator">=</span> <span class="token string">"I am outer"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outerVar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问了外部函数的变量</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> inner<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="关联html中的事件">1.3.2.2. 关联html中的事件</h4><div class="table-container"><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onClick</td><td>鼠标点击</td></tr><tr><td>onMouseOver</td><td>鼠标经过</td></tr><tr><td>onMouseOut</td><td>鼠标移出</td></tr><tr><td>onChange</td><td>文本内容改变</td></tr><tr><td>onSelect</td><td>文本框选中</td></tr><tr><td>onFocuse</td><td>光标聚集</td></tr><tr><td><code>onBlur</code></td><td>移开光标</td></tr><tr><td><code>onLoad</code></td><td>网页加载</td></tr><tr><td><code>onUnload</code></td><td>关闭网页</td></tr></tbody></table></div><p>事件处理程序是与特定事件相关联的函数。当事件发生时，关联的事件处理程序将被调用。在 HTML 中，可以通过以下方式添加事件处理程序：</p><ol><li><p>html</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bottom</span> <span class="token special-attr"><span class="token attr-name">onClick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">'</span><span class="token value javascript language-javascript"><span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">'</span></span></span><span class="token punctuation">></span></span> Click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bottom</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>DOM属性</p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> botton <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myButton'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>botton<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>addEventListener</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myButton'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Button clicked!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取元素，并修改内容">1.3.3. 获取元素，并修改内容</h3><p>DOM 中的一切都是节点。文档本身是一个文档节点，而文档中的元素、属性和文本都是不同类型的节点。主要的节点类型包括：</p><ol><li><code>元素节点（Element Nodes）</code>： 表示 HTML 或 XML 文档中的元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等。</li><li><code>属性节点（Attribute Nodes）</code>： 表示元素的属性，如 class、id 等。</li><li><code>文本节点（Text Nodes）</code>： 表示元素的文本内容</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 修改元素文本内容</span>element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'新的文本内容'</span><span class="token punctuation">;</span><span class="token comment">// 添加新的子元素</span><span class="token keyword">var</span> newElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>element<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newElement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 移除子元素</span><span class="token keyword">var</span> childElement <span class="token operator">=</span> element<span class="token punctuation">.</span>firstChild<span class="token punctuation">;</span>element<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>childElement<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="致谢">2. 致谢</h1><p>摘录自<a href="https://docs.geeksman.com/front-end/1.front-end-html.html#html">Luo</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="大模型">1. 大模型</h1><p>训练流程</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250516165010562.png" alt="image-20250516165010562"></p><h2 id="预训练">1.1. 预训练</h2><p>无监督学习，学习先验的背景知识</p><p>大模型的输出总的概率与原数据比较，不需要</p><script type="math/tex; mode=display">L(u) =\sum_{i}{\log(p(u_i| u_0,..., u_{i-1})|\theta)}</script><ol><li><p>数据获取</p><ol><li>网页爬取，数据没有处理</li><li>重复</li><li>拼写错误</li></ol></li><li><p>数据清洗</p><ol><li><p>转换文本格式</p></li><li><p>去重</p><ol><li>URL爬取的网站去重</li><li>文档的相似度</li><li>对文档分组30M， 超过6次重复， 删除其余5行</li><li>启发式过滤，使用token级的KL散度去重</li></ol><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250516172556394.png" alt="image-20250516172556394"></p><ol><li>数据打包<pre><code> 1. &lt;BOS&gt; &lt;EOS&gt; 2. 一行一行的训练，而不是一句一句的训练</code></pre></li><li>观测模型，使用测试集对中间模型测试</li><li>数据比例，代码模型中平衡代码补全（中间填充）与代码编写（从前向后编写）的任务，两种数据集都需要</li></ol></li></ol></li></ol><h3 id="继续预训练">1.1.1. 继续预训练</h3><p>当前的base model 对于专业领域的效果很差，继续与训练补全知识。</p><p>加入新的数据，调整学习率</p><ol><li>warmup 的步数不会影响最终的结果</li><li>学习率较大，下游任务更好</li><li>对原有模型继续warmup，效果更差</li></ol><p>使用梯形的学习率，保存拐点位置的学习率，继续预训练时候，使用拐点数据预训练，保持较高的搜索速度，拟合新增的数据集</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250516173720277.png" alt="image-20250516173720277"></p><h3 id="scaling-up">1.1.2. scaling up</h3><p>扩大模型的参数和容量</p><h3 id="尺度定律">1.1.3. 尺度定律</h3><p>模型的损失是可预测的，与模型的算力，大小，数据集有较大的关系</p><ol><li>模型的参数</li><li>数据的大小</li><li>算力</li></ol><p>模型与参数、大小、算力由直接的关系，不需要训练，就能知道最终的训练结果</p><h4 id="尺度定律-1">1.1.3.1. 尺度定律</h4><ol><li><p>模型与参数、大小、算力由直接的关系，与模型形状弱依赖</p><ol><li>某个网络的占比</li><li>隐层数量的占比</li><li>每个head的大小</li></ol><p>的影响很小，不需要对此调参</p></li><li><p>其他变量充足的时候，我们就知道模型最后的效果</p></li></ol><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250519222325535.png" alt="image-20250519222325535"></p><ol><li><p>过拟合的普遍性，一味增加其中一项，模型效果就会进入衰退阶段</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250519223024436.png" alt="image-20250519223024436"></p></li><li><p>同等算力下，调整模型大小和数据集的大小</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250519223337327.png" alt="image-20250519223337327"></p></li><li><p>模型在训练集与测试集上表现高度相关</p></li><li><p>训练数据有显示，仍然可以重复使用数据进行训练得到可预测的“尺度定律”</p></li><li><p>其他模型（包括transform)都具有尺度定律</p></li></ol><h4 id="利用尺度定律">1.1.3.2. 利用尺度定律</h4><ol><li><p>固定模型的大小，更改预训练的数据量</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250519224015225.png" alt="image-20250519224015225"></p></li><li><p>规定算力大小，训练不同大小的模型，（训练到模型收敛较难，可以得到算力的大小）</p></li></ol><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250519224308944.png" alt="image-20250519224308944"></p><h3 id="涌现">1.1.4. 涌现</h3><p>大模型在训练数量的规模时，准确率会发生突变</p><h2 id="后训练">1.2. 后训练</h2><p>对齐人类的要求，回答问题有用、无害</p><h3 id="指令微调">1.2.1. 指令微调</h3><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250519225029335.png" alt="image-20250519225029335"></p><ol><li><p>上下文学习</p><ol><li>用户给出例子，模型不更新参数直接学习</li></ol><p>使用例子训练，模型直接输出</p></li><li><p>预训练-微调</p><ol><li>在目标任务上进行微调</li></ol><p>给出命令前缀，然后训练</p></li><li><p>指令微调</p><ol><li>在非目标任务上进行泛化，在任务上泛化很好</li></ol></li></ol><p>指令-回答， 对回答的预测计算损失函数</p><h3 id="数据合成">1.2.2. 数据合成</h3><ol><li>人工构建任务例子</li><li>使用强模型根据种子任务生成指令</li><li>将生成的指令再给另一个强模型，获得指令的回答，得到&lt;指令，回答&gt; 对</li></ol><h3 id="test-scaling">1.2.3. test scaling</h3><p>模型输出多个结果，打分选择结果</p><p>过程奖励模型&gt;结果奖励模型</p><p>选择框架</p><p>   <img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250523163748097.png" alt="image-20250523163748097"></p><h3 id="微调方法">1.2.4. 微调方法</h3><h4 id="lora">1.2.4.1. lora</h4><p>增加低秩矩阵</p><h4 id="前缀调整">1.2.4.2. 前缀调整</h4><p>训练的模型权重不再调整，k,v前分别添加可训练的连续前缀向量</p><p>冻结原权重，增加可训练模块</p><h4 id="提示调整">1.2.4.3. 提示调整</h4><p>训练文本前增加提示命令</p><h4 id="adapter">1.2.4.4. adapter</h4><p>在前馈神经网络前增加低秩矩阵</p><h4 id="LoRAMoE">1.2.4.5. LoRAMoE</h4><p>微调插入专家模型中的LoRA适配器</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250523200928848.png" alt="image-20250523200928848"></p><h2 id="强化学习">1.3. 强化学习</h2><p>最大化智能体获得的期望累计奖励</p><h3 id="PPO函数">1.3.1. PPO函数</h3><p>策略： 大模型生成句子的过程$\pi$</p><p>轨迹： 一系列的动作，大模型生成句子时候，的状态与动作</p><script type="math/tex; mode=display">\tau  = s_1, a_1, ..s_n, a_n</script><p>奖励：$R(\tau)$，一整条轨迹的奖励</p><p>基于策略的强化学习的目标：找到一种策略，是在这个策略的轨迹上的奖励分数最大</p><script type="math/tex; mode=display">\begin{align}\underset{\pi_\theta}{argmax} j({\pi_\theta}) &= \underset{\pi_\theta}{argmax}E_{\tau~\pi}|R(\tau)|\\& = \sum_\tau R(\tau)P(\tau|\pi_\theta)\end{align}</script><p>LOSS函数的梯度：</p><script type="math/tex; mode=display">\begin{align*}\nabla J(\pi_\theta) &= \sum_\tau R(\tau) \nabla P(\tau|\pi_\theta) \\&= \sum_\tau R(\tau) P(\tau|\pi_\theta) \frac{\nabla P(\tau|\pi_\theta)}{P(\tau|\pi_\theta)} \\&= \sum_\tau R(\tau) P(\tau|\pi_\theta) \nabla \log(P(\tau|\pi_\theta)) \\&= \mathbb{E}_{\tau \sim \pi_\theta} [R(\tau) \nabla \log(P(\tau|\pi_\theta))]\end{align*}</script><p>路径的概率，从$s_0$递推，推到T-1,计算出T的概率</p><script type="math/tex; mode=display">P(\tau|\pi_\theta) = \rho_0(s_0) \prod_{t=0}^{T-1} P(s_{t+1}|s_t, a_t)\pi_\theta(a_t|s_t)</script><script type="math/tex; mode=display">\nabla \log\left(P(\tau|\pi_\theta)\right) = \nabla \left[ \log \rho_0(s_0) + \sum_{t=0}^{T-1} \log P(s_{t+1}|s_t, a_t) + \sum_{t=0}^{T-1} \log \pi_\theta(a_t|s_t) \right]</script><p>前两项和策略模型的参数 $\theta$ 无关，可舍去。于是 </p><script type="math/tex; mode=display">\nabla \log\left(P(\tau|\pi_\theta)\right) = \sum_{t=0}^{T-1} \nabla \log \pi_\theta(a_t|s_t)</script><p>带入Loss的梯度中，使用每时刻的奖励函数代替总路径$R(\tau)$</p><script type="math/tex; mode=display">\nabla J(\pi_\theta) = \mathbb{E}_{\tau \sim \pi_\theta}\left[ \sum_{t=0}^{T-1} \Psi_t \nabla \log \pi_\theta(a_t|s_t) \right]</script><p>$\psi_t$的组成形式</p><ol><li>$\sum_{t=0}^\infty r_t$                        轨迹的累积奖励   </li><li>$\sum_{t’=t}^\infty \gamma^{t’-t} r_{t’}$                        轨迹的折扣奖励   </li><li>$\sum_{t’=t}^\infty \gamma^{t’-t} r_{t’} - b(s_t)$                        引入基线    </li><li>$Q^\pi(s_t, a_t)$                        动作价值函数   </li><li>$A^\pi(s_t, a_t)$                        优势函数   </li><li>$r_t + V^\pi(s_{t+1}) - V^\pi(s_t)$                        时序差分残差</li></ol><p>累计折扣奖励</p><script type="math/tex; mode=display">G_t = r_t + \gamma r_{t+1} + \gamma^2 r_{t+2} + \dots + \gamma^{T-t-1} r_{T-1} = r_t + \gamma G_{t+1}</script><p>动作价值函数：在策略<em>π</em> 下，从状态 <em>s_t</em> 开始并执行动作 <em>a_t</em> 后，未来所有折扣奖励的<strong>期望</strong>。</p><script type="math/tex; mode=display">\begin{align}Q_\pi(s_t, a_t) &= \mathbb{E}_\pi[G_t | s_t, a_t] \\&= \mathbb{E}_\pi\left[\sum_{t=0}^{T-t} \gamma^{t'} r_{t'} | s_t, a_t\right] \\&= \mathbb{E}_\pi[r_t | s_t, a_t] + \mathbb{E}_\pi[\gamma V_\pi(S_{t+1}) | s_t, a_t] \\&= \sum_{s_{t+1} \in \mathcal{S}} P(s_{t+1}|s_t, a_t)R(s_t, a_t, s_{t+1}) + \gamma \sum_{s_{t+1} \in \mathcal{S}} P(s_{t+1}|s_t, a_t)V_\pi(s_{t+1})  \\& 贝尔曼期望方程，将 G_t 拆分为当前奖励和未来价值\\&= \mathbb{E}_{s_{t+1} \sim P(\cdot|s_t, a_t)}[r + \gamma V_\pi(s_{t+1})]\end{align}</script><p>优势函数:在策略 π<em>π</em> 下，在状态 <em>s_t</em> 执行动作 <em>a_t</em> 相对于在该状态下平均（期望）价值的“优势”或“额外价值”。</p><script type="math/tex; mode=display">\begin{align}A_\pi(s_t, a_t) &= Q_\pi(s_t, a_t) - V_\pi(s_t) \\&= \mathbb{E}_{s_{t+1} \sim P(\cdot|s_t, a_t)}[r_t + \gamma V_\pi(s_{t+1})] - \mathbb{E}_{s_{t+1} \sim P(\cdot|s_t, a_t)}[V_\pi(s_t)] \\&= \mathbb{E}_{s_{t+1} \sim P(\cdot|s_t, a_t)}[r_t + \gamma V_\pi(s_{t+1}) - V_\pi(s_t)] \\&= \mathbb{E}_{s_{t+1} \sim P(\cdot|s_t, a_t)}[\text{TD\_error}]\end{align}</script><h3 id="价值损失">1.3.2. 价值损失</h3><p>这里提到的“价值训练过程”通常指的是在强化学习中，<strong>价值函数（Value Function）的估计和更新过程</strong>。这通常通过训练一个神经网络（价值网络/Critic网络）来预测状态的价值 V(s)<em>V</em>(<em>s</em>) 或状态-动作对的价值 Q(s,a)<em>Q</em>(<em>s</em>,<em>a</em>)。最常见的训练方法是使用<strong>均方误差（Mean Squared Error, MSE）损失</strong></p><p>价值函数 V<strong>ϕ<em>(</em>s</strong>t<em>) 的目标是准确估计<strong>未来累积折扣奖励</strong>。因此，训练它的方法就是让它的预测值 </em>V<strong>ϕ<em>(</em>s</strong>t*) 尽可能接近“真实”的累积折扣奖励 R_t。</p><p>价值损失采用的是MSE损失，最小化如下目标函数： </p><script type="math/tex; mode=display">\mathcal{L}_{\text{critic}}(\phi) = \mathbb{E}_{t}\left[\left(V_\phi(s_t) - R_t\right)^2\right]</script><p>其中$V_\phi(s_t)$为价值模型预测出来的回报，$R_t$为实际得到的回报。</p><p>$R_t$ 是理论标签值，需要计算出来</p><p>如果使用时序差分目标，则 </p><script type="math/tex; mode=display">R_t = r_t + \gamma V_\phi(s_{t+1})</script><p>如果使用GAE目标，则 <script type="math/tex">R_t = \hat{A}^{\text{GAE}}_t + V'_\phi(s_t)</script> </p><h3 id="RLHF">1.3.3. RLHF</h3><h4 id="构建奖励模型">1.3.3.1. 构建奖励模型</h4><ol><li><p>收集偏好数据，对模型回答的多个数据，评估排序，不是打分</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530121011621.png" alt="image-20250530121011621"></p></li><li><p>损失函数，max(做好回答- 最差回答)</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530121104796.png" alt="image-20250530121104796"></p></li><li><p>只获取最后一个token的评估</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530121333003.png" alt="image-20250530121333003"></p></li><li><p>使用KL散度，避免与模型的差距较大</p></li><li><p>使用PPO函数，计算历史和未来的奖励</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530121812769.png" alt="image-20250530121812769"></p></li></ol><h4 id="总体流程">1.3.3.2. 总体流程</h4><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530121856320.png" alt="image-20250530121856320"></p><p><strong>RLHF实开源链接</strong>：</p><ol><li><code>https://github.com/huggingface/trl</code></li><li><code>https://github.com/OpenRLHF/OpenRLHF</code></li><li><code>https://github.com/hiyouga/LLaMA-Factory</code></li><li><code>https://github.com/WangRongsheng/awesome-LLM-resourses</code></li></ol><h3 id="RLAIF">1.3.4. RLAIF</h3><p>模型选择结果，替换人类标记，同时需要使用双重判断</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530170449430.png" alt="image-20250530170449430"></p><ol><li>D-RLAIF，模型直接打分，不再训练</li><li>常规RLAIF，先训练奖励模型</li></ol><h3 id="DPO算法-direct-perference-option">1.3.5. DPO算法(direct perference option)</h3><p>由偏好学习的数据，直接用于模型的训练</p><p>目标：</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530171548497.png" alt="image-20250530171548497"></p><p>损失函数：</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530171648715.png" alt="image-20250530171648715"></p><h3 id="SPLN（self-play">1.3.6. SPLN（self play)</h3><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530173051126.png" alt="image-20250530173051126"></p><h4 id="main-play">1.3.6.1. main play</h4><p>区分某个回答是人类的回答</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530173622192.png" alt="最大化人类回答与机器回答的区别"></p><h4 id="opponent-play">1.3.6.2. opponent play</h4><p>不需要区分人类回答和LLM回答</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530173750170.png" alt="image-20250530173750170"></p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530173801712.png" alt="image-20250530173801712"></p><p>得到优化目标</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530173906352.png" alt="image-20250530173906352"></p><p>最大化生成与真实标注的信息与自己生成信息的差距</p><h3 id="self-rewarding">1.3.7. self-rewarding</h3><p>模型给自己提供奖励，在优化回复的功能是，优化模型指令遵循与打分的能力</p><ol><li>初始模型，具有基础能力</li><li>种子数据集，少量数据集，<ol><li>指令微调，只有回答</li><li>评估微调，回答排序</li></ol></li></ol><p>模型使用种子数据集，生成新的prompt，模型自己打分，取最高分与最低分，加入数据集，用于DPO训练。</p><p>不断迭代</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530175457392.png" alt="image-20250530175457392"></p><h2 id="微调">1.4. 微调</h2><ol><li>增加参数微调</li></ol><ol><li>软提示微调： 在embeding之前怎么增加soft prompt，训练优化增加的soft prompt ，模型的参数固定<ol><li>且不同的任务可以使用不同的soft prompt</li></ol></li><li>适配器微调： 在模型前后增加一个层</li></ol><ol><li><p>选择性微调</p><ol><li>学习优化哪些参数，优化任务结果，使用正则化，惩罚修改较多的参数<img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530182117984.png" alt="image-20250530182117984"></li><li>指定修改部分参数</li></ol></li><li><p>重参数微调，调整子空间参数</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530182340311.png" alt="image-20250530182340311"></p><ol><li><p>Low-Rank Adaption(LoRA)，优化两个低秩矩阵，与原矩阵组合</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530182623192.png" alt="image-20250530182623192"></p></li><li><p>学习模型的缩放因子</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250530183050936.png" alt="image-20250530183050936"></p></li></ol></li></ol><h2 id="知识蒸馏">1.5. 知识蒸馏</h2><p>教师模型将知识提取出来，学生模型学习其中内容</p><h3 id="基于特征的知识">1.5.1. 基于特征的知识</h3><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/image-20250523201806237.png" alt="image-20250523201806237"></p><h4 id="多个教师教学">1.5.1.1. 多个教师教学</h4><h3 id="基于关系的知识">1.5.2. 基于关系的知识</h3><h2 id="模型剪枝">1.6. 模型剪枝</h2><p>删除权重小于一定阈值的连接或神经元节点，获得更加稀疏的矩阵</p><h3 id="结构化剪枝">1.6.1. 结构化剪枝</h3><p>参数从起点到重点，图中有相连，则保留</p><h1 id="简短">2. 简短</h1><h2 id="预训练-1">2.1. 预训练</h2><h3 id="词表化">2.1.1. 词表化</h3><h4 id="BBPE-byte-level-BPE">2.1.1.1. BBPE(byte-level BPE)</h4><p>单词量过大时，每一个单词一个token使用，词表空间较大</p><p>单词使用字节标识，采用unicode 编码作为最小颗粒度，将单词切割为字节token</p><p>例如，对于不存在的字节“待”，使用3个字节标识(中文在unicode编码中使用三个字节表示)</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/v2-4cd433a354233d03bc2aad15745a7285_1440w.jpg" alt="img"></p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/v2-66a59222fb083b240eac861eb026c73c_r.jpg" alt="img"></p><h3 id="模型预训练">2.1.2. 模型预训练</h3><p>采用无监督学习，学习输入文本的特征，学习语言语法</p><p>输入一堆文本，让模型做 Next Token Prediction 的任务，学习基础语法，初步学习。</p><p>类似与transfomer论文中的对语言的输入学习输出。</p><h2 id="指令微调-1">2.2. 指令微调</h2><p>GPT-3只能完成续写任务,InstructGPT可以根据指令回答问题</p><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/v2-a7a8e7aed0750d189f792b19e8272dfe_r.jpg" alt="img"></p><h3 id="监督学习">2.2.1. 监督学习</h3><p>给出指令问题，并给出答案，监督模型学习</p><ol><li><p>指令: 在面试中如何回答这个问题？</p><ol><li>输入:当你在车里独处时，你会想些什么？</li><li>输出:如果是在晚上，我通常会考虑我今天所取得的进步，如果是在早上，我会思考如何做到最好。我也会尝试练习感恩和活在当下的状态，以避免分心驾驶。</li></ol></li><li><p>指令: 按人口对这些国家进行排名。</p><ol><li>输入:巴西，中国，美国，日本，加拿大，澳大利亚</li><li>输出:中国，美国，巴西，日本，加拿大，澳大利亚</li></ol></li></ol><p>模型学习指令回答方式，准确的响应问题</p><h2 id="奖励模型">2.3. 奖励模型</h2><p>之前，模型只是简单学习了语言学习的内容，但是并不知到语言中是否正确，或者错误，这将导致预训练模型中原先「错误」或「有害」的知识没能在 SFT 数据中被纠正。</p><h3 id="利用偏序对训练奖励模型">2.3.1. 利用偏序对训练奖励模型</h3><p><img src="/2025/05/24/python/deeplearn/%E5%A4%A7%E6%A8%A1%E5%9E%8B/v2-29f8de16d921303fc6ee5c338fc68800_1440w.jpg" alt="img"></p><p>偏序对是指：不直接为每一个样本直接打分，而是标注这些样本的好坏顺序，标准A比B好多少，而不是具体的分数。</p><blockquote><p>直接打分：A句子（5分），B句子（3分）<br>偏序对标注：A &gt; B</p></blockquote><p>模型通过尝试最大化「好句子得分和坏句子得分之间的分差」，从而学会自动给每一个句子判分。</p><h2 id="强化学习（Reinforcement-Learning，PPO）">2.4. 强化学习（Reinforcement Learning，PPO）</h2><p>进行Reward model之后，需要使用RM进化模型</p><ol><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编码器 - 解码器</title>
      <link href="/2025/05/24/python/deeplearn/%E7%BC%96%E7%A0%81%E5%99%A8%20-%20%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
      <url>/2025/05/24/python/deeplearn/%E7%BC%96%E7%A0%81%E5%99%A8%20-%20%E8%A7%A3%E7%A0%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="编码器-解码器">1. 编码器 - 解码器</h1><h2 id="基本框架">1.1. 基本框架</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Encoder(nn.Module):    def __init__(self, **kwargs):        super(Encoder, self).__init__(**kwargs)    def forward(self, X, *args):        raise NotImplementedError  # 占位符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Decoder(nn.Module):    def __init__(self, **kwargs):        super(Decoder, self).__init__(**kwargs)        def init_state(self, enc_outputs, *args):        raise NotImplementedError    def forward(self, X, *args):        raise NotImplementedError  # 占位符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">class EncoderDecoder(nn.Module):    &quot;&quot;&quot;编码器-解码器架构的基类&quot;&quot;&quot;    def __init__(self, encoder, decoder, **kwargs):        super(EncoderDecoder, self).__init__(**kwargs)        self.encoder &#x3D; encoder        self.decoder &#x3D; decoder    def forward(self, enc_X, dec_X, *args):        enc_outputs &#x3D; self.encoder(enc_X, *args)        # 编码器的输出最为解码器输入的一部分        dec_state &#x3D; self.decoder.init_state(enc_outputs, *args)        return self.decoder(dec_X, dec_state)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="seq2seq">1.2. seq2seq</h2><p><img src="/2025/05/24/python/deeplearn/%E7%BC%96%E7%A0%81%E5%99%A8%20-%20%E8%A7%A3%E7%A0%81%E5%99%A8/image-20250424214252355.png" alt="image-20250424214252355"></p><h3 id="编码器">1.2.1. 编码器</h3><ol><li>将序列(时间步)的数字转换为张量</li><li>通过rnn输出上下文变量C，隐状态</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Seq2SeqEncoder(nn.Encoder):def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, dropout &#x3D; 0, **kwargs):        super(Seq2SeqEncoder, self).__init__(**kwargs)       &#39;&#39;&#39;编码层       将数字编码为为向量       输入(batch_size, feature) 输出(batch_size, feature, embed_size)       &#39;&#39;&#39;        self.embeding &#x3D; nn.Embedding(vocab_size, embed_size)        self.rnn &#x3D; nn.gru(embed_size, nn_hiddens, num_layers, dropout &#x3D; dropout)    def forward(self, X, *args):        # 输出&#39;X&#39;的形状：(batch_size,num_steps,embed_size)        X &#x3D; self.embedding(X)        # 在循环神经网络模型中，第一个轴对应于时间步        X &#x3D; X.permute(1, 0, 2)        # 如果未提及状态，则默认为0        output, state &#x3D; self.rnn(X)        # output的形状:(num_steps,batch_size,num_hiddens)        # state的形状:(num_layers,batch_size,num_hiddens)        return output, state<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解码器">1.2.2. 解码器</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Seq2SeqDecoder(nn.Decoder):    def __init__(self, vocab_size, embed_size, num_hiddens, num_layers,                 dropout&#x3D;0, **kwargs):        super(Seq2SeqDecoder, self).__init__(**kwargs)        self.embedding &#x3D; nn.Embedding(vocab_size, embed_size)        self.rnn &#x3D; nn.GRU(embed_size + num_hiddens, num_hiddens, num_layers,                          dropout&#x3D;dropout)        self.dense &#x3D; nn.Linear(num_hiddens, vocab_size)   def init_state(self, enc_outputs, *args):    # 用隐状态来初始化上下文变量    return enc_outputs[1]        def forward(self, X, state):        X &#x3D; self.embedding(X).permute(1, 0,2 )                # state[-1] 的维度为(layer_num , batch_size, num_hiddens)        context &#x3D; state[-1].repeat(X.shape[0], 1, 1)        # 在feature上增加了元素C        X_and_c &#x3D; torch.cat(X, context, 2)        output, state &#x3D; self.rnn(X_and_context, state)        output &#x3D; self.dense(output).permute(1, 0, 2)        return output , state        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="训练过程">1.2.3. 训练过程</h3><p>不同点：</p><ol><li>定义使用MarkedSoftmaxCELoss 损失函数</li><li>塑造解码器输入，原序列前增加bos, 删除eos</li></ol><p>相同点：</p><ol><li>apply(init(m)), optimizer , loss,  net.train()</li><li>分epoch, 分批量，optimizer.zero_gred(),  net(x) , l = loss(y_hat, Y), l.backward(),  grad_clipping(net, theta), optimizer.step()</li></ol><h3 id="预测过程">1.2.4. 预测过程</h3><ol><li><p>net.eval()</p></li><li><p>准备序列数据</p></li><li><p>对src编码，得到dec_state=context</p></li><li><p>传入一个<bos>数据</bos></p></li><li><p>dec_X 的维度为(1, 1)</p><p>​    Y 的维度为(1, 1, embed_size)</p><p>​    每一次更新dec_X, 更新了decodor的隐藏状态</p></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">def predict_seq2seq(net, src_sentence, src_vocab, tgt_vocab, num_steps,                   device, save_attention_weights&#x3D;False):   &quot;&quot;&quot;序列到序列模型的预测&quot;&quot;&quot;   # 在预测时将net设置为评估模式   net.eval()   &#39;&#39;&#39;   准备序列数据   &#39;&#39;&#39;   src_tokens &#x3D; src_vocab[src_sentence.lower().split(&#39; &#39;)] + [       src_vocab[&#39;&lt;eos&gt;&#39;]]   enc_valid_len &#x3D; torch.tensor([len(src_tokens)], device&#x3D;device)   src_tokens &#x3D; d2l.truncate_pad(src_tokens, num_steps, src_vocab[&#39;&lt;pad&gt;&#39;])   # 添加批量轴   enc_X &#x3D; torch.unsqueeze(       torch.tensor(src_tokens, dtype&#x3D;torch.long, device&#x3D;device), dim&#x3D;0)   &#39;&#39;&#39;   对src编码，得到dec_state&#x3D;context   &#39;&#39;&#39;   enc_outputs &#x3D; net.encoder(enc_X, enc_valid_len)   dec_state &#x3D; net.decoder.init_state(enc_outputs, enc_valid_len)   &#39;&#39;&#39;    传入一个&lt;bos&gt;数据   &#39;&#39;&#39;   dec_X &#x3D; torch.unsqueeze(torch.tensor(       [tgt_vocab[&#39;&lt;bos&gt;&#39;]], dtype&#x3D;torch.long, device&#x3D;device), dim&#x3D;0)   output_seq, attention_weight_seq &#x3D; [], []   for _ in range(num_steps):       &#39;&#39;&#39;        dec_X 的维度为(1, 1), 每一次传入上一个时间步中预测出的值       Y 的维度为(1, 1, embed_size)       每一次更新dec_X, 更新了decodor的隐藏状态       &#39;&#39;&#39;       Y, dec_state &#x3D; net.decoder(dec_X, dec_state)       # 我们使用具有预测最高可能性的词元，作为解码器在下一时间步的输入       dec_X &#x3D; Y.argmax(dim&#x3D;2)       pred &#x3D; dec_X.squeeze(dim&#x3D;0).type(torch.int32).item()       # 保存注意力权重（稍后讨论）       if save_attention_weights:           attention_weight_seq.append(net.decoder.attention_weights)       # 一旦序列结束词元被预测，输出序列的生成就完成了       if pred &#x3D;&#x3D; tgt_vocab[&#39;&lt;eos&gt;&#39;]:           break       output_seq.append(pred)   return &#39; &#39;.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   <strong>这里可以优化使用束搜索</strong></p><h3 id="损失函数">1.2.5. 损失函数</h3><ol><li><p>计算pred与label的Loss</p></li><li><p>计算序列的掩码</p></li><li><p>将loss与序列掩码相乘</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MaskedSoftmaxCELoss(nn.CrossEntropyLoss):    &quot;&quot;&quot;带遮蔽的softmax交叉熵损失函数&quot;&quot;&quot;    # pred的形状：(batch_size,num_steps,vocab_size)    # label的形状：(batch_size,num_steps)    # valid_len的形状：(batch_size,)    def forward(self, pred, label, valid_len):        weights &#x3D; torch.ones_like(label)        weights &#x3D; sequence_mask(weights, valid_len)  # 掩码        self.reduction&#x3D;&#39;none&#39;        unweighted_loss &#x3D; super(MaskedSoftmaxCELoss, self).forward(            pred.permute(0, 2, 1), label)        weighted_loss &#x3D; (unweighted_loss * weights).mean(dim&#x3D;1)        return weighted_loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="掩码">1.2.5.1. 掩码</h4><ol><li>生成序列掩码，可以使用arrange&lt; valid_len获取</li><li>将所有掩码位置 置为0</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sequence_mask(X, valid_len, value&#x3D;0):    &quot;&quot;&quot;在序列中屏蔽不相关的项&quot;&quot;&quot;    maxlen &#x3D; X.size(1)    # 生成掩码    print(torch.arange((maxlen), dtype&#x3D;torch.float32,                        device&#x3D;X.device)[None, :] )    print(valid_len[:,None])    &#39;&#39;&#39;    (none,:)是在dim &#x3D; 0上创建一个&#x3D;1 的维度    广播机制后mask &#x3D; (batch_size, time_stem)    &#39;&#39;&#39;    mask &#x3D; torch.arange((maxlen), dtype&#x3D;torch.float32,                        device&#x3D;X.device)[None, :] &lt; valid_len[:, None]    print(mask)    X[~mask] &#x3D; value    return X<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="预测序列评估">1.2.5.2. 预测序列评估</h4><p>我们将BLEU定义为：</p><script type="math/tex; mode=display">\exp\left(\min\left(0, 1 - \frac{\mathrm{len}_{\text{label}}}{\mathrm{len}_{\text{pred}}}\right)\right) \prod_{n=1}^k p_n^{1/2^n},</script><h1 id="注意力机制">2. 注意力机制</h1><p>查询值query, 键值对（key, value)，每一个key 对应一个query</p><p>注意力权重计算的是query对key的关注程度，attention(query_num , key_num)，每一行是当前查询对所有键的注意力，然后与query计算，得到每一个查询对query的注意力结果</p><script type="math/tex; mode=display">attention_weight = \alpha(query, key)\\f(x) = attention_weight * query</script><h2 id="常见机制">2.1. 常见机制</h2><h3 id="掩蔽注意力机制操作">2.1.1. 掩蔽注意力机制操作</h3><p>对键值中不需要的部分掩蔽为0，具体操作是</p><ol><li>将atterntion_weight(batch, query, key) 中的key维度数据通过掩码，转换为较小数</li><li>使用softMax，较小数转换为0，key对应此处的权重就是0了</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">def masked_softmax(X, valid_len):    &#39;&#39;&#39;    X：attention_weigth &#x3D; (batch_size, query , key)    valid_len 不同批次掩蔽的长度，&#x3D;（batch_size) 或 (batch_size, key)    &#39;&#39;&#39;    if valid_lens is None:        return nn.functional.softmax(X, dim&#x3D;-1)    else:        shape &#x3D; X.shape        if valid_lens.dim() &#x3D;&#x3D; 1:            valid_lens &#x3D; torch.repeat_interleave(valid_len, shape[1])        else:            valid_lens &#x3D; valid_lens.reshape(-1)        &#39;&#39;&#39;        sequence_mash: 将param1中的第1维度按照 valid_lens的长度掩蔽，大于的掩蔽为values        &#39;&#39;&#39;        X &#x3D; sequence_mask(X.reshape(-1, shape[-1]), valid_lens,values&#x3D;&#x3D; -1e6)        return nn.functional.softmax(X.shape[shape], dim &#x3D;-1) # 对掩蔽维度归一化      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加性注意力">2.1.2. 加性注意力</h3><p>键，查询有时是矢量<strong>（不同长度）</strong>转换为相同长度的矢量</p><script type="math/tex; mode=display">a(\mathbf q, \mathbf k) = \mathbf w_v^\top \text{tanh}(\mathbf W_q\mathbf q + \mathbf W_k \mathbf k) \in \mathbb{R}</script><ol><li>线性层操作，query=&gt;(batch ,query, hidden_num),key=&gt;(batch ,key hidden_num)</li><li>得到注意力矩阵，query=&gt;(batch ,query,1 hidden_num)，key=&gt;(batch ,1，key hidden_num)， query+key =&gt;query=&gt;(batch ,query,key, hidden_num)</li><li>$W_t$ 是线性层(hidden_num, 1)， 移除最后一个维度，得到attention_weight =(batch ,query,key,)</li><li>使用掩蔽注意力，对key上无用的权重屏蔽</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class AddictiveAttention(nn.Module):    def __init__(self, key_size, query_size, num_hiddens, dropout, **kwargs):        super(AddictiveAttention, self).__init__(**kwargs)        self.W_k&#x3D; nn.Linear(key_size, num_hiddens)        self.W_q &#x3D; nn.Linear(query_size, num_hiddens)        self.W_v &#x3D; nn.Linear(num_hiddens, 1)        self.dropout&#x3D; nn.Dropout(dropout)            def forward(selk, query, key ,values, valid_lens):        query, key &#x3D; W_q(query), W_k(key)                attention &#x3D; query.unsquence(2) + key.unsquence(1)        attention &#x3D; nn.tanh(attention)        attention &#x3D; W_v(attention)                self.atterntion_weight &#x3D; masked_softmax(attention, valid_lens)        return torch.bmm(self.attention_weight, values)        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点积注意力">2.1.3. 点积注意力</h3><p>计算效率高，但是要求query, key具有相同的张量长度，权重函数：</p><script type="math/tex; mode=display">a(\mathbf q, \mathbf k) = \mathbf{q}^\top \mathbf{k}  /\sqrt{d}</script><p>方差缩放，防止梯度消失</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class DotProductAttention(nn.Module):    def __init__(self, dropout, **kwargs):        super(DotProductAttention, self).__init__(**kwargs)        self.dropout &#x3D; nn.Dropout(dropout)           def forward(self, query, key,values, valid_lens):    # attention(batch_size, query_size, key_size)        attention &#x3D; torch.bmm(query, key.transpose(1,2))&#x2F; math.sqrt(d)        self.attention_weight &#x3D; masked_softmax(attention, valid_len)        # 输出(batch_size, query_size, feature_size)        return torch.bmm(self.dropout(self.attention_weight), values)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多头注意力">2.1.4. 多头注意力</h3><p>使用多个结构一样，参数不一样的注意力去学习不同的知识</p><p><img src="/2025/05/24/python/deeplearn/%E7%BC%96%E7%A0%81%E5%99%A8%20-%20%E8%A7%A3%E7%A0%81%E5%99%A8/image-20250516113430112.png" alt="image-20250516113430112"></p><p>将键值对分为多个子空间，每个注意力机制学习一个子空间的特征，得到H组的注意力权重，然后将注意力权重通过线性层汇聚</p><p><img src="/2025/05/24/python/deeplearn/%E7%BC%96%E7%A0%81%E5%99%A8%20-%20%E8%A7%A3%E7%A0%81%E5%99%A8/image-20250425155705305.png" alt="image-20250425155705305"></p><p>常规思路：</p><ol><li>将query, key, values映射到子空间，使用不同的Linear映射</li><li>将不同头的注意力结果合并在一起，在feature维度上合并</li><li>再通过一个Linear线性层，连接所有head</li></ol><p>并行思路</p><ol><li>将query,key, values映射到完整空间，然后将完整空间查分成子空间，head与batch组成一个伪batch</li><li>再将子空间的数据通过点积注意力</li><li>将head从batch中分离出来，与feature合并，效果与非并行情况相同</li><li>最后通过线性层</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MultiHeadAttention(nn.Module):    def __init__(self, key_size, query_size, value_size, num_hiddens, num_head, dropout, bias &#x3D; false, **kwargs):       self.num_head &#x3D; head        self.attention &#x3D; d2l.DotProductAttention(dropout)        self.W_k &#x3D; nn.Linear(key_size, num_hiddens)        self.W_q &#x3D; nn.Linear(query_size, num_hiddens)        self.W_v &#x3D; nn.Linear(value_size, num_hiddens)        self.W_o &#x3D; nn.Linear(num_hiddens, num_hiddens) # 全连接层            def forward(self, query ,key ,values, valid_lens):               # 转换为(batch_size* head, key&#x2F;query , num_hidden&#x2F;head)        query &#x3D; transpose(self.W_q(query),  self.head_num)        keys &#x3D; transpose_qkv(self.W_k(keys), self.num_heads)        values &#x3D; transpose_qkv(self.W_v(values), self.num_heads)                # 将掩码扩展为batch*head        if valid_len is not None:            valid_lens &#x3D; torch.repeat_interleave(            valid_lens, repeats &#x3D; self.num_heads , dim &#x3D;0)                    output &#x3D; self.attention(query, key ,value, valid_len)                output_concat&#x3D;transpose_output(output, self.num_heads)        return self.W_o(output_concat)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="附录">3. 附录</h1><h2 id="BLEU">3.1. BLEU</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def bleu(pred_seq, label_seq, k):  #@save    &quot;&quot;&quot;计算BLEU&quot;&quot;&quot;    pred_tokens, label_tokens &#x3D; pred_seq.split(&#39; &#39;), label_seq.split(&#39; &#39;)    len_pred, len_label &#x3D; len(pred_tokens), len(label_tokens)    score &#x3D; math.exp(min(0, 1 - len_label &#x2F; len_pred))    for n in range(1, k + 1):        num_matches, label_subs &#x3D; 0, collections.defaultdict(int)        for i in range(len_label - n + 1):            label_subs[&#39; &#39;.join(label_tokens[i: i + n])] +&#x3D; 1        for i in range(len_pred - n + 1):            if label_subs[&#39; &#39;.join(pred_tokens[i: i + n])] &gt; 0:                num_matches +&#x3D; 1                label_subs[&#39; &#39;.join(pred_tokens[i: i + n])] -&#x3D; 1        score *&#x3D; math.pow(num_matches &#x2F; (len_pred - n + 1), math.pow(0.5, n))    return score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研要求</title>
      <link href="/2025/05/24/%E6%9D%82%E9%A1%B9/%E4%BF%9D%E7%A0%94/%E4%BF%9D%E7%A0%94%E8%A6%81%E6%B1%82/"/>
      <url>/2025/05/24/%E6%9D%82%E9%A1%B9/%E4%BF%9D%E7%A0%94/%E4%BF%9D%E7%A0%94%E8%A6%81%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="666f19edf31fd0a9299bd24b6c55edd81b03edafdf451be7b61631d3fdd8c021">4fbb2435fd3b6574fd4f7bd14582288411baa04027e1f23082c91553eb7a7a05eb4575f5db7410d01b3a851becea14efc9b1080494a6f90406baaa51fa210b72f73e00ff091657bfd75dfc1ae0a5f3aa453861efeb63f5baab35c652a20ad1c9ab1a61379a3320cd01a396c23a598acd7b733943c095307345d242ef6fb9dc932edc689b8865c24ef8a358b05479c86f05e5199c05049ab3348ca6c82ae2a2ffc785e0a74d7280e209e1c91ec266fa21dc81ca6e96d521058ecb50f0697bb5b47aa4b5fac606a385477a449a4967bd0f1c3459401a8492ddc0e890490ede5f65fcdf35309e82a3395bbec0486fcd5df87ed10233e5e0693d85bbfa61999c83517c42df125d9fc617f3a7ae7ec63fed9210a2cb0bd2b60382849fa7e0b114460f355e94bf17e45f951da59350e76adcc56601b99b55a17e2ed2b268619840b4de2e844fae194e22683ece83fe3dbdcf7383d9c72d8b0ac8e85a7fbf7d05409d606e31b60d95ef5c17aa53932f1eab8037b803143460bc6f23d1ca861a7245399030a470108583f69af6a0af96b34613e1b7a03f5517793b61469b01bace5a2374e00e59e9360871a89a5e8459cb372b8ff82a7cba1084870d8ce818c2ce241e859708455c17df679be55f4f7f3dedff920d4440a7760201900c92ef5dd1a18998615d39225e5326c6013ad0bb728fe3d70b131161c7de2135ce7f4125e947b3c3c43830ee5061d73cc4f0ff5522dd451b9dbfd1c418c1dd73e5a031ab60a6bed9b7f266422043affb86059ae4dcd77de8e469216687b78a6000d27f1d186aa32ef8c38e2f76a24d8883b5bd9efa83145c7141ebc7e6de165290e592a2ff31f5222122ec49ab971b0bd5dd875d065a65be766ee3dae54d1db1073ea6ea78b18a9c76cb09915d04ea6d76f75f20fd044d937ee644b2a10fe9f0717cb381a79a84253f6bde03bad04a27bddca9492d1ac9bb4a0deacceee7cd8acc3e7a144a61dd819cdf21aca2505841233a308eaae880f4227a9b674b40ad54e9a582c7dbced16b534a4e55f45962cb58fab1963a60bb328488b1099ed80fc652cc7fe35990d74cea0000c0b4e500ef43e5cbd279bec1fba5fa81fd9851533c8e425bc7de382194a91c5d6a851c9fc20f7a1f8f20ca30a012e38124e3add63c09adebeaaf044b6f9acc86fdbfaa075610501d24f046e32b1ff4066c67226f1cb169d576c851e2757270d2a0215932c786d978875307cbe32857dc7e75b77203411330752e36aeede8cf596aeae53f6eab69248a98a2758b26e2095ad902cc8e7a5a78cd485d319a49c9b018c678dffcab5e916cc18c5e62a29e796c302684693d85765f1bf53843676c305863fbde86148c2f3e96e1752886b5e215bf57a647c0853614442d8cd089e0f35cfcd584ac796ca23e6330de146b7f2747c5f90740133d6f7d31043035425f38ffe070624dad29ac3734d66d9549118ddb1e749d251caa69978811274a5714ea3520b46cc382b7c18af9e93536fa9deaca9ae866646db06f8248551488cdd1fc932e4ed6f137808740e054c17226a53c58cd39ed50e9ce56e69d2f68d9aa5d70542bf4d5e05bb48ee24b8b5e1816641239b9aee8926cc6861de2b2c5fa019a8101f8d7ea5cd0db45f53c023f52ec88478bd326f7d259239f15d64e4770c563215264fb2637b0133b1f229ef9e122e0d6294b298720cadd5e1151b0fa534fe4dbdc13fa9a80e7a9a74161766d35a9d292107f81cb4b42148011459d3d488cbb4618b77841ac341f517375c831e2dc159cbbc8c1edfbc3af9ada4ab03ea1c97024256fa35412acf5e7026cacb44901502b77d2bd5700de264e19d8b7d8cf120ee3aa5705ff467831ce1a1eeb5c9fa8480ba95acb09d3862cb06027bf5fb8ca68bc779b1342b8a310651f5d12cb847000669a16b7d980a6816d12bb82476a201204f3d67a5b464b495aed37a78fb738375f98bb421fd0efe5e128242f230e1921ba4577cd66073d2d5e65b0a2557a8dc900a3ce120725477761ed19d9175646b2c4552440e1ac67bc68506ec23ffad866118419b4ae506823301b87aa997c07529df711907b7c55ab05c1fcbd129a68c63e5ff7e1f056d8e9652edc3e8c32e3dbcd3fe838894c964ac616e9b4a6a445cbca0b81f5935d7cc025fd049e18398bcd8d0fe1723f7f4f0b876932e4f041d907a9c07bf019771ff471ab672d40a08cec6f9f4b6ae820c3cf85a72c7d4297687cfeb824d7ff9e71d76d03486d326bb7ef55525fe19e43c4329d658333fbf64ddaf800832cbe90b3504c3ba2a753cc09c508d6c1c415673b916381a82d020d7176149471605ff676b042bf491918427eb6cf48e7f1566464a0a154dcbac6eebd66af7af7d4fcdb230b4d1b0d0e70cadf632238c1c396c013512cd0b11b9e43968c2e1c8450973195910949a17c80178c17cd663c5a09b09f2df67d76fcd05fc36618a2eeb0589cfd10023c6b76bfb483d2f209808f6b5b82111fa0a957f519235ad72ea59a562c7aacfa7207e0c0c0ae959c54e1e70936d279a871433f654fcd2aa6db75a9b247ee110ff3656da1f3acd1e6a1665202a7d80151941ba1fb90ab174c680b8f6d969331b84ae20ab6a23cbc9caa13ba4554ec1ba94bbad22eb29a5eb7c86d8b2e2841265697dac4ab57ea0c4991e8d7a4330a1597875676f051d594af968ad86fb074f7599ca102e4122dfb818fcdf793a3343fc27145ab4d5046046cbf8fbe2bbe13d4b40969af1e193458b4a9a1c313aa7e1a40f66872fa782598d4ade7f95255b3f7c791fd9ecca89ffbe9c633f0681ceda560ca547506f39d3f2b1b3bdbd779be31ed20623213e1635d57b739198dab51fc423094f6daaed330f94b59b2168ec50e460100a5b2fa688ba3134b3e67ae0f7295ebd248370764ed094f88cecf3b4afd75b48cb2311eccd5279000b84c5ec19078a75f3c0422d7324cbba76d9b7130a59a62aa1c5e2b33c181bbf714ea8c35d02654f6dd45b311057faf208bc29e48c2924ea8059a513c9442f61d82e7145583153ffc22709a612f5ce5a29d229af7db3f7e0e82eb996ffd0131053b5ae43070c16ae489b62c0e1e21e79d28dc8f711ea80f641310f3d026a7f7c2e8cbeca371e4762701c71edc8d72345a6e295da3c24c58c805076fef065598063c42efb432e8d635b026b495d9218ae024b2101d4afa899830da3d367d64d4c909e34e1565ff5a0ea6955071a17ebc1a218ae80311801ffc67012d30d88c68a66c03dc59073a2655ee3eaca371ae8ce8e96bef8d461c0d79891cd4bc68bed24986e75ed800b84f55e1b8b40d5334b82ecc5aaf940595e000336ae0448d4cccc0bb14be1b037e96f0da4cad9c2c356efa2e1f8b26a4362b765f9f4498c95539583287d900653220b71f9793fde2d0618fbb99ad06b387fff558ae20aaa92797f8254e5449d7c367ff6a7e22895bb92207a3c44ec86ea12eedbe9b4008a86da2daba9ec51d4339ba732885286476f331c27b34caca249bae0308077cfbe8428e0cacddee2b256d796e87208da835551faecf18778a632c67584ce96d222750293bef25104d3885363a04dc5834ea33d5a1732537eebe4ebc3184beb1f834254cfe055e7458bf3cab927d53f2ab9062c30b2b9c7f252fcd569dc43d82e9c1cb18772934e3dda8cde3f6d17bbcebe3b87e2a88cce780a23562ddb40d90cdb6dcc79ddfc5a8bbdb560211e0d50ee383114dedc62c06ca3c64e7198d7f34f5fc8baacfc36a212b9fa3b43b7f0d341035a1f99f992d471d882cef26c6be4ac4bc5db81447c1296be6551237b002435e4bd3953de1aef10b0b3b3fe108ab855c7b1c44bc2b319ce34eb359358e201073357201c2efb82fe45fc53419fe3d3f0db0bb9a1174832dce0dafc4b88f79039d5c12e9d1f038d0b7bdf530ca8af49079cda094fb7ef5ed19dca730cbd28c72c7471056ef46c1fa17e4097ddacb1e5151b12b1c13dca785c928a3bfb0cab75cb964aa646e6a6060e6812d3fa9c87af08fc46591eef319a97fc3daeb95a3a91cd9ff87d52c9124951e1513c5ae3871d86cd9ffed6244471c3c975511304c638d5685805f127909ee50fb8ffc72a31afbb05c2bb5a20147a15ba78d6d368af3e3c8a48934c193cb67fb3ff209149017aac0ac76963c598cff1facbaa7617c0515e21173be90a3f616bf90b4bfb1190b78a34c3d0e4e19dd38badb5e0f70af973ddddeac794b98e29a794c501e7847319661b6445808b29ab1a8c70e31727c5659b56ee37b4cab5a888678c1794a840ca6a349ea357e4567b2132e1f43b6894bda1d8ba0ebbb9fa5f9aa904aa4106a07c61d5a6836fc66ad440ddac05feabbacdee33fb9d8614896fbe1411350d49d16bf70b8832349aa2d20f5814b3a3cf6f0aec516dbaf77e4ab1aa1101c6df73f154f3f8972b5a662359c9d8e00344eeaa23f22ab0f102df1e900ac3f9de78f3ff122b564f95340567006790e215099b8ba478cb821a4c5ccf44165d0937b173cc3de3e58e98ae1bb7db2b582059286caa692810b56c3fa9e98974212aa321836c62d5669d65f8b6f69045b48b53bb592c6d858b54dffaae2d0360831dd116f765ce07f9aeec90cf0f48d5467b67bda75285fa79e420861754c3e333530760f0f8dd17c60ce427ac2866b97d129677d5be8a81e80f3355a6ab9ed6988f92fe13a490355eb5de1ce502bd0115792690a72910528d52177a9c2308412d5efa16602cf28a2070dcf560bcfe8032d3e2244c219f8043ae554eb7844b91275cc2bf66b49c6552a351d2e32afcb553c1fabaf84cbc9221a11d02397d63f123384432b0161c0f5fb31cf0ff2093a99e21bde94b77c7055ecf262e0645cfdad4ea70501aa65d3004ae24d8f15af0675b7d21116ad91e8836e9c59765b7a8ea36848d2e10d05b3f16b933a2f54f58f16362cb9af7197535eb4078cbbbf282c5259dd5b5031380044f3c0c1c63b40b8cfbb08f9183ac9c6c148a274a44658cdd3e746bab3d920549a139c161d9d94f3acf0ac921b7514e77fc0f3601c56f3119c1d42e0a3de475737b9bc919d9de5846da9c7b3d07877e89f0805fc52563ae3ce2a81f56a64c08cf2e4244273a930c8ee9d41443eb335803639060f4fdde98d54efa709e6a31d987716817d726cbfa8ead880444e5575446c1542c12d2c78e6f050ed236716decbaf8f83c261688e84f7b8a99bc85963f66a0794b6b76e1dccf7547247447ae214edd0d12b23eac0e6ff8fd8244f288c0d013b4c33461b3331793d5e740a30ccdd86cbcea391225cd609aad5d16f44ccef3b81b159e96ab4fb0ccc0184634c85953c25e9ce555a4722d08a4dbe0dc745c00476dbe315ac1d16db5a953a482dab2c0c7f62fb24d27030e95c73ee55013d609c823fe1edb7fc317b5d75e4ab5920b58f829030e925b4b9d48cba94151f802a1075f7b948aba1766c3f6cb167a0dcc12e89cd9ba30d3e229b3b12246df6135052a1b526a7e576d7c62a71f16845cbd1bd4ed2f4fabc010cca1cd687e74016d8b29a092790242b635c47a835318ec2171ab9ea530c386d79c21981d59b9349b4455d22a07b2201d6a10922ae27272bb7b5badd25a09e65ceb745505d313b8b2ffb19e3baf0a70ef03737d4bea8842614b71d36c6b8b3fc7642e4ff02bf2e031c1067d3c02e79a2cfad54e5f1aee4a768c8579541187d29eb3b27f1ae96647c2b448451755b4e8b3c4a5d39535cd0ed7fb2a9346094dccdc35450fde1b325f65cf571fa83fda447350f86ed3ba93af53ecb8a98559b1a11f9d3898ae3fe2b53a873909b076577bd5201c126f3ef78cc168e6431f169ac9783ce44d712b722280238077f3ca486a10f75f6160552b51a5f1b2045f1e132b585003690d47721379bccbbacbd1805dbca966c589874274da83e42f05b5899bee962e3b1354213d3bd97f213c8e7bf108911da7eb0e368802d3c9abcf1ab53f946c71616e9a605c0551a7d14486cb56277df8faeb2bac5b64840057572faf64c611f732c1b802739a52a208f0f3592b914669d9a6d1f1a9c65a65fe1e4a599b4984fad942732285016bfc6870e7de75c23ade20fc4cad713a0a99eacb3b87712c4ae8ba990278a0a1b34d031e6d54d0900b729fd60ec8abe311326deb7ff32abe5c3bc2d13ce2883e0c84577a6bffc0d0ee112e7973feb4ec9a38c6cbf5f5eec4c30a9583cab9c3272d9b02014b959c075c2571ae0bfc05fb2740a0c561648674cf68384c2bf056d75c658274bb40cbfd41f270a149b69f5c59e2fc82ea4041730a5c7cd7ce14b46ef760466077d8c51048d70e759dab74d4e78fac25cf53d314bc55c0f757e1a43b91f57fc7dc2f274db0c7ec16f8293cb28f202ca512719ba13d9ad5318bb0066e045271265808c0210af99914fdc8ddfd0875f2eb7316e12f3f8ce90b523885d593fa58cfe3a4cc1431910ee60d1590c939d42ddbcf7ac1d26bcac86df3cf2a705f141021ba2c8e58d6fff60e22fef1e5d685899e06654bce1b28cb50edfe0838bee29813a6b0f6e1bd7008e665a3d5c1320758a4ee29fceaf04b2111d3ed8e58fa77f16d9d8e8331cf2a1be58ddbd61e77e58e63a9c60bb0841716d37799b63aa36cdf89538f73625ec8e280eb8d76bbe3fc37a2a3f3e6fd53fba503e1cfcfa2e07a347b9a65b12a187cce86b4d19b8c7a1f9dfc4d70712b36c0e2d082dda1b6242c337c1f891dccf15fa7ac159b4baa547ee2529372d92eabd7da3887561bd564ab7562c7dac714948d530ea599757379abef70296811075591258441587d4bc7c8706ef7dc28c35fa8944660c5212f546216663188a09c4e0faa9387d0e875fcdffe8e057b093dfe4167ee4f96be5df480724668c23e3fb0f83908aadd777f845418a8434d483c03d00b86ae5ae51df99de6d24525bfa14ff4f41b9551a4d101893a6964638b92595789ba2b4a41aa2702860e6b3632a6c92c7a1161f018aa1a5e200143fb946ef6d787f0de337c32a2caff4a11d410cc18320fb28a2d2a6163ac3257b7e2ebe2faf9c9d9f85b17e269d218b675b2c811dff72781ed8b6ed5cdb92aa6841b1661dc7ddc7ef757b5056bc4578ef01c9a34e0aad992794880c13e420b5da0df40e2e26a8aebdd33b303b241d75d152a83c9e7d5c67f5404dc5d023ad64f024af021f9cd4f161b878c799049b532dda67e6ac0870ba114463db7875cb981ac9d2094b8ac5d1c3283849768d9de5c389b929249ac28456b23ef619966e767309ca78135c6a44372fc888f8d45ff2150a864291af07963a68fc86f0c4377351e0b07666a667bd4166f84949a14550f2eca968930f3936dd1e14244486bf36784bdf21894f6987bcd9fe7f809bbaa4015c4bff7aa5abe529b8703e1fc94a2a2c9addd9f40be9a6a353d51bc2c4e640f161a8d41ed64a97f1d58ba12e6fb3dc42c2cfa6008e262a1894612a6582951a43ed12c4924a2f51bd94554e8775f999d3b39d378eea955f4047f72602db82ac0ddff443bcdd73302693a0b88935455a72fefd61e74247958755a06ca82f90e6d008b642aaf85b68aa1d753bfe7f24ed341a8653232d3d1f5acc82873ce24b146c83faef35d244a94a74759e052cf554fd1b5fdae0123e38b349ebf588c44ae7ed7b3cf1bb65027a2a896df1eba3a828d93c39835173d1b5f811e62813b93932cc0f9d0af7ae3e73aafda2534cf75204baa54ac96de53d9a1fcada7c0a548d143eb801a750d8961a2c0f6f0cb29d83ce5c18499f84893e51c3c73313f1f0820de3ba7af2dd37acf5b27a9b96aec4b67f8e919799a0bee8d4e113ed7bb016b88895ee69892e51bee1b8627ddf5f0d59f7fab828af63aba3d21b53b22fc81182b51fad47c783ffe2f48942bfb190616a733705794e411a1aa8ddf3cc12f1fd620be502b084d1206d4e1481946cd0da4e5b872e246350b9403af7df37a0eb0c9ec0f6ea962f680a149a273194d5e9a7fa0de398a89c58935375d043e427abefe2b371af93d17cd6f6272c360d56c2e38c84b8304325bc325539ea95d4eed9a1e45727793b0f4c76f8bd513bdb60ae5b7da36fe6c8fd454498e9cdc7f74e36451143ab16ddf1ad1dda59e4699875af920f555804b2e24af07d058832ec5834fe755fc3b7022cc441829220648c938703cc6eb538f1a589f519670041782b2ef6f4a23f4e9ab522abfabeb7ff5befade67f3533ac588be060fbc24ce5cc8211171f53abd12222887965b962a75a3be30586e06015d3e1caf1656737735788879df14402021e965c27db5d45a5306868f05653a5b000c3bb95f90f7b0dfadea416c40904af6a812fe2f340ae0a73df5ae070fd6565f8cc87cd1be64bc5d39c287bf710a957ecbe323d8cde053d323a8605a6023c1aee46af006fdd9a5156d53e726b351c1c97cb50877bebb9a4b7858172e380a3a31942200c9819ca39683ecc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 保研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密文章 </tag>
            
            <tag> 保研 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/24/java/web%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/05/24/java/web%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="web课程学习内容">1. web课程学习内容</h1><ol><li>mvc格式<ol><li>javabean周期</li><li>javabean 与mvc组成</li></ol></li><li>jsp中使用数据库<ol><li>mysql建立</li><li>JDBC连接，解决乱码</li><li>查询</li><li>用结果集操作数据库表</li><li>预处理语句</li></ol></li><li>jsp的文件操作<ol><li>FILE类</li><li>文件操作流</li><li>文件上床下载</li></ol></li><li>xml<ol><li>xml基本结构</li><li>dom 解析器</li><li>sax解析器</li><li>xml与css显示</li></ol></li><li>化妆品销售</li></ol><h1 id="web">2. web</h1><p><img src="C:/Users/34999/AppData/Roaming/Typora/typora-user-images/image-20250522212412585.png" alt="流程"></p><p><img src="/2025/05/24/java/web%E5%9F%BA%E7%A1%80/image-20250522212605681.png" alt="学习流程"></p><h2 id="html">2.1. html</h2><h3 id="标题">2.1.1. 标题</h3><p>h1</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>https://www.cctv.com<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_self<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 央视网<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>span : 没有语义的标签</p><p><span style="color: gray;"> </span></p><h3 id="css引入">2.1.2. css引入</h3><ol><li>行内样式，写在标签的style属性中</li><li>内部样式：写在<style> 标签中</li><li>外部，<code>&lt;link rel= &quot;stylesheet&quot; href= &quot;style.css&quot;&gt;</code></li></ol><p><span style="color: gray;"> today </span> </p><style>     span{        color: red;    }</style> <h4 id="颜色">2.1.2.1. 颜色</h4><div class="table-container"><table><thead><tr><th>种类</th><th>使用方法</th></tr></thead><tbody><tr><td>关键字</td><td>red</td></tr><tr><td>rgb</td><td>rag(red ,green ,blue)</td></tr><tr><td>rgba</td><td>rgba(red, green, blue ,透明度)</td></tr><tr><td>十六进制</td><td>#</td></tr></tbody></table></div><h4 id="css选择器">2.1.2.2. css选择器</h4><div class="table-container"><table><thead><tr><th style="text-align:left">选择器类型</th><th style="text-align:left">写法（语法）</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>元素选择器</strong></td><td style="text-align:left"><code>元素名称 &#123; ... &#125;</code></td><td style="text-align:left"><code>h1 &#123; ... &#125;</code></td><td style="text-align:left">选择页面上所有的 <code>&lt;h1&gt;</code> 标签</td></tr><tr><td style="text-align:left"><strong>类选择器</strong></td><td style="text-align:left"><code>.class属性值 &#123; ... &#125;</code></td><td style="text-align:left"><code>.cls &#123; ... &#125;</code></td><td style="text-align:left">选择页面上所有 <code>class</code> 属性为 <code>cls</code> 的标签</td></tr><tr><td style="text-align:left"><strong>ID 选择器</strong></td><td style="text-align:left"><code>#id属性值 &#123; ... &#125;</code></td><td style="text-align:left"><code>#hid &#123; ... &#125;</code></td><td style="text-align:left">选择页面上 <code>id</code> 属性为 <code>hid</code> 的标签</td></tr><tr><td style="text-align:left"><strong>分组选择器</strong></td><td style="text-align:left"><code>选择器1, 选择器2 &#123; ... &#125;</code></td><td style="text-align:left"><code>h1, h2 &#123; ... &#125;</code></td><td style="text-align:left">选择页面上所有的 <code>&lt;h1&gt;</code> 和 <code>&lt;h2&gt;</code> 标签</td></tr><tr><td style="text-align:left"><strong>属性选择器</strong></td><td style="text-align:left"><code>元素名称[属性] &#123; ... &#125;</code></td><td style="text-align:left"><code>input[type] &#123; ... &#125;</code></td><td style="text-align:left">选择页面上所有有 <code>type</code> 属性的 <code>&lt;input&gt;</code> 标签</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>元素名称[属性名=&quot;值&quot;] &#123; ... &#125;</code></td><td style="text-align:left"><code>input[type=&quot;text&quot;] &#123; ... &#125;</code></td><td style="text-align:left">选择页面上 <code>type</code> 属性为 <code>text</code> 的 <code>&lt;input&gt;</code> 标签</td></tr><tr><td style="text-align:left"><strong>后代选择器</strong></td><td style="text-align:left"><code>元素1 元素2 &#123; ... &#125;</code> （注意有空格）</td><td style="text-align:left"><code>form input &#123; ... &#125;</code></td><td style="text-align:left">选择 <code>&lt;form&gt;</code> 标签内的所有 <code>&lt;input&gt;</code> 标签</td></tr></tbody></table></div><h3 id="video">2.1.3. video</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>video/mp4<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span> <span class="token attr-name">width</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>800px<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span>width = 80% 长度占父类框架的占比<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>音频</p><pre class="line-numbers language-none"><code class="language-none">&lt;audio src&#x3D;“ ” controls&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="段落">2.1.3.1. 段落</h4><p></p><p>hello &lt;/p&gt;</p><p></p><h4 id="加粗">2.1.3.2. 加粗</h4><p><b> hello </b></p><p><strong> hello </strong></p><p><u> / <ins> 下划线</ins></u></p><p><i> / <em> 倾斜</em></i></p><p><s> / <del> 删除线</del></s></p><h4 id="特殊符号">2.1.3.3. 特殊符号</h4><div class="table-container"><table><thead><tr><th>&nbsp;</th><th>空格</th></tr></thead><tbody><tr><td>&lt;</td><td>&lt;</td></tr><tr><td>&gt;</td><td>&gt;</td></tr></tbody></table></div><h3 id="盒子模型">2.1.4. 盒子模型</h3><p><img src="/2025/05/24/java/web%E5%9F%BA%E7%A1%80/image-20250524155210755.png" alt="image-20250524155210755"></p><div class="table-container"><table><thead><tr><th>div</th><th>span</th></tr></thead><tbody><tr><td>一行显示一个</td><td>一行显示多个</td></tr><tr><td>宽度默认为父元素的宽度</td><td></td></tr><tr><td>可以设置height, weigth</td></tr></tbody></table></div><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span>200px<span class="token punctuation">;</span>  <span class="token comment">/* 定义的内容展示区域的宽度 */</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> 20px 20px 20px 20px<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 20px 20px 20px 20px <span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> 20px solid #100000<span class="token punctuation">;</span> <span class="token comment">/*宽度 边框 颜色*/</span>    <span class="token property">box-sizing</span><span class="token punctuation">:</span> content-box<span class="token punctuation">;</span>    <span class="token comment">/* content-box 内容盒子； bordor-box 边框盒子        /* 当前的盒子居中显示 */</span>    <span class="token property">margin</span><span class="token punctuation">:</span> 10px auto<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对齐方式">2.1.4.1. 对齐方式</h4><p>弹性布局flex</p><div class="table-container"><table><thead><tr><th>属性</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>display</td><td>flex</td><td></td></tr><tr><td>flex-direction</td><td>row x<br><br>column y轴</td><td></td></tr><tr><td>justify-content</td><td>1. flex-start 从头开始<br>flex-end<br>center<br>space-around    均分<br> space-between  两边贴边</td></tr></tbody></table></div><h3 id="表格">2.1.5. 表格</h3><div class="table-container"><table><thead><tr><th>&lt;table</th><th>整个表格</th><th>border: 边框宽度<br>width: 表格的宽度<br><br>cellspacing: 单元之间的空间</th></tr></thead><tbody><tr><td>&lt;tr</td><td>表格的行</td><td></td></tr><tr><td>&lt;td/th</td><td>表格的列</td><td>&lt;th是表头，&lt;td 是普通表格</td></tr></tbody></table></div><h3 id="表单">2.1.6. 表单</h3><p>提升与表格的交互，并在input前增加标识</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户名:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>    用户名:    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>input<ol><li>text</li><li>password</li><li>radio 单选按钮，相当与select option</li><li>checkbox</li></ol></li><li>select</li><li>textarea, 更大的文本框输入</li></ol><h2 id="javascript">2.2. javascript</h2><p>js代码最后放置在body的末尾</p><p>结尾的;可有可无</p><ol><li><p>内部脚本</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>外部脚本</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>/.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"> </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>在<body> 内外，都可以被执行</body></p><h3 id="定义变量">2.2.1. 定义变量</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//定义变量</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//声明常量</span><span class="token keyword">let</span> a<span class="token operator">=</span><span class="token string">'abc'</span><span class="token punctuation">;</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回a的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输入内容</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 弹窗</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//控制台</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Body标签中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="拼接字符串">2.2.1.1. 拼接字符串</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a<span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">let</span> b<span class="token operator">=</span> <span class="token string">'tom'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello my name is'</span><span class="token operator">+</span>b<span class="token operator">+</span> <span class="token string">'year is'</span><span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用'+字符串拼接</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>b<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> yeas is</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>a<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// 使用` $&#123;&#125;模板字符串输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数function">2.2.2. 函数function</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 匿名函数</span><span class="token keyword">let</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token operator">+</span>b <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对象">2.2.3. 对象</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token function-variable function">sing</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span> <span class="token string">'刚满十八岁'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//简化为</span>    <span class="token function">sing</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="json">2.2.3.1. json</h4><p>JavaScript 对象标记法（使用js对象语法书写的文本）</p><p>不同的是，所有的变量名使用<code>“”</code>引起</p><div class="table-container"><table><thead><tr><th>JSON.stringify()</th><th>js对象-&gt; json 变量的字符串</th></tr></thead><tbody><tr><td>JSON.parse()</td><td>json -&gt; 没有字符串的变量</td></tr></tbody></table></div><h3 id="DOM">2.2.4. DOM</h3><p>文档对象模型： 将标记语言的各个组成部分封装为对应的对象；</p><div class="table-container"><table><thead><tr><th>Document</th><th>整个文档</th></tr></thead><tbody><tr><td>Element</td><td>元素对象</td></tr><tr><td>Attribute</td><td>属性对象</td></tr><tr><td>Text</td><td>文本内容的对象</td></tr><tr><td>Comment</td><td>注释形成的对象</td></tr></tbody></table></div><p><img src="/2025/05/24/java/web%E5%9F%BA%E7%A1%80/image-20250525161235954.png" alt="image-20250525161235954"></p><h4 id="获取对象">2.2.4.1. 获取对象</h4><p>选择器对应css中的选择器<a href="#css选择器">css选择器</a> </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'选择器'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取匹配到的第一个元素</span>document<span class="token punctuation">.</span><span class="token function">querySelectorALL</span><span class="token punctuation">(</span><span class="token string">'选择器'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取所有匹配到的元素</span><span class="token comment">//得到的是一个节点集合，有长度，有索引</span><span class="token keyword">let</span> hs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span>#title<span class="token punctuation">)</span><span class="token punctuation">;</span>hs<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'修改后的内容'</span> <span class="token punctuation">;</span> <span class="token comment">// innerHTML代表文本内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="时间监听">2.2.5. 时间监听</h3><p>语法： 事件源.addEvenListener(‘事件类型’, 事件触发执行的函数);</p><ul><li>事件源：document中对象</li><li>事件类型： 点击click</li><li>事件处理的函数：要做什么事</li></ul><h4 id="事件类型">2.2.5.1. 事件类型</h4><div class="table-container"><table><thead><tr><th>鼠标</th><th>click</th></tr></thead><tbody><tr><td></td><td>mouseenter</td></tr><tr><td></td><td>mouseleave</td></tr><tr><td>键盘</td><td>keydown 按键触发</td></tr><tr><td></td><td>keyup 按键抬起</td></tr><tr><td>焦点</td><td>focus 进入输入框</td></tr><tr><td></td><td>blur 离开输入框</td></tr><tr><td>表单事件</td><td>input 输入时触发</td></tr><tr><td></td><td>submit 提交时触发</td></tr></tbody></table></div><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>func1<span class="token punctuation">,</span> func2<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"./utils.js"</span> <span class="token comment">// js导入函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>utils.js中的内容</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> functtion <span class="token function">printLog</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//使用export标记</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>html导入时候，需表明类型是模块化的js</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./js/1.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="vue">2.3. vue</h2><p>Vue是一款构建用户界面的渐进式的JavaScript框架</p><p>构建用户界面：针对数据构建</p><p>渐进式：可以只使用一部分</p><p><img src="/2025/05/24/java/web%E5%9F%BA%E7%A1%80/image-20250525174822695.png" alt="image-20250525174822695"></p><ol><li>准备<ol><li>引入Vue模块 </li><li>创建Vue程序的应用示例，控制视图的元素</li><li>准备元素，被Vue控制</li></ol></li><li>数据驱动<ol><li>准备数据</li><li>通过差值表达式渲染界面</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>        &#123;&#123;message&#125;&#125;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span><span class="token punctuation">&#123;</span> creatApp <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/vue@3/dist/vue.esm-browser.js"</span><span class="token punctuation">;</span>    <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>        <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">&#123;</span>                <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"hello vue"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用mount接管app</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="vue指令">2.3.1. vue指令</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-xxx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span> ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="v-for遍历">2.3.1.1. v-for遍历</h4><p>key的值避免复用</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(item, index) in items<span class="token punctuation">"</span></span> <span class="token attr-name">:</span> <span class="token attr-name">key</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> &#123;&#123;item&#125;&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>v-bind</strong>：动态为html绑定属性值，src, style,alt</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>avatar<span class="token punctuation">"</span></span><span class="token attr-name">,</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123;item.src&#125;&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">:alt</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123;item.alt&#125;&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- vlind:属性，然后对应v-for中的内容// : 简写形式 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>v-if/v-show</strong>:控制元素的显示/隐藏</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--v-if：根据条件判断结果，判断结果输出/隐藏，不一定创建不频繁使用紧跟v-else-if, v-elsev-show: 根据条件结果，调用css 中display格式，分别用来显示和隐藏，会创建频繁使用“”之间的结果判断--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>e.job==1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 帮助人<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>v-model</strong>: 双向绑定元素与vue data，绑定输入的内容</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchForm.name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>v-on</strong>： 为html绑定事件</p><p>引号中绑定的是函数动作，可以简化为@click</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>handle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在vue中定义方法</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">const app &#x3D; createApp(&#123;data()&#123;return&#123;        &#125;&#125;,    method:&#123;        handle()&#123;        &#125;    &#125;&#125;).mount(&quot;#app&quot;)&#x2F;&#x2F; 使用时需要将button的类型设置为button<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="致谢">3. 致谢</h1><p><a href="https://www.bilibili.com/video/BV1yGydYEE3H?spm_id_from=333.788.videopod.episodes&amp;vd_source=8f246175d50731783a1ab3dafac1f6ab&amp;p=2">02.Web前端开发初识_哔哩哔哩_bilibili</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>transformer</title>
      <link href="/2025/05/24/python/deeplearn/Transformer/"/>
      <url>/2025/05/24/python/deeplearn/Transformer/</url>
      
        <content type="html"><![CDATA[<h1 id="Transformer">1. Transformer</h1><h2 id="模型基本框架">1.1. 模型基本框架</h2><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250425173522602.png" alt="image-20250425173522602"></p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250516114212148.png" alt="image-20250516114212148"></p><h2 id="编码器">1.2. 编码器</h2><ol><li>通过嵌入层</li><li>对位置进行编码</li><li>经过编码器层<ol><li>注意力层：<ol><li>注意力机制</li><li>残差+ 规范化层</li></ol></li><li>前馈网络<ol><li>前馈网络</li><li>残差+ 规范化层</li></ol></li></ol></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class TransformerEncoder(d2l.Encoder):    def __init__(self, vocab_size, key_size, query_size, value_size,                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,                 num_heads, num_layers, dropout, use_bias&#x3D;False, **kwargs):        super(TransformerEncoder, self).__init__(**kwargs)        self.num_hiddens &#x3D; num_hiddens                self.embedding &#x3D; nn.Embedding(vocab_size, num_hiddens)        self.pos_encoding &#x3D; d2l.PositionalEncoding(num_hiddens, dropout)        self.blks &#x3D; nn.Sequential()        for i in range(num_layers):            self.blks.add_module(&quot;block&quot;+str(i),                EncoderBlock(key_size, query_size, value_size, num_hiddens,                             norm_shape, ffn_num_input, ffn_num_hiddens,                             num_heads, dropout, use_bias))                def forward(self, X, valid_lens, *args):        # 因为位置编码值在-1和1之间，        # 因此嵌入值乘以嵌入维度的平方根进行缩放，        # 然后再与位置编码相加。        X &#x3D; self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))        self.attention_weights &#x3D; [None] * len(self.blks)        for i, blk in enumerate(self.blks):            X &#x3D; blk(X, valid_lens)            self.attention_weights[                i] &#x3D; blk.attention.attention.attention_weights        return X<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="EncoderBlock层">1.2.1. EncoderBlock层</h3><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250425175900742.png" alt="image-20250425175900742"></p><ol><li>注意力层：<ol><li>注意力机制</li><li>残差+ 规范化层</li></ol></li><li>前馈网络<ol><li>前馈网络</li><li>残差+ 规范化层</li></ol></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class EncoderBlock(nn.Module):    &quot;&quot;&quot;Transformer编码器块&quot;&quot;&quot;    def __init__(self, key_size, query_size, value_size, num_hiddens,                     norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,                     dropout, use_bias&#x3D;False, **kwargs):    super(EncoderBlock, self).__init__(**kwargs)        self.attention &#x3D; d2l.MultiHeadAttention(            key_size, query_size, value_size, num_hiddens, num_heads, dropout,            use_bias)        self.addnorm1 &#x3D; AddNorm(norm_shape, dropout)        self.ffn &#x3D; PositionWiseFFN(            ffn_num_input, ffn_num_hiddens, num_hiddens)        self.addnorm2 &#x3D; AddNorm(norm_shape, dropout)    def forward(self, X, valid_lens):        Y &#x3D; self.addnorm1(X, self.attention(X, X, X, valid_lens))        return self.addnorm2(Y, self.ffn(Y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多头注意力机制">1.2.1.1. 多头注意力机制</h4><p>将键值对分为多个子空间，每个注意力机制学习一个子空间的特征，得到H组的注意力权重，然后将注意力权重通过线性层汇聚</p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250425155705305.png" alt="image-20250425155705305"></p><p>常规思路：</p><ol><li>将query, key, values映射到子空间，使用不同的Linear映射</li><li>将不同头的注意力结果合并在一起，在feature维度上合并</li><li>再通过一个Linear线性层，连接所有head</li></ol><p>并行思路</p><ol><li>将query,key, values映射到完整空间，然后将完整空间查分成子空间，head与batch组成一个伪batch</li><li>再将子空间的数据通过点积注意力</li><li>将head从batch中分离出来，与feature合并，效果与非并行情况相同</li><li>最后通过线性层</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MultiHeadAttention(nn.Module):    def __init__(self, key_size, query_size, value_size, num_hiddens, num_head, dropout, bias &#x3D; false, **kwargs):       self.num_head &#x3D; head        self.attention &#x3D; d2l.DotProductAttention(dropout)        self.W_k &#x3D; nn.Linear(key_size, num_hiddens)        self.W_q &#x3D; nn.Linear(query_size, num_hiddens)        self.W_v &#x3D; nn.Linear(value_size, num_hiddens)        self.W_o &#x3D; nn.Linear(num_hiddens, num_hiddens) # 全连接层            def forward(self, query ,key ,values, valid_lens):               # 转换为(batch_size* head, key&#x2F;query , num_hidden&#x2F;head)        query &#x3D; transpose(self.W_q(query),  self.head_num)        keys &#x3D; transpose_qkv(self.W_k(keys), self.num_heads)        values &#x3D; transpose_qkv(self.W_v(values), self.num_heads)                # 将掩码扩展为batch*head        if valid_len is not None:            valid_lens &#x3D; torch.repeat_interleave(            valid_lens, repeats &#x3D; self.num_heads , dim &#x3D;0)                    output &#x3D; self.attention(query, key ,value, valid_len)                output_concat&#x3D;transpose_output(output, self.num_heads)        # 输出为（batch_size, query_size, hidden_size)        return self.W_o(output_concat)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="残差-规范化层">1.2.1.2. 残差+规范化层</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">class AddNorm(nn.Module):    &quot;&quot;&quot;残差连接后进行层规范化&quot;&quot;&quot;    def __init__(self, normalized_shape, dropout, **kwargs):        super(AddNorm, self).__init__(**kwargs)        self.dropout &#x3D; nn.Dropout(dropout)        self.ln &#x3D; nn.LayerNorm(normalized_shape)    def forward(self, X, Y):        # Y+X 残差网络        # Ln 层归一化        return self.ln(self.dropout(Y) + X)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="残差层">1.2.1.2.1. 残差层</h5><p>训练是模型训练出F(X) = f(x)- X</p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250423225436209.png" alt="image-20250423225436209"></p><p>对应模型中 支线 为x ，前馈神经网络中预测是f(X), 相加后得到准确预测的F(X)</p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250425181440459.png" alt="image-20250425181440459"></p><h5 id="批量归一化层BatchNorm">1.2.1.2.2. 批量归一化层BatchNorm</h5><script type="math/tex; mode=display">\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}.</script><p>对特征维度进行归一化,$\gamma、\beta$ 是拉伸和偏移参数</p><ol><li><p>对特征维度进行归一化</p><pre class="line-numbers language-none"><code class="language-none">mean &#x3D; X.mean(dim &#x3D; 0, keepdim &#x3D; True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>卷积层</p><ol><li>对通道维度进行归一化</li></ol></li><li><p>训练状态下使用小批次的样本均值与方差，测试状态使用的移动平均估算的均值与方差</p></li></ol><h3 id="前馈网络层">1.2.2. 前馈网络层</h3><p>这里的线性层可以使用1*1cnn网络代替，代替结果</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class PositionWiseFFN(nn.Module):    &quot;&quot;&quot;基于位置的前馈网络&quot;&quot;&quot;    def __init__(self, ffn_num_input, ffn_num_hiddens, ffn_num_outputs,                 **kwargs):        super(PositionWiseFFN, self).__init__(**kwargs)        self.dense1 &#x3D; nn.Linear(ffn_num_input, ffn_num_hiddens)        self.relu &#x3D; nn.ReLU()        self.dense2 &#x3D; nn.Linear(ffn_num_hiddens, ffn_num_outputs)    def forward(self, X):        return self.dense2(self.relu(self.dense1(X)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解码器">1.3. 解码器</h2><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250425181429443.png" alt="image-20250425181429443"></p><ol><li>通过嵌入层</li><li>对位置进行编码</li><li>经过解码器层<ol><li>第一个注意力层 ， query ,key, value,都是解码器输入</li><li>第二个注意力层， query 来自解码器输入 ， key, values来自编码器输入<ol><li>交叉注意力机制中，<strong>key,value</strong>来源使用一致，这里key,values来自编码器输入</li></ol></li><li>前馈神经网络</li></ol></li><li>全连接层</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class TransformerDecoder(d2l.AttentionDecoder):    def __init__(self, vocab_size, key_size, query_size, value_size,                 num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens,                 num_heads, num_layers, dropout, **kwargs):        super(TransformerDecoder, self).__init__(**kwargs)        self.num_hiddens &#x3D; num_hiddens        self.num_layers &#x3D; num_layers        self.embedding &#x3D; nn.Embedding(vocab_size, num_hiddens)        self.pos_encoding &#x3D; d2l.PositionalEncoding(num_hiddens, dropout)        self.blks &#x3D; nn.Sequential()        for i in range(num_layers):            self.blks.add_module(&quot;block&quot;+str(i),                DecoderBlock(key_size, query_size, value_size, num_hiddens,                             norm_shape, ffn_num_input, ffn_num_hiddens,                             num_heads, dropout, i))        self.dense &#x3D; nn.Linear(num_hiddens, vocab_size)            def init_state(self, enc_outputs, enc_valid_lens, *args):        return [enc_outputs, enc_valid_lens, [None] * self.num_layers]    X &#x3D; self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens))        self._attention_weights &#x3D; [[None] * len(self.blks) for _ in range (2)]        for i, blk in enumerate(self.blks):            X, state &#x3D; blk(X, state)            # 解码器自注意力权重            self._attention_weights[0][                i] &#x3D; blk.attention1.attention.attention_weights            # “编码器－解码器”自注意力权重            self._attention_weights[1][                i] &#x3D; blk.attention2.attention.attention_weights        return self.dense(X), state            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解码器层">1.3.1. 解码器层</h3><p>经过解码器层</p><ol><li>第一个注意力层 ， query ,key, value,都是解码器输入</li><li>第二个注意力层， query 来自解码器输入 ， key, values来自编码器输入</li><li>前馈神经网络</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">class DecoderBlock(nn.Module):    &quot;&quot;&quot;解码器中第i个块&quot;&quot;&quot;    def __init__(self, key_size, query_size, value_size, num_hiddens,                 norm_shape, ffn_num_input, ffn_num_hiddens, num_heads,                 dropout, i, **kwargs):        super(DecoderBlock, self).__init__(**kwargs)        self.i &#x3D; i        self.attention1 &#x3D; d2l.MultiHeadAttention(            key_size, query_size, value_size, num_hiddens, num_heads, dropout)        self.addnorm1 &#x3D; AddNorm(norm_shape, dropout)        self.attention2 &#x3D; d2l.MultiHeadAttention(            key_size, query_size, value_size, num_hiddens, num_heads, dropout)        self.addnorm2 &#x3D; AddNorm(norm_shape, dropout)        self.ffn &#x3D; PositionWiseFFN(ffn_num_input, ffn_num_hiddens,                                   num_hiddens)        self.addnorm3 &#x3D; AddNorm(norm_shape, dropout)def forward(self, X, state):        enc_outputs, enc_valid_lens &#x3D; state[0], state[1]        # 训练阶段，输出序列的所有词元都在同一时间处理，        # 因此state[2][self.i]初始化为None。        # 预测阶段，输出序列是通过词元一个接着一个解码的，        # 因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示        if state[2][self.i] is None:            # 使用当前输入的数据进行预测            key_values &#x3D; X        else:            &#39;&#39;&#39;            state[2] 中存放者上一个时间步，留下的已经每个块之前计算好的key_value            # 加上y_t之前的数据一起预测            &#39;&#39;&#39;            key_values &#x3D; torch.cat((state[2][self.i], X), axis&#x3D;1)        state[2][self.i] &#x3D; key_values        if self.training:            batch_size, num_steps, _ &#x3D; X.shape            # dec_valid_lens的开头:(batch_size,num_steps),            # 其中每一行是[1,2,...,num_steps]            dec_valid_lens &#x3D; torch.arange(                1, num_steps + 1, device&#x3D;X.device).repeat(batch_size, 1)        else:            dec_valid_lens &#x3D; None        # 自注意力        X2 &#x3D; self.attention1(X, key_values, key_values, dec_valid_lens)        Y &#x3D; self.addnorm1(X, X2)        # 编码器－解码器注意力。        # enc_outputs的开头:(batch_size,num_steps,num_hiddens)        Y2 &#x3D; self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens)        Z &#x3D; self.addnorm2(Y, Y2)        return self.addnorm3(Z, self.ffn(Z)), state        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在transformer结构中，query与key权重对values值进行查询，values值是编码器的输入，为什么就可以查询到解码器想要的结果呢？比如，编码器编码我是李华，解码器对I 查询 我，ji</p><h2 id="优化">1.4. 优化</h2><p>Adam， 自动调整学习率</p><p>warm up 和逆平方根衰减</p><h2 id="BERT">1.5. BERT</h2><h3 id="预训练（无监督-自监督）">1.5.1. 预训练（无监督/自监督）</h3><p>自监督</p><ol><li>完形填空</li><li>预测下一句</li></ol><h3 id="微调（有监督）">1.5.2. 微调（有监督）</h3><p>需要根据下游任务添加输出层，添加的层需要重新训练</p><ol><li>两个句子分类</li><li>单个句子的分类</li><li>问答任务<ol><li>找到答案正确的文本位置</li></ol></li><li>命名实体位置标记<ol><li>标记实体位置（begin ,inside ,O（非实体））</li></ol></li></ol><h2 id="Decoder-only">1.6. Decoder_only</h2><p><strong>优点</strong>：</p><ol><li>Decoder-only的注意力矩阵始终是满秩，表达能力更强</li><li>不会浪费Encoder的参数，输入可以直接作用与decoder</li></ol><h3 id="预训练">1.6.1. 预训练</h3><p>test prediction 预测文本</p><h3 id="微调">1.6.2. 微调</h3><p>test prediction + task classfication 的损失相加</p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250516123238590.png" alt="task"></p><h2 id="GPT-2">1.7. GPT-2</h2><p><strong>无需微调，预训练的模型就可以解决下游任务</strong></p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250516123552285.png" alt="image-20250516123552285"></p><p>Zero-shot, One-shot, Few-shot</p><p>使用任务提示（prompt）和少量示例直接输入</p><h3 id="lay-N放在模块前">1.7.1. lay N放在模块前</h3><ol><li>尺度定律： 模型的大小与Loss线性拟合</li><li>涌现能力： 大模型效果迅速提升</li></ol><h2 id="GPT">1.8. GPT</h2><p>参数数量增多，需要减少计算量。</p><h3 id="sparse-attention">1.8.1. sparse attention</h3><p>减少attention的计算量，只关注临近部分和前面的部分权重</p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250516124911687.png" alt="image-20250516124911687"></p><h3 id="chatgpt">1.8.2. chatgpt</h3><p>增加人类反馈强化学习（RLHF) ,与人互动</p><h2 id="LLAMA">1.9. LLAMA</h2><h3 id="swiGLU">1.9.1. swiGLU</h3><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250516155254082.png" alt="image-20250516155254082"></p><p>使用swi激活函数，同时使用门控机制（GLU)，选择性激活函数</p><p>优点： swish激活函数更平滑，GLU实现选择性激活</p><h3 id="GQA-grouped-query-attention">1.9.2. GQA-grouped-query attention</h3><p>减少k,v的head 数量，query共享重复的k,v，减少参数</p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250516155516226.png" alt="image-20250516155516226"></p><h3 id="layer-norm-变体">1.9.3. layer norm 变体</h3><p>RMSNorm:均方根归一化</p><p><strong>取出平移，只保留缩放</strong></p><p>优点：计算简单</p><p><img src="/2025/05/24/python/deeplearn/Transformer/image-20250516160128424.png" alt="image-20250516160128424"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp+servlet</title>
      <link href="/2025/05/24/java/jsp/"/>
      <url>/2025/05/24/java/jsp/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础">1. java基础</h1><h2 id="修饰符">1.1. 修饰符</h2><h3 id="final">1.1.1. final</h3><h1 id="servlet">2. servlet</h1><h2 id="http协议">2.1. http协议</h2><pre class="line-numbers language-http" data-language="http"><code class="language-http">http:&#x2F;&#x2F;ip:端口&#x2F;资源路径?name&#x3D; eg : http:&#x2F;&#x2F;127.0.0.1&#x2F;myweb&#x2F;servlet?name &#x3D; zhangsan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>支持客户/服务端</li><li>支持get ,post请求</li><li>传输内容，类型可以有Content-Type</li><li>http无连接，http1.1之后支持可持续连接</li><li>http无状态信息</li></ol><h3 id="请求和responce">2.1.1. 请求和responce</h3><h4 id="请求request">2.1.1.1. 请求request</h4><ol><li><p>请求行</p><blockquote><p>get的请求放在请求行中</p></blockquote><p>method Request_url http_version 换行</p></li><li><p>请求头</p><ol><li>键值对</li></ol></li><li><p>请求体</p><ol><li>get没有请求行</li></ol></li></ol><h4 id="response">2.1.1.2. response</h4><ol><li>状态行</li><li>响应头</li><li>响应正文</li></ol><h3 id="消息头">2.1.2. 消息头</h3><ul><li><em>referer</em>: 请求前来位置</li><li><em>Location</em>: 请求达到位置</li><li><em>refresh</em>: 自动跳转时间</li></ul><h2 id="服务器">2.2. 服务器</h2><p>接受客户端的请求,调用程序处理,返回程序数据</p><h3 id="tomcat目录">2.2.1. tomcat目录</h3><ul><li>bin: 启动或关闭的配置文件</li><li>conf: 配置servel端口号等信息文件</li><li>lib: 运行时使用的java包</li><li>logs :日志文件</li><li>webapps: web应用</li><li>works: 工作目录</li></ul><h3 id="使用idea-集成tomcat">2.2.2. 使用idea 集成tomcat</h3><h2 id="servlet实现">2.3. servlet实现</h2><ol><li>创建java类</li><li>实现servlet规范, 继承HttpServlet类</li><li>重写service 方法,用于处理请求</li><li>设置注释,指定访问方法的路径</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Webservlet(name &#x3D; , value &#x3D;&#123; , &#125;) value可以指定多个名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="servlet执行流程">2.3.1. servlet执行流程</h3><ol><li>从请求头中找到主机</li><li>访问请求头中的资源,第一次访问创建一个对象</li><li>将参数交给req, 通过resp响应参数</li></ol><h3 id="三种访问方式">2.3.2. 三种访问方式</h3><p>继承方式</p><p>HttpServlet -&gt; GenericServlet &gt; Servlet</p><h3 id="service-doPost-doGet">2.3.3. service ,doPost, doGet</h3><p>调用service 实际上调用doPost, doGet</p><blockquote><p>不知道post 或 get ,写service</p></blockquote><h3 id="servlet生命周期">2.3.4. servlet生命周期</h3><p>请求访问servlet容器时候,检查容器中是否存在该资源对象,没有调用init方法,第二次访问时,调用service.程序停止售,调用destory方法</p><p><img src="/2025/05/24/java/jsp/image-20250503221820723.png" alt="image-20250503221820723"></p><h3 id="HttpServletRequest-获取请求">2.3.5. HttpServletRequest 获取请求</h3><p>HTTp的请求都封装在Req对象中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String value &#x3D; Req.getParameter(&quot;&quot;) 获取名称对应的值String[] values &#x3D; Req.getParameterValues(&quot;&quot;) 同一个name存在多个值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="请求乱码问题">2.3.5.1. 请求乱码问题</h4><p>乱码原因: request 封装时候,使用的ISO ,不支持中文编码</p><p>get 不会乱码，post有乱码</p><p>解决办法: 设置请求的编码方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">req.sertCharacterEncoding(&quot;utf-8&quot;) &#x2F;&#x2F; 只值对post代码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">String name &#x3D; new String(req.getParameter(name)).getBytes(&#39;ISO-8859-1&#39;, charameter &#x3D; &#39;utf-8&#39;) &#x2F;&#x2F;适用于所有get 与post<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="请求转发">2.3.5.2. 请求转发</h4><ol><li>服务器行为</li><li>前台地址栏不发生改变,只产生输出</li><li>只有一个请求</li><li>req, resp对象共享</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">req.getRequestDispatcher(&quot;跳转网址&quot;).forward(req, resp);req.setAttribute(String name , Object value);&#x2F;&#x2F;设置新的对象值req.getAttribute(String name);req.removeAttribute(String name);&#x2F;&#x2F;删除对象值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HttpServletResponse-响应请求">2.3.6. HttpServletResponse 响应请求</h3><p>使用流输出方法响应</p><ol><li>getWritter() 字符输出流(输出字符串)</li><li>getOutputStream(), 字节输出流(输出任意数据)</li></ol><p><strong>两种流不能同时使用</strong></p><h4 id="响应乱码">2.3.6.1. 响应乱码</h4><p><strong>原因</strong>： 服务端和客户端的编码格式一致</p><p>解决办法：同时设置服务端和客户端的编码，保证编码格式一致</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 设置服务端的编码格式response.setCharacterEncoding(&quot;UTF-8&quot;);&#x2F;&#x2F; 设置客户端代码response.setHeader(&quot;content_type&quot;, &quot;text&#x2F;html; charset&#x3D; UTF-8&quot;);&#x2F;&#x2F; 同时设置编码格式response.setContentType(&quot;text&#x2F;html; charset&#x3D; UTF-8&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端重定向">2.3.6.2. 客户端重定向</h4><p>服务端指导客户端的行为</p><blockquote><p>地址栏发生改变，写入location</p><p>服务器接受location</p></blockquote><p>有两次请求</p><blockquote><p>请求对象不共享</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">response.sendRedirect(&quot;s05&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="请求转发与重定向的区别">2.3.6.3. 请求转发与重定向的区别</h4><div class="table-container"><table><thead><tr><th>请求转发</th><th>重定向</th></tr></thead><tbody><tr><td>一次请求，request数据共享</td><td>两次请求</td></tr><tr><td>服务端跳转</td><td>客户端跳转</td></tr><tr><td>绝对地址到当前项目中，不能向外跳转</td><td>可以向域外跳转</td></tr></tbody></table></div><h2 id="Cookie对象">2.4. Cookie对象</h2><p>浏览器中将数据存放在客户端中，在客户端中处理数据，减少网络传输与数据库查询</p><p>由服务器写入客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 服务器写入Cookie 到客户端中，客户端保存CookieCookie cookie &#x3D; new Cookie(name &#x3D; &quot;a&quot;, value &#x3D; &#39;b&#39;);response.addCookie(cookie)&#x2F;&#x2F; 获取CookieCookie[] conkie &#x3D; request.getCookies(); &#x2F;&#x2F; 获取客户端路径下所有的Cookie对象&#x2F;&#x2F;将Cookie 的name 与需要查找的Cookie作比较<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置对象存在时间">2.4.1. 设置对象存在时间</h3><p>设置maxAge存活时间 ，从创建Cookie对象开始</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">cookie.setMaxAge(time);&#x2F;*1. 负整数，只在浏览器内存中存在2. 正整数，保存磁盘对应的时间，关闭后依旧计数，时间为s3. 0 ： 删除这个Cookie*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意点">2.4.2. 注意点</h3><ol><li>Cookie 只在当前浏览器中有效，不跨浏览器和及其</li><li>Cookie不支持存放中文，使用时候需要编码/解码</li><li>新的同名name Cookie 将覆盖之前的Cookie</li><li>Cookie的存储数量有上限，Cookie的大小有限，4KB左右</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">String name &#x3D; &quot;陈龙&quot;;&#x2F;&#x2F; 中文通过URLEncoder.encode()编码name &#x3D; URLEncoder.encoder(name);&#x2F;&#x2F; 使用时，需URLDecoder.decoder()解码name &#x3D; URLDecoder.decoder(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Cookie的访问路径">2.4.3. Cookie的访问路径</h3><ol><li>当前浏览器下如何项目任何资源都可以获取Cookie</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">cookie.setPath(&quot;&#x2F;&quot;);&#x2F;&#x2F; 默认本项目cookie.setPaht(&quot;&#x2F;s02&quot;);&#x2F;&#x2F; 设置指定站点名cookie.setPath(&quot;&#x2F;sc03&quot;);&#x2F;&#x2F; 指定项目的指定资源访问cookiecookie.setPaht(&quot;s03&#x2F;co1&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有访问的路径包括  <em>cookie的路径</em> 时， 能够获取这个cookie</p><h2 id="HttpSession-对象">2.5. HttpSession 对象</h2><p>属于服务器对象， 标识一次对话，确定是否为一个用户的数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">HttpSession session &#x3D; request.getSession(); &#x2F;&#x2F; 如session 对象存在，则获取 ；否则第一次创建对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一次请求到了服务器，标识启动了会话，客户端向服务器传递JSESSIONID的cookie，用于标识服务器中对应的session， 如果有，则共享数据，没有创建sesion,同时给客户端创建JSESSIONID的cookie.</p><h3 id="设置域对象">2.5.1. 设置域对象</h3><p>HttpSession 与 request 的区别</p><p>重定向： 只要session会话不是小，session一直共享数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">HttpSession session &#x3D; request.getSession();session.setAttribute(&quot;name&quot;, &quot;hello&quot;);session.getAttribute(&quot;name&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="session-对象的销毁">2.5.2. session 对象的销毁</h3><p>默认是30min， 一旦有操作，session 重新计时</p><blockquote><p>在conf/web.xml中修改session_config中timeout,单位为1min</p></blockquote><h4 id="设置到期时间">2.5.2.1. 设置到期时间</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">session.setMaxInactiveInterval(15); &#x2F;&#x2F;单位为s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="立即销毁">2.5.2.2. 立即销毁</h4><p>退出登录，立马销毁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">session.invalidate(); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="关闭浏览器，Cookie对象销毁">2.5.2.3. 关闭浏览器，Cookie对象销毁</h4><p>session 需要JSESSIONID ，JSESSIONID默认在浏览器内存中有效，Cookie消失后，session 结束</p><h4 id="关闭服务器失效">2.5.2.4. 关闭服务器失效</h4><h2 id="ServletContext对象">2.6. ServletContext对象</h2><h3 id="获取对象">2.6.1. 获取对象</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">ServletContext servletContext1 &#x3D; request.getServletContext();&#x2F;&#x2F; session对象获取ServletContext servletContext2 &#x3D; request.getSession().getServletContext();&#x2F;&#x2F; ServletConfig对象中获取getServletConfig().getServletContext();&#x2F;&#x2F; servlet中直接获取ServletContext servletContext4 &#x3D; getServletContext();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取服务器信息String serverInfo &#x3D; request.getServletContext().getServerInfo();&#x2F;&#x2F; 获取项目路径String realPath &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;&quot;);&#x2F;&#x2F; 从根目录下获取<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Servlet-域对象">2.6.2. Servlet 域对象</h3><ol><li><p>request 域对象</p><p>再一次请求中有效，请求转发有效，重定向无效</p></li><li><p>session 对象</p><p>一次会话中有效，session销毁后无效</p></li><li><p>servletContext 对象</p><p>服务器中始终有效</p></li></ol><h2 id="文件上传下载">2.7. 文件上传下载</h2><h3 id="上传">2.7.1. 上传</h3><h4 id="前端实现">2.7.1.1. 前端实现</h4><ol><li>准备表单form</li><li>设置表单的请求类型 ‘method =”post”</li><li>设置表达类型为文件上传类型 enctype = “multipart/form-data”</li><li>设置文件提交的地址 active = “提交路径”</li><li>准备表单元素<ol><li>普通的表单项 type = “text”</li><li>文件项 type = “file”</li><li>设置表单元素的name值</li></ol></li></ol><h4 id="后端实现">2.7.1.2. 后端实现</h4><p>添加注解<code>MultipartConfig</code>, servlet将 multipart/form-data 的post封装在part对象中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@MultipartConfigPart part &#x3D; request.getPart(&quot;name&quot;);String fileName &#x3D; part.getSubmittedFileName(); &#x2F;&#x2F; 获取提交文件名称；String realPath &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;&quot;);&#x2F;&#x2F; 需要自行指定保存路径String saveName&#x3D; fileName+&#39;&#x2F;&#39;+ realPath;part.write(saveName);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件下载">2.7.2. 文件下载</h3><h4 id="超链接下载">2.7.2.1. 超链接下载</h4><ol><li>没有download属性<ol><li>浏览器识别文件，跳转显示，否则下载</li></ol></li><li>有download属性<ol><li>指定属性值，为下载名</li></ol></li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>download/text.png<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 图片文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>download/text.png<span class="token punctuation">"</span></span> <span class="token attr-name">download</span><span class="token punctuation">></span></span>图片文件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="后端下载">2.7.2.2. 后端下载</h4><ol><li><p>设置request和response的编码类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">request.setCharacterEncoding(&quot;UTF-8&quot;);response.setContentType(&quot;text&#x2F;html; charset &#x3D; UTF-8&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>获取文件名称</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String fileName &#x3D; request.getParameter(&quot;name&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>判断文件名称是否为空</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 文件名&#x3D; null 或者全是空格if(fileName &#x3D;&#x3D; null || &quot;&quot;.equals(fileName.trim()))&#123;    response.getWritter().write(&quot;输出提示信息&quot;);    response.getWritter().close();&#x2F;&#x2F; 关闭信息&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将路径转换为file 对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String path &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;download&#x2F;&quot;);File file &#x3D; new File(path+ fileName);&#x2F;&#x2F; 检查文件存在&#x2F;&#x2F;是否为文件夹if(file.exist()&amp;&amp; file.isFile())&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>输出</p><ol><li><p>设置响应类型， 浏览器无法解析的MINE类型 “application/x-msdoanload”, “application/octet-stream”</p><ol><li>response.setContentType(“application/x-msdoanload”)</li></ol></li><li><p>设置响应头，下载文件筐和文件名</p><ol><li>response.setHeader(“Content_Dispostion”, ”attachment;filename=”+ fileName);</li></ol></li><li><p>输出流和输入流</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">InputStream in &#x3D;  new FileInputSream(file);ServletOutputSream out &#x3D; response.getOutputStream();byte[] bytes &#x3D; new byte[1024];int len &#x3D; 0;while((len &#x3D; in.read(byte))!&#x3D; -1)&#123;    out.write(bytes,0 , len);&#125;&#x2F;&#x2F; 关闭资源out.close();in.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>简便实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">response.setContentType(&quot;application&#x2F;octet-stream&quot;); &#x2F;&#x2F; 设置为通用的二进制流类型response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;\&quot;&quot; + fileName + &quot;\&quot;&quot;); &#x2F;&#x2F; 提示浏览器下载文件&#x2F;&#x2F; 使用 try-with-resources 确保流被正确关闭try (InputStream in &#x3D; new FileInputStream(file);    ServletOutputStream out &#x3D; response.getOutputStream()) &#123;    &#x2F;&#x2F; 使用 transferTo 方法进行拷贝 (Java 9+)    in.transferTo(out);    &#x2F;&#x2F; 注意：在 try-with-resources 块结束时，in 和 out 会自动关闭&#125; catch (IOException e) &#123;    &#x2F;&#x2F; 处理可能的 IO 异常    e.printStackTrace(); &#x2F;&#x2F; 在实际应用中应该记录日志或返回更友好的错误信息    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, &quot;文件读取或传输失败&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> servlet </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/24/%E6%9D%82%E9%A1%B9/done_url/"/>
      <url>/2025/05/24/%E6%9D%82%E9%A1%B9/done_url/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="a24a8e9923adc73f8734bf4d54f0f52b3c7aaa3a7338ff83a9c89288fcfbac47">4fbb2435fd3b6574fd4f7bd145822884a098a0719a519100aebfe4c2fde4f5a0b742ef9261977b6e3a9b4c3e50829a470e690778866554ee319777c27fc8d372d445bc34ce0815f9126ccbdb184b46eb9e78f871294fe7a7b3c58ac1b6ef19add18dffb744ecb7e98080827e173e466133046651ab70423598fdf7baa145809b0518243cc3962fdae97283ff57888465c714936a21428f2916ad58ae556cf843e238c090515ef0788309dfeb4e0498a241956600f541f1c73efefcd8ec48ead5c300cc0ed4ecbca27dab55c2812181460d9903a118ea2bad531f7c16baa52070a963405f115aa1a627350322077063a4d16a5329d1730ad9d02d7f1a2c69eb527582f766e9f3895abe85a22307c109713a5ace6ff0bbcb82c6f3a1fab5bd640e122571f1d47d85ae85daaeeefab990396dcbf359d1eb4e2d31e6fe8880a10965774b467c14506c40fcd79e01abee68ec6a2d00140e8ae05e3aae3583ce3ee4f2c253967667cce2caaea5850866eaa4fba018799e6f820aa77708ca20439af2a8b93a29bb2aec22273169ef05804893beefa0d2303e520a2d39276e1d51a7f0247cbf6cb79e16a6095c10d7910789e3bda26ac3da96bf0ffdc0143f1f4c3b2d7442f2a4d2d2b6e44a1281840ab6768dd63d49158a36d3ee50b58ea42f29317ed36a8b3ae92bc0cf8ce0b1d1bf4b0ebff7a9d11a5fbc5ecf5d3ee6a3eacce8d321d11fb8d999a97f03f301933f1ea88863a3b34e7885f1e5df5aa174ccf27923b9fdd3017b7f87ef19964125584dce4ff7cc68d26b5a88c4a94c23c8e56a559d778529382af5922b5c37bfaba45194a8ca28f4d9bd69d5110ed4b7957b06df2ff4edd079f42d4471941f5b30830b067b51e6860fea39e6d0b9f545135eed44b7b2bad6d6b1b1ce5a4de570dd82b1c2492a9e548369396c0a0a88069551f03614aa58ca1c6a11001217382c6890491f434b8bc37a80f20289abdeed80cddf4e2144039bd392a8033aee7d25019e004fea5c5bcfd2e5851d304cc5fdea93562b74bfad3ad2c65907786c0aea421151340b3a058616e0c5ff3d4d970f64b1cf1c62e2a891c694ef9f71db0e780ec875562eb3d833a18c036348dc94fb52c0a842ac0412dd4b4e352f51e9a6c4dbe0d2ee00f62f9f87b9a7b3aa507f4a9d8b10f6310c01df785d6daec05a9ea009f58cd17adf0e2ef732e10b0574c6e79245da6d12fca112fe6e97fa4ac509e81376a5fcb5f0bb410d2f287f6cc8be9ea90bc60f8bdadcaf16d4c44ded9a4d202ae7b6dc791f96064ee3e9b23313230fe8e21a3918e9c5b00ed80ea0205e951a77dc82e79d51c95b28608366516a27120f2e9441bb0bdfbb28070d95e7fc007fceec387f7a3efe93c41c15b3bdf7e72d6af8313b3ba6cc1a09939ac2f9344828edb728d9d0259b6ee592b409bba57fb84dfb50c82160775448498c56b39bb36b967083d6798434a2e413c4f2fd3da5277416fa7da231a9478866ee3514d31645d8ba8268aa7380935494f6d6b6055f0d19068f8cfa0dd18555d003404654467345027bb2d3bddf92c7d4fd46b556f099619628a86ce5d50f3bca6921ac111ec5acf9cb41ef48a2e28d68cdbfdc86a1464066eaead11c8df0c209d541170efa61175d74a8cdbf250a95f65857e396ab7ab87d37b962c1349496098b96d1d9a4e4d0fc0c69380c3b753ac8158095600eae6886fa61876eab302f60ba3203fdbe3159c9fd19ebb4e596bd250fc2421b47c111a9201d283563ead3eef58a33836e9fda5c87a2a25ec4fdc6da3fc2c51e94d7fb45f4a1ff6e48d69ea33924c75f62eef38961d3651cd9d4bf0c401075b1e3ad272ba613b63b8c62c71a71cd7a020f8605e8547ee32e01592e42abfbc73b02e5dc7c71a440fe0a4b429e489dd0ed6065412881512cff9ea3eff255fc2b09fee537da3a898c4e3abf31067187da0e8cfde71ae087bcad</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.3. 线性回归的简洁实现 — 动手学深度学习 2.0.0 documentation</title>
      <link href="/2025/05/24/python/deeplearn/250224~3.3.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0%20documentation/"/>
      <url>/2025/05/24/python/deeplearn/250224~3.3.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0%20documentation/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="a80bb3eb76826986e9be24dee8e5181c361ff9121986ed17a89d9a87384de296">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60e5f9fda98f86fd38c651c3f8f0abfbdd0a6088a45091d466dd95dfd8d18467540188f42059ed1cc831057111030ef596d7a614f06585145ef319391037d90987d0c676ce32e3c1101d40ded99ce2b6110aa7d1617a0427b35824bb44e9008c2d926888490de5c7adae48c8e16df7b4142b3d03deaa590521de9b27e4c8c08e4face896d68f97a72da6a5971850acb8e5cc2b49316fb6a5fcf9abe57809e2161a0a05f19c340e5a56820f98ffd6d8f56a8ecc2cf6d882ec0c7cced550c395ac46e7694624658bac82944bdf83fd79e1a0b175883b4c455eba8d2b15eed9d19896cf356b052eb347425793d49f284c49ddd544fd04a7ed01e3e777e9dc36c7941bb1650a6db84a9ca2a8d9c23e33ae04140520d1dc03ac272f183848db373d036d1ffccefe58a764df7edd65991c76f9656645d73ecefaff4dff9bcf48237f51b9eeb9a88815557e8705359ec0077e7a3f9cbf90636a062ba7dc09d24c83d6f461fafa8673da951f9f91d9ea2321b6347c3ddb08754c3734cd8055834549e12b11ce23fddeecafc8704efcf060176ceaf660d99c9bbf766b2e5bd6bd7cb5bf8fcd3fe63c28d963cc809b3f73757e847cd2695141dfc8a0a09ab7f742542f10efc76c310fd8cda133a1f8079dcc1f147ddba21962e67edff5134009412bbb276f4261e2a008d010f91d7548b9d87340b406ad5824d3de88ce9ee72d9d3cadd555f838d940180afe6f7c83dd44e732f5229bfe9da636cdaed5125e31577b6e105cb4673b0d79c1cf46215080365fae2d10c21eeab6a9f3ed0f508936afba3dd2345a431bda8d53b5e914fc8d242400fee2028cd7139363288840f98cd75e4f39f5902664639496564deb842e12e02ac5ad86ac90493b1697cc6b98a56fa276860d7cdfc9c12afd9438d2886cd5a8e7f24ab53a69880de0d075a9778f8087813ce4cb87d57cb2e605b8f6610ba1ddb4f77273bb4bf4d8a84a03d2f14d50b07a1ddee4ea1b65ccc381125d7ddb474e04363df94c1cbf1e6c853d8de47351907d524ed401bb71f13250f05e9122107bcdaae1f2eb4c5f6c1ea5fd786017c71e64d0831a0250fdfe08ee6e6413bf2ca17b21a3687f587ae52718137fff4539abdfca2ac1bd167fa34e30cf53f3843b2dcd42651d4e377b6b9967dea1d29c6f0b32e7c47de97a8a018d0325aa8a0be0c7ea19fd43c23226ed8f35223ee27d1673c653f2449f7f66b9ca4d24b7e9f3dca9449ba7fc8bb2d3adfcc05166764568b49bbd995d7165b27275e59e34ccb94aa351a16a4adb5d5352c60cbb3b307877880d0d6410e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1. 线性回归 — 动手学深度学习 2.0.0-beta0 documentation</title>
      <link href="/2025/05/24/python/deeplearn/250224~3.1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/"/>
      <url>/2025/05/24/python/deeplearn/250224~3.1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="bb63b8b1991191306c637f011f7cc2a19e2605a44977449a19c5dc193e83c519">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60e8a63cff3affdad4196ea3b3d2bb3e3df4b785af3711d3c158f5bf1dca36612a2abc35b220cac76193b063378b46e46291e7f1dbe5fc63dd677e29144448e05baf7b0efe49c2e6211996743342692845e057c2bf2d54bf3659be6b52ff08dd49dab586796b45fa28f77a8eb35ded65dc5bf42350813c8e587b42be2f83d258e992e4d1e55ed7d2324b32a2e9baf9ca5b4a655d945cbdb75162e78f683502b97b61f4cf8b2e7468addc63638d8594d8b53b261f4bcf9dbcab89b51df2b5009566017fbefc3bc8ee9ebb607586ddc09597ec538589dcd93b0668de491b723de06d4be542ee37e963e2f706f23b4ddcc926cb96c4b695d476954550ba6a7f04a3f746cb02bf1a20b84eb8af2c982b495982fe94245f04dd701817561d7cc8be00ecb7e67971674a9dc823f5e15c998cb55f14cbb5e9e98edd1bcd5ca2eb8b2d22587b2845b057b373ab21d56bb08569d66eabf0a3a2c27e8b407ef0592073a3bb40d5b46f8483b3e35e71583519e5214b6e7f613f2ea1026421d4398720ac3c43f985f0285b2e74cf2620345339dbccf4b558ac0132d12046263445f0b83b3a8d840254e67eb1f1d6f73f11ae71aa3d2d2e86bddd0fa524f6c21587f83f17d149003dcba5afd23e77c124d3755d9a623688986db6ee94c9c46a3dc422d6ee1f02519e20285e348de2c62f4e81877e2f12ed809b47edc0d607f0e0f79ce254a5a60dc34956651c84b5167cc0e166dfbccb95b3c8b950f417e064f51a966b1fa6cf4484734585c4589063579eb2d9b9843c5335093d563ad2375bead16784a824637f8ee0005a7fd6af3d2717677c4e9530b3d0a6dc1372488a3957a131689d41e24a5e2061748313fdaf19a0f63f568e20b484898f0099b44b9719f497144cb10c38523e8b906947c7c7905b74f1736655842e61343fd211b2920146a1a2ee6a9b97391314b414cb79dbcd782d38d6227542dd52080f68453785316e597fdc018b7b09a159dde01755bd35aaa72ea63f61e10231fce6935b93dfd4a55f920e461a8c31bdc6d25432e07d872293450831cfc462be7847ba895a978754daa1a9a5f0d266c8699830755cadbabaedaad2f5b821005e1f77fe3afbd0cf862e8b91668910fe17620accdf62b1d830a7612096f190bf555077e08416b73f82716d5f3f4778fc6a307cf6a39cd37cca7948331a41af502e01258c43102ea988aea0eca54981cac6ad3eaea7fc281013f8b61b510de2dd16c861b83b1021adb4766b41b3e0d4304ef2744b1d4267e32447783b6f8f8febeb80b23c4c9d8a7b60bb30c39edddbc1e3bf2c18818c54fcef32a302d4a78c5b7f15bcbe3710a415a6169d75bcdccdf4804674ad7647826e0fff380b88eb6556bae79ef3c99afa6d05c7cb41a0a3c08756cbbfb7c4bb5c8db52975e26e62dc1663829ae06e7e613844c28482e23d11871e627559e036f129d812c3470162e2e62e91afafcff45d7654753e7022329b7d9f9b6c5b87a2aac6d8dd4d6890016c798d31178ee39f152fce3b5b5451c9ef4d96350dfd3966ad98a8732c5e84cef881baa1cd7d12b1499abbb908d8c96649c99ac66e2aee3763e9d8de9aea8fe1c347781bb3c34c0722c1e554ea0258d9c1efa9ed80318c80b4b849635fdcc8027070e26591d0324817d0cb0921834d77faa1a119bee04300f5da46f3e424ecb39daa93c9df13b4f27554477f10c8ecdeb6215f0320fc712146ac33ab3b892eb5a2b82465ce815beafa6f2638b60594c1ba60d45122eae9cfb22badf41273f2daac3603ff2342a6ead57ea085df825ac8feca903fb9751877186b630856f301c505580f98795731ebfe8b1e1eaf8a2af1fa6966aadd3cf635f4568023fc5132fb9ccabd6d980b1f48786b1cc281323cfb0b80d4af1b42c8e87726291bf8c28cf22644bfb2df30b1efeea646a068db0a0e9e4af061a2896f204401a1bc593a8d479521e5f27501459e199cedcfbc14005d5a4c71a9f27b77a60c77e7b9aca1cc7aafac81feeb52d6bccfca441d7d5dff4863358170654ee74c9a8f4dea26fb762724901ba4885f0bc20b8c7679248ec3863fba68a119f2e41fa4217fa6adf19b6f0603f4a3786ebfeb75554b90632636fde1dad6a958e598b2354de49b0c8c1f0e7ab7eb5e6c4b27e19f4e940bc8b07b89e5f2e7a71c7ebcadf974808e61bf013310d00bd1670bc0799903e9beaf94b6f89147873e3b11c21a332d5abd510c158525dd4a4e1481016951bc9665cb9183f0ed5a7ec929b0da1a71efd7c55c8e65a75e4a5d498c0e7dbc8bca37bcfa3206d37122ea73857cdac6b72c88ccd8a9abdded0053914930f8be3d98b5a7fb2db8c8342b50604754d2eed9a940cedad1745ca0ba52c43d7279753d947b99116058609dfff3f26a80b6c478e6e749b668ce48e4e735e9b6818b99e7d37abc5775b1c2dab11203c746964f416304936d7b9eb8f8bae8947461748143b5e44c69f3631ddfe0b265690f80a0318b3a8feb07d3810aac798df424ed519d9a6f4ecf732b3f74b575e91a0def2868cf3792f86be63d732cf7bc9b044951d36ac20c3e44b78a6020085c9b30fd174974ef42912bb62dbca79c7201794c5ea7f8b099d9d90b0e9368d203898b04ca1e2a1947c50df31cccab8bd1535ade6cf689a635e7872af28b0e339fd7798816c3bd876d61402162323a43e6c9a4e2bdf65963b7caa32f2bd35f0e9eca349cb79c2a8b1b6019c3396a02f6a4453030b084c1268864620817a91c528973a11fe322e24890c6af0d1ef3833eb9bdf4a3e581c18564f606c8dae0ccac0bddbff6b6fd91bd88bf0c812bfc913ff4e426fb003c514645fda8cbc1a09cabc9655e21e0e24f19146b07fb8dfdd17e1adc0ae5e1f24f95e3143a1853a16ac4b86280899d94023cb6984f7856cf778bef3508e8a1b8e670913953f20e04c007d308d5047c7f78bb2fe5c66bfa9af5a758fd95ae12454247ffc183ae50293348ef4fdc78ca2d32b2ccf653711e555ac485fc924c527a7aca03de0fe58040bc02ceb031cb938208eb6ab512776ec58f29dc3d95ec5fd394fdb60a5ff7b69fad2712b5ba91e0b530c272a116dfec4d1ebca43fbd049688fe2b2412324143bd2071858e2c7ec497540d0ba59e96dcd95c870b2324915a87186c21ac3178a552747a956595ab94c91eaf3b3fa7d21b8d2d138fc26a3c13ee097d78d4ad71b22f651e4dce114a8b22c428f480ef5db0b0bbc1ab9c14c40e4a60c43d179c8372dfe181281ef619cfa511778f389c806e8ef8e971f6d114e33cca6d54ffa5f3fcae67bd926a1c52cabd15aefbd8a059d2125945bc4b838f24b90b4071850812ac2b5435ac3f21d619b422936e01896760ccf423333d454b0ef89753d077672df9a8abde78bad37e7cb2f490a5bbff93392d75e17eb1a66d45ca602de53a9eeeceda4ca772758581338932fa4badcb0be374375ef88af4eed38ccae44d130b6c47d026694de20a6cff5506bc0266c38ff57ed85aee0fecd78943bd5673cffe21bc0f33da00431108076ecc6172d52d2f586be60be56a7baffe03acb415f25fdc49397f227874cde9b181e9ac5adbb25fb1a5b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3. 线性代数 — 动手学深度学习 2.0.0-beta0 documentation</title>
      <link href="/2025/05/24/python/deeplearn/250223~2.3.%20%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/"/>
      <url>/2025/05/24/python/deeplearn/250223~2.3.%20%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="598a14e603568bbb0260fe566b9570e1768a7a93060db5010aca274aeae905a7">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60e9ebc76c33cede934e6003bf68b21abc3b83b81eec0c34ae3b45f770708dd5fc18e8f208336c569c89aa7b01c3eb270b6062dde53e09ac1317e2c7cd64ea74e31cef9d9c06345fc525ace5089dc16d88543be407e989d8d9fad755fd2e0f8e3c9fff224814b5e9500a16b3627741a998434f2ce4c086c6a9addda5d7cc6a303607bce37e27229cfa70061a2536c182a31458d87364c57d8beef6e8fd331ba3f3bdb4a5b7ce82519f82cdbee7ed8eaacad063e8ca2eae56bb19bbc6fd245ae0968ea49f4a2f2bc61578b60cba5b8b3da1216959ba6a1943b6653a4b4889d2b896e47f6181afb134119fc0dcef896a32dd3069677906af83a1b3625eada92a9c7192ebba7c526465b147ee0d925bf1aaf6a2a985491eb0ed8cd36ef0863a9a279386e83b36e082e88712de8a2878dcef2421e7df001714598d736daf27d25d91c3bebffce5bcd9645d140065140a235325f3f941dae6301f81c7398f4c8360fbe99c6bfe468ea9288c3e9eaf4a12431d10c7d2e4999e131de27bcccc55d876d5279c31da02ab9da0dd3c27847469addef2ff320df69c013044ac7c30fb8f8e45921d8c4377feaf81533e93423aedf5fc4b6366b4cfcbfe2205aa03e10892f61b258b21b97a9b1cc662ffe4ca43017fa88a340895ab077341480cc4e1a03788eb17290d5a925339eb86b02b23bdf9e286258ea3d291373a7ef86a6889081e6c87a82023d8c44a284d5d497a8d152f74208803cbda9c7985314cccf2a4f2bf677cff2e1cd6c5602455437f5b776466fb294578010a7abd141f9704f2a8ce94b0448673b3a892dec78416cba6e2611a303eb377c5c9b59fcc6c8e1680ab670bcbe4556b87dbbbf4d53fcc76e4309734ff25272034186cde3098e172c758160e8860ca509ec1a054811a7b2ffc1b08210e45a8bdfe1ada57b88a591301141d44b6fc5fa6b756a630a8d8f8346a341cc7b8132613bac3edd3a87cf9dfeb457312e1ae7b13b8c20dd9b9d6d5dbbab5dc9403085e20659e681355501ce4d64e5c1aea79ce634b3600ac90898a4ff36f2583010958bb4b27809c0c1a37bdeb61ea605c7f065a54f6f50ed2a37a60b1443195cd1707dc5417be1f4bc10f31737d71bb4b20dd5ea462a9c1b1b0dc1fcabdcc0565397fdf4eb31b5ce9a641a6f475fbe3e984d2d1ca8ea2aa67f655c4c047103d5e275076994d18211fffb50b720a375267d5f88ce9cbed6316383e42e0797c215ba75d3cf944aee3c6e94f7c88d2d11e29e110bf155b9e17fe14456940b006ad6da8b2ff346d6a3b9901439c8d47fa39c7136599a970bbf7bdf44fcab9e489c58a74e2c5bd1c320d3043485a94d85f30e14c6507affbe1ff5b389fff84476b6fd868d6d3cd976cefa6ca7019de790b0e8a5d1ea038ee1af4362b10db3a0e1e0b0816a0caadb0a8b77a7d48af4614dcf972e4d4aec4e4b3af86af2e1c7dc305d7189cb5376d5f134ab5977541b5066f6ed52274e6421b7997f9a2392c7031ce4f0296850e8a42a670c2e568818691643abb0309f01c500ba31f6a2d874ca13eb195f5009fc46c7f514429414007da09302bdaafc7873736a14575a7264ad908654dcc3c170125c695ce54eceaf10b7fd023cbc5a1f4570df8e5fb3af181efdc8f8baa48e067892ca0d3239d8f10cdaca8aecf37e4b7de2f37d37b1cc6692e8718ceedfeee1316ebc2e82488afc9cf273aed27004d17a719385243f130ee898a0428b047f5ba26fb757fd97fed5663c8be74303697a9d0df043adef8df77c5caba2ab655445d58a39eb2f9ee6cda8c7e88efcf7ab7fd946d2be2e375234353eaa9d4c05ebeea6c7b92c2517abf346f443dfb4fef46e8601b7dfe68674a614381701069b5050360de5f6c2d5c8ae05308a21833b02aefb068d39d0650a2ea07a8f8ece7ccee442878dea2716d2b940036fbbaa24de809fc39115169e90bda24112dbd3867638d4bf82645dbab567294d1ff212854c4ea8dc90429e6025316b57f5caaaf8ef27d974e3fd1c2920c5fc5b67999ce3fbb15e4b1f0d07ec4bd1252ffdac8a4dcc5dfd65e4d80958fce59c26ece4e759faeb457227a92fc3caaf57f37524946ceb345e0b0fd489ae8000fa04da4b3363f1ee0fc5cfbd30b39717d90b6a1e30d6fe6e56466a5ad1d3d0c247b75cd117656f40b3aaea94526a1b4d2235413ab4ef1a427d2b4ed0997b5052f935ab18af290f3abbc8eff219588f0cddd7200a7a29c3a5c1a7820b05e6d6de9d23dffcc5d8d88372174d5b6e0c8148388da2822b1573cc1851697492f6b50ec535785b42bb49050c0019be69df69229c63cbfca7a2ee6e7af47a25924a00f4d57010657b9dc86c8c00d74741ff67aad06cbeca63f2a3532fe3b1321cfb2f40d410d18ada783f5b43854bfc11995d068d25c717e79cb7194698aac5ed7018bc7995440b7ca8dec864eb42759b3b2c00c782f43c2db6230e841f8e19690cb1bab1ec9a452aec4d93adaebe4a2d40feba2b091dccfc07230d434edbc98a08b47188ba2d393044ac1b114e73e1dd3e9e3bb98d454255fb24a88e3ee3da3bd2303dcc0a92647f073fd7b8eba25d447aa6ccb4fd34ed295dfb0efe6dc1d0896aec597a6b6f5789b33c0847ba925c3adb87c8ed8620a6bb7da423cd37fadc20abf3b18d1947548f3594f4178f8ece4bb90b18bb5a8457ab33bcc3612ad14170ed1e1f7e7c4106a396557a409a898eb4b5811cd76162d34e672751ffe65e5399ae812ec49ffa3cd872238849474941051459c8c3516d3e8d69c645a82159d4829d48d4b9b86aff8d14e61457231667774df8788521f965c8d9978917d6b05ea6dcbd7f4d39c04e6f61b7ad829a07e99508ca866d43b986824b6d32a8f770a1d45bab4a67e5a5e2e675805a869e1c537564a5ac936041e2422a267cdb7a33c237f6d59fcf222e9a59f9e58e900d813cc8931025d38f10634c683e182def3d0126479cf571beeb2065144271808a88c323a2f927ff0ae30bfec627704ec270fc96324dc352e6862b4db3ba07741695ffa050e2699522bd7d1be9fce9d34ceffaa216c414c48b9b5eda44ca6ed54a92d968c8add54d9baf4a7a28e6dff6f87d45058b44e9c9bce391c539673ec2bf287be206cd9cba027bf95842de228629f9366ff433df38c59092b96fa3297ecf3f312a5509b17974606c53016429e231154c50ab047a947810d1f819d2fd9ca072d4d055dcfc5b137e02d30818d174684d3fecd3877c376cdcdcb8a0930565c7ec098e2df87c7d95e9291f0917219dfa7b1b07c0201e7f775835ad9b88442014035131cf768bb2b1a3f8a1828bebc1c9f7948b002cf1102cb874b40ee665c4ec0cdc9126947d39bc305a1cd423cc4b3e231447bf48277d02732406d539afe2d35c577f8703aa76b9766eaff93896baa230afec7d361616a0dc09ae49c537aa78e2fcd981110ee4252fdd641d96dbc7f569871b8c88e0ba579042fa14af01622e38b4c8989791777ad05b01fdb0f34508dfcbbc26e0dc3a6b29c6d5f790d14b3eb81337481d580850a30fe54175f00436b07a36ea96a5c370e1f25db12e1f128079ec209c5b2e9e70140f7eba0d8852c071fe32babe3398cf69a8c4aef66fadd2c06bb0ac2134e972226110a922103236781996e1d01aa7c9472b32dec214706a3267fae00928b880c22e5d1e3193be9f3328ceb0a98c7363d072911d3acdad15a06dfe99581b405ad1e3cbafc16c7348ef47793eb90cfb359e3f6a33ef7d435a06c0693b30ab68b817b21278d69b64492e3b9559ce67d3f69d2aead41f2f8fe8d3fbcbc2f65b86675ff2d7c95c47f1c3d9b80bfbfdaf75f8b78b02f3e6961fde3e994351d6601844da5ea1809ef38e09dc0bef1f14fd9a7a89c94dd03645f507fc3ac289d15eedf506862540e788b46717dd5688a1fadd15775f1bade0986875eb558317adb267bef0d3ab29cf27d1f45ad107817beaa0dbb3ef2330f928a42f312c19c5345bbbe978021ff7295af749cf7dd0b5debe5336fa0dd3df29a74ca2820748a6c657cef23fcc5a809ea5c351a10c6e2c0f34867428142beb2932d607bfdaca72635500a852b50a1afecf13b6d45ea49eaa68e511fa04dedec969c3a81c5597b955b1edd7830e7f0ed837677b4e875f86fad52de26f8c74ee4d5a5b4131ffaddc9637d932927df13fa42880145e8dac0c46777e17e4a373496cc35b12e25996b1dc05062d4dd67edf3c295c8a8c407aecb3478c291163e091bcd471c7523a2d8f9c74aebc534bbacad67d9c2eddfa8a412f4432d4315f56f3be258c8f47d7ce2dbded56a776c3fab2e2a856495407f02aea259d8c5fa6fb3dc1ac34a5deb849835a6670f9a1bd9ba2a9b566a88d5eee679b06288f4cc32c31fc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2. 数据预处理 — 动手学深度学习 2.0.0 documentation</title>
      <link href="/2025/05/24/python/deeplearn/250223~2.2.%20%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0%20documentation/"/>
      <url>/2025/05/24/python/deeplearn/250223~2.2.%20%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0%20documentation/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="aae4e1800acef633df349c7da6c7539cabd4fcad509409a65aaa0c9165023ece">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60efd52249f16f8437060cda3c52d08cfb5d6b84549e44134207be9bd8865e14be3b5f7a3c636e2481089da6dca79bdb838cebf411737ac8e75c3f955a9344b9193557d7c76b8ac259d165d13ab558887e047df13b03d8a5b486a4cac1a5ee8a36e7ab78cd8ef6af459fc6826cb4175f99c99bca619778addd0ee940de51c498ab66d4d8e32bb29b35a4c89a59286074151df25341b7bafe45d12ea78d1eed76045b5af7732ada952345440452f487f45395037444940f5195a09e16ae34165b1fe19c2c31be0d1daae5c357941bb0576d489b333eae872694765ed1f8d5dfa09ab7366c4200673f7b1200786f79d6711822c6eb13f7081fa88fbc1340b737dcc87bd6997f3f7e7f7d5e2db3f189d6276e0a215f4b35ea20155a3bda9720550f7b91e30ad7a243c658f7eebd0d95bb1f642bc0451c815400385040dd57b51130324cf484a5c6f2f080e8bca0164aa08892ec8b91bf071962a4484b36b04b503cff4bfa6dd2ef477b00bc194359054453a8216f17ead3b572bf826cb2c7dbb980753c0bfd96a487224f7ae492de34a7bf36647b1a74859a75313a0043e242b8831822c55b390dbf70b400fe4a4528b0e9999c2bdadafb4b17e8d27648d12a51174db</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1. 数据操作 — 动手学深度学习 2.0.0-beta0 documentation</title>
      <link href="/2025/05/24/python/deeplearn/250223~2.1.%20%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/"/>
      <url>/2025/05/24/python/deeplearn/250223~2.1.%20%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="8be05a1daf89c8836caad12188770b112e5c10a7ce1181ddc71bfbedd2dcb962">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60e14251b1bfef4ab10ba5a76a7142a2866f9f7f359bf571bc859f507e08cdbf002bd60053e36b8d7ca5cb7a57d727178f182389b3364930a1c501b8b53b923ad1e9dbc49ad0636a2dc77664159f39cebc3da3de85895f78b07a97af9da0f52803cfde91324fa20ef449f5b205531225170b46070d3688cede657e14235d0cfa01429ed46288f0e6749b80cc7b5ac1f9c225c86295589ce9e28aaa2550249281b071996cfe1ad53aceef9c3745e8121f08ed5476941a327429075681405e9fabd18f35173e4c636aade02857d780172871ef1784b17e362b17c15f65b211280fb6e5ef24edd6152e2a8732b7e51fce2843a35175a66c81184638ad9e218d8b50162b4f798495f3ef9b0451bc3b3a4c9ec4aff17aae273b3a05b0d8034aa0748faf5d3f3ec80f229473fd8c756fc3d28f85d44957c0bcc98543e937b31d5d3a288d28ab9e3c2c3e24b569bd82168ee8f84f1b46979f94b9d4261c6900687050fb7bc05a60b94cdae1d1720d00cb7865d55b78ab6f68f30d78a3ac64d8f5d2307777896ccc65f4bd77007de5d8112909187087923e776a484c8093117eecaa1eeb39643a3d18aeaa74d4707ba1d50e1fe40bc62c645c1bb722715e63c6797428c2e41e5128daa49e6a0356e99d5cf0cff4bf6638c24603ae2a47b32738941faf7622eae40def345309108eab9cf5edc33fb3bc1aaada4e87dc5501bb3c5d908501ecbc8760f3100b1d99665e7f1b95a1c14decc003d1607a3fb8fcf9b79a8ba28b6ae7aecc9aca1abd059768fd67081dca41bb907a768bf191009105b7f94233a76f621d6aefac2cc2e6a0733064d2b38ea9892de1dcda98ae4576ca9bc1f64df1e921f25b5ec48261db1d503f337b6cca5e0a53641c8ffdb6691314a365b4fa085c6c90b0555457f356ce9122ab6696bb70951508b5158c7c30f9e86c14b226781fdb82a25f9acdbe69cf3460b2672028167e0a61a6c2b8b09a9dee922d1283b8a7447d7aa0a3e183a1c4b353be0a4bfb0cfc42c3e9fcde33fddbec955ef391c39fcd29abec9d95664ec74a86fa2dd76d7038f9f30381fcb9249c8461b4002a21c03d42ac67f1f39c88a646e80cb4f2254844fd37cb42283d7e603e9328a66e090aa96392f73a0267786d044ec504d964d4eddc9774e9df3bf035fc1a0776c8967b388355eda3259db569db68d3d7b42b516966624b06ed6a8752626ea5edd81d7b556fa7b4f0ce1bab440aaba84ba75dda9e59e94d18eae083cb501e1447aada9fb0871e8e96e30d6a65c538c67513621076dcfe8cb48441789d8a9b370e7431b144742bba64ef18c7e396f2f6b2db51b99a7c63e798f394a81139fb759a7b6dcad2d78a4286415eee5709f0e9fea63bd3c58d852cd0e4a522bd5adac42e62efc32bd3b44de002f3e4a9767cb3afb263de1ddc890271f7f77aca2ad0fbe1ef900fdf7468fa7e7412fd274ea21281f771e1e86c799c53dd11c8be2b7b482ca97efc39f06dc2c4ccd44b6e2c6cd0dac59523bdb7f779688e2b4dcfec99a3c67ca6554b32e56c972eb6742e855fd589d162e2190306539d859ecf059edebd88181fdd86e4007bc566b17c8945ee5c6041857555342049b19e4c8d8f75ae4b4cf22cefa080fae0897145fa7f96ee0914765c999eb25ecb03ea08c13e02077790099d5c30b931749d34b64aa82c46e985b2b3b8e58b0f45a9c02b793b2901b9bea479baaf8030e5b590fabbafa9fa55c6b17eab61a188f57d142a9ade103de4055d6dbb7db32bdb5bc6adce128f17eec2fc7d46e3ca8d31d9b9fb71ff61e2649406c84cf118b4e370c0c823d0339343217174e7a5bf45ef01b4614cfacc1206b1a0964440573bd06b78b68287ff59a33d5c0a713d1ecc9b7e15b01d9a3b438d09afd37a8461e5a57a563d615949bf12ab177b73c947c5ab4e8a77e0e6dee92ec7a553a62123679c9e5b6b43b24add45c5eb4997cff18ad139f85afb0c960062b4ce76bfbe5a294e097ec0914f6d48890f53996b512e7122b93c7f7617459fda0f0d0ba63d298e4f33548fc908306a701bdbbe770168fe052d6f5b87cf0b880324642ad2cbcf6225b3cbc066a6f28473f262e2687ffbac0d3530dcae46d7220e5625d58a1e443765465cc63830a4e2f633d4848aff35fcee7c7cc42bf4667f10d47f92e50950005ecf7a64a209c8eb0128661f96d892517a8095d870f6bec909cc3293b779cef8c69774df4e48d76f5678d6097cb2a32de1c599fbe3036f9d331660126bf1692394bb8ddb315533f6dfecc3620cff5b28987e323544f95dc392df59b109b232bde46fd84ae06621e838b62fae14c15afe25adecac8dae189e14b0fcd5758870b1046690bdf1acea12c37475dd6d4a3743e4a5d1b4e26c5722a6d5d3ef6a1792fcc05bb5c1142dc3adda9abb0d09bfd1a9a258729ba82c9dc3ff863e62db41531a855d66189482b41b0415b1206ec0af3dae5886b8104f56e82ce7b14d9ad0c39c904257e2e0c7ec7920bf51b59cb0faf0af5a32c183a9380d19c7b70188304d27f411a437720c7acc99b96fe52a882bbab2b34563edef798595a436e92d0638995a32a741f2a1798b0bf3b98bde3f7ae809e4feaea8e11c561590b5c0e89db998d64bc86cb4bcb6805be9606ca55bcdcdfbb738d4844ba133458e415c055ed1e862c54a2c4fe641bc97a4f3cf1bdddeea889f555973d411767993c4ec3d09228c760799b05ed8f6502f20bd1167e7ded461024acccb2fb064726ba2cf6ce1c132b55ca7249e25787e20fdccec0040064fad700a56200e5d4ff285c98d39dedb73dd6fb11d5f3dbd9f9c863a73d63e580a9bd947125784a20d522b8bb576973eb6d3040985a59e8047f7c85bd290168620f07f9df0b51de02f760b85d5a8a0573208bc08621d7c1ddd62ab49f7c50e5a1787208dd625bab565d92d2d477844f6e2dd354d538ac6a9586e6ee25d762bc751d98b8232cae0a371d9bd00e054cf2f1a1b7049f2f19d20d1289a7bbe5be2565e16993715798d8b874f33c91bbd5303bea292b4e02f897bcf728624b7cebbfd9c35c9305c3e9c58a2168e18edacb03c52ccde0aef0ea244250e28fdb2765e32a8773e0951555db49e872d3657feeec65579b004be5453cba43e905499e0dc56e283fd3b2d724cbc33af5c3a53d57d1bb6ccbf1c0a878ca104c9b1a5664e1a3f4a3bfdcff471715242cdcb65c5ed8c22eb0011e028929e565e1ca7918cf22cd4b636825d25817aa7dcc4b8a3707590389d6f9e638233270f42b94682c77cff7056c9515b7d4c01c1ba1a0338989dd4ecec89055c41ab0e5a73cec142c3b21983ee978d0208a7914a5fb0664d923fea4c3f889efacd02a0c1396720638c46dcd9be9c03e5cbfec682c1dc1aa71211985c153056c0ee8d6decefd5b42455dc8904b152db7db0dd772945dfd6f4d0b18f6f883df39ce18cc34c1de6f1b6e23720a19379da9af00fdcf59cec2b5a0d2ed756d14efc6fc6c3207d8d652263c5852512783feb8babd5f66741acda10fd369</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于本地git通过ssh链接github时 time out问题的解决方法_github timeout-CSDN博客</title>
      <link href="/2025/05/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/250218~%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%9C%B0git%E9%80%9A%E8%BF%87ssh%E9%93%BE%E6%8E%A5github%E6%97%B6%20time%20out%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95_github%20timeout-CSDN%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/05/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/250218~%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%9C%B0git%E9%80%9A%E8%BF%87ssh%E9%93%BE%E6%8E%A5github%E6%97%B6%20time%20out%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95_github%20timeout-CSDN%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="e1ad28e67c8e08c2eb48ae4568b9b7c429e06d465f513c6ca8019ccb634b9d8e">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60eba450451260b3741c5d18f11ec897ce5d018f7d34c82e033479c2e232508dd65d0020a3f66e0f817aa5f3d84f7606b23c0a979871bce7fba58e45379fb206c7d8d837fcc3d48da2354435c27c77d3eddb080cef27f5cd693ca180bf639ece40ece9ada0381d43a57d845ed71d493aaed41876aa9104b78fa83dc01ae8b935068bcbb4ccbae6e39bef15da82ec6d4a972389387136a7bf7606a62601470ea70d1a1c2b459ae336b936fd0b1a438ac40f9df4524db490e15b754f909b2349db25ef8f9d6b920cf7277ccfb8a42acaf2f8acdf7402838122ac1383e63ff12920bcb47d511df48c7de136cd6d5b602125d0b5ad9663fe6d1f503bed0186ebc9adeda408664efacb55af6b90d7b243faf67cfee36c5099e08e36509d5aed6867517c7dd3688c4e870bed0403357504bd35dce2058f08bdae4f4dc7dccb34e772a4980e04fb01ca26cfe6a863ec5ea129faf7d0c726deb15c28f8ec36b4558c9880f4e2232e3aceca95b656ab1e5d99b1c970ee4e8b22e12ed45ba576cb8e163cf1f8ea784e77b25d762e00827ea23bb3935f0899d5cfc43eb2bce0d57d6b0dcdba4fc52725ad8049630b372c35ee8c0d0fbe5258c4f53de75b96729a060fd4da20632646268b161891231b1e7956c5ecf9e127ccd301c6f19d4c59c73632ceee7b112987de9d4b5aa4ec4aad2abdbfd705f653af95cafb8e70a05e00333dcff52eddd0b79603be65454176e8798535ae953790cf4d005b39064d9cbce2419007472fc467056ffb16875fa17ec0f234a5ac0855254e21124026d2f38df83983d1d98def2012835998f1f9bbe7b6b1f04b206015c90c15f26c6c606524c351b1c50c886fbb94272c3213f7d61031380e3050271a6210c05a2de69b6f1b62dcb7b02dffe6dee5f21033caa41f2d59e8a66c9cb1b3a27d4eefd7498092a532e948dba08ad8a521fe0d007197bfaf896d483214caedec47058b51d49fef69a0cd771c270069fd8840ec6ac5ff997033e18893b5692e8f40409e410748ef555cdf88c0d8405f537f7de8fbc5eafaf6d86538cc7d6dd81a4ee55af18982c3e623789882949b51d8aa1dbaa3e03225aa7bcc39bf2eb8d356dfcd8a90872604b97ca9f2a35b0fdc90f2968f53cb805d416743573734759b05b6c2272c853de99295b9411ac7a5e70bad421f1f17c6b3bed761d1ea17ea4561059c4fa1bbc65ff85e4bc3deb6f4054eade6de90c148586fa18c5814da98a67e2b8fe0ca8da6ced02755bd6ca5336bad7e2d013a058784ff9ad1db614356ab99461338da1763111e3e6194c798d9b05322f8880bc243289b8632bc1e9e6b670812e77ff7f62416f2bc087288c72d07f0e15464242081ae8cccc36e202068826bfc7bea31713e639117a2efd3be7e5653f96b434b8bfcda092b54738574272cb79a26177a0d2279d23df91d747017dc63803bc497d4393430b323d438ed1b5ea96e246e7afa320bf88551c97c7b9a7209c5443d6ed05c3d98b2b343bf9c8a8c6e9e165a3035b2cdc49224d2db95b513608dd073f9017daffb6724a65b7145b754ac76e50d5a20875814701f7be770f2e3ad187b3e7ced1394832672df45b2169e06b8c794d37967204000f14ece6fb2904d0fb8e8ebaae3e9c9d7ac2effeb2aea2595efcd6ed2cb116e5011b3161e21af6dd58ac7677e73873af7d40c49bbfee35ba452b79ad86d1aa47c6b7438c44a4605d55285881daf344d0304cb5fce3e2c312321dc16a1dfc24b51376deb8ffbcd9eab5fcf36fc75ca3cbee26c58e2cca5051175aafc2cb5896a20aa6383f180a7ae00df8b42ae2591b70cd4e170dc7a4d1387f9d45233d497d0de219d8954cf6ee42ab0d712812792cbef0445ab9c857188469c4abdafc192912038c3351dd9dc899d4e69e5f4cae5492d0595a64b5206d8cdadf0b8ee1315e21da1c7223306c93e2cf232c4c828dec34ea1a6c2f0c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL Ubuntu22.04默认用户（default用户）更改_wsl ubuntu切换用户-CSDN博客</title>
      <link href="/2025/05/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/250215~WSL%20Ubuntu22.04%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%EF%BC%88default%E7%94%A8%E6%88%B7%EF%BC%89%E6%9B%B4%E6%94%B9_wsl%20ubuntu%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7-CSDN%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/05/24/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/250215~WSL%20Ubuntu22.04%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%EF%BC%88default%E7%94%A8%E6%88%B7%EF%BC%89%E6%9B%B4%E6%94%B9_wsl%20ubuntu%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7-CSDN%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="6ffde551be1cef01fc5fe079e57547f28531669fa2d5ff7b688b9e78c2e983d9">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60e73469ab53f8a3ba7e51e054e23ce9e1cbafc730395d6dfe96c63035d86061b8ce6679a693a438ba67ef47e9e74ffafea45b89db152e678ff908801ad280eb490545febedb7ee5a714f2165e7b318b609f787fe6118bc909052a2fe1d29332bbeeb054df0491efa117c06b6386e0667b9df00891d88d4cf9794fac2a1d893ef4768f2610729f4c8dc6c25e081c59d6ab8316e3fb34ab1cd4523d1a7ded629cb1a0019a08a1e4cc2763b53e1172e0a1c1a005ae19c8f7a706cdf9f117ba0a5f2b3be93633d5153fbd853453ece446d341f7a49cd604cb7eaa19ae8c8ccc1b5a2bc44543ea5fd178c931e4f04d2e2dc0ae08bd0a9f8113008fd65142f7195a629041ddcd60c7e0ba65b1b6bf1119e50547c99ca90015d0e7b8bf4baa62fdb4de87afc712da195656386aba751c2b553ca2bc2736b50c31da1058f511f0e232ed9fb0fb5c8eff3833e5fcaaf2c6653f453f6d6bd6aa5688d5feacf65e8ebaa80ce8a53f41a2fb3191bebe635321faa91d9749d10f7c32ba06556c4424318c6a72f4a193ad3166276e133045ce59df1549578ea12af77793704748f6defd976d2ba287cc07cb7bf1e1313f3879abbb097b608c364f521fd7b7bc309402e6bd3904c5f74fe67d7e4cada4765ac2849bd86be933b50875fbeb4f7a8086a2ff4f0fb60e37dcfd55fcbd2b132935fec75a1d89fd950a7c43f08b7ab230ec4db139677050c3873e27da8fed7fe4e0d0b019bb00947c0d14240c4d911d1778ff6b55e0bd623170f95bfd12547edfe8e94112baca45f78da452b528951cd20eaaa79ecb130d40394dd0fd511e142cbe1f199482eae18dd522205a774e20f9da918a5ae77f7072cbd37919600c3304682d79c33bf0d311d41e5f40eb69a4767523d5a39d45b9f0cd213997f32c91b29d42662af3e1316efe9cf59e92558f3cf193d31033abfab353712a6d269745fe857b46ce7e30807776bfcd8079327946c3f508ef7a3c17302c8c3fbae5759252b264c7ad5294c00</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 前言 — 动手学深度学习 2.0.0-beta0 documentation</title>
      <link href="/2025/05/24/python/deeplearn/250211~1.%20%E5%89%8D%E8%A8%80%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/"/>
      <url>/2025/05/24/python/deeplearn/250211~1.%20%E5%89%8D%E8%A8%80%20%E2%80%94%20%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%202.0.0-beta0%20documentation/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="fbc8388ba2d42cbe84bb9448dd9f662a8dacda97e60c422c46ef38afc5b58a7d">4fbb2435fd3b6574fd4f7bd145822884e6ae3e59628bafabb1f9da51f33172901c4b77e24bb12a2b37aee9695c886ef344f3317669af1474ed80c9c11a71fd0bae7cf1f108b131d8cf7cfef630bcb60e24b10caeed0ca85f22b581d515eed0cad135bd8e29d7378fd2a48421a52224caae763039d4c33868c2c650efe7cb9fefeb1e3919f0c6188d3ff7378b012ab7ba3390d8712a6236a2e6d9c4905592b3dbd4fc34e0505ad925cbdc351137c0b4bfae450552e8a8aaad3c3c44adc4da81f17d6782dcb10928e9d40d275627ff631f15bac2dd82f372f2fe2678b9b58ff269d97a03ce32f10383a7b8bb0c03849c134e21afee6a1f699dd583df9e6444d7918f2cc895beae314c2ecbc76d57dbd131bf44bbb13255cf6485b1d0975f6bff753e6f109fb476bb98196179e257d4e8c2abcfeaed261541c3b5cbd8e6b93acf74a8d847a37f386125e47e5b668c6392cd02b25b91715c69c61080c922af02d4bfd04b71df729b45651ebef0a8a2fae283a3bc6977f60044439e9c7862db85ffca3596f37aa993a2a9fd03abe510ee33fc8d00d64afb6dd9d59b6d77be7299699014c0c4e5afd8efdaae8089b254d00f0f8a63331448ddcfc2ffb504e754484f76d64c1076f70f854287dbd959c793f49fe5b92e8bb8daf523466775430c16b4a36cd1e6823f0379ff1c31ab2f826a540adc44484c50864c31056f89e0fcaeea64c7e18e810cbbb421c7d3982cdecb2733564022239340dc93c23025d8c9482c2da677b958e4e527e6528b1653edff8d9afd3bf53711cdc801a096abef92b3aadf9aea010df0decf1d39636ce486526405dd789615e55e8b9866af3502c35b23346a227875a66d02d879b3a3b2402dcc2c65dd0bb6228d152987a0648e1d70a54f0db595f0d2b5a1f16bbbc96586f66c9678d4cb74737142b5d4ed9e29935a5d6f0480f1599b0e1337432d1daaca5f5f8a9e2fb50256c7423102087ff20289bf171d6d6769740da8439f6f226019c4e1389fdddfcb43d1a29a48e176c92cd3ed24dc36206f91322a3efe68269ccc35e4ee0e43239c53665d8f14eba0e9f3adee69b4981847ba6c8edfbe101c9defe314a69f2c6b4c170fddc9537de2be3515155565663d98c2d689f2659336ba7320247a66aeaf7caefbb0eb11cc7ba1b98fdeaa9cd0496e339dcdf923da801e2594434ca0aeae85ca85a08c24f6d1fc4713e3725ef42686a33e5964db341b7110a3f72e1d40a8dc7e26109fb2fe1f051db0d4838c3b58fd3cd6755bf3520e28fe6e8cbbbf90130ea22ee9703317d9edd287ca60366a45dd0bf0d62bec57fd043e61bc924e905d271ac46b58f83e3060ff59bfd00475f22c5c50e442936c492545d7894d5b640cea52b9b1042aae7923ba547a0891c311499ad2681fbc5b7186d33f3031403983aab9abb1aa02b16e88b28af27ce0c6cdba0f88685873a288690747cad7ac88a38a11fc2f0f41bdf2b31859817c8cddd16d68e30d408a59cd96dcdd9336db705396c7615b687fbc008be358e3f1d6cc3352984b326bf62cd0faab35e12d6d401d5f4a3acd5e90cf8bd0231e76bb2ec50a6569b37f630eb79bce742e06da7ddc896e7fff3cb05d7334699384fa362f278633879f600acb11571d5654b9ef2984e82e0ff4b209ac46f73e1051f295164187b5a9efa7ff6b73d39f0e351bb13a0aa8ed35a61bd3a3191ae682877085b6135c7dd50d713b2e26480c4c258cc7d9508273d72df66408f13b548d53693bd4740810b6abdcfa49cabe06bb549ed316519a62bc46820b4f4249a3b1ad87d6dfdbd9afa46b595b237eb44d60626734d62323a8fefeb706a5e9c189af7157716d5feb2bcbc885624a75566e180ac03ad483086542f760dd55325d2332ec6412012ddb0048ed4e41e3473aa9428bf38a7b9ba0b1b3da523a6d86f559f38a93cd8aa9185af4cbd8e45324132d922850840ef4756805e42280c1668e8d334506b5765c0fd182f8c9177ce221773936b0d7093f57e95d67e4a098a77a762f724311267add5440b6f93efe51ecfaeb68e34b05dcc05e1e6a98ec8f5418276aad36e2ca72453d0f091bfee8c55511520bfdbbbf18ca7213045dc6af8050a3fd9db3a5404e6b1f3bacc58661d158cffd597c4dc0b5754217aa25b3b2277c19de48c695ba4ab1472ea74e185a69da6f0d014600c535c6b59e5471c796146704647220b207bfa65b6d989f250b1b880b2ff0d321a11c07695aa4c71cc9448dbce414a67ce792c7d2efb4e6ae7d0c9e5c30924d9c3fc42ec41bc00d05888ba305e74e84a3b7daa406b269d604ab269c67917cf067fd96fb86c446b904989537614a9055d889bac2b4753f1698c8b599dd93d9abea423a84552423f95ab880f981301d2f01e3ba7313f0c407d66a13db84d97021dd6264f3d8ab1a0ae0259fc8700aeaa57578515b0ffbf034d58ac04d20c8895c830046dfa63dbabd7c764d56b989ae21181caeab161dea28afd1478ecbbbccf4f93b966551e58e6f22c0956151e43ec4b74beced1add9a7497da145dc1e98d10a30953fa57c1be7c41ff526f3723c09901af8c535e69b05f084dc39e17e5972b8aa0858593ba5b2f33c39e50b66ddb3a514ef3ebadc65d22646cc244d72226444f2cfa0c2abb5a60a771fcee749652865917a8dd7a7d37aee307bc91ba0f20d2056fe0ddd0c0a2af848c01ea758100f6d23f86b94e62148ea5c1fa19c5ea999bbd774771e2541ea94751c059d95982d71834590130902e26afb5b9ab6f9fcc96b404adff0d7bdf5634cc953766e00a4b6f97c1e76f3cb25edbb7d1a47c003c38d300280fcf32fbd598e560ef4902f1f06963bc26ef56ad808adb676ff29688b89eb9b737d9dfa70a9648a00a15cb37077f73aa881f177f279b518ab0904fcc8cf35c775a90e5b800d976fb0b361f743f10c77e4761f295809652241ca27f8e4301a9e60bb30075da221d2ef71b212930db901735992b33d1db3860471a737f580fa898ad575644e28f09e791f9151d29175b116155d615d537328a181657fd639be788e3889e8029046b740fa67540bfc2e61509d15a4280738ad50b6aeddb18c7b78be21e49d39241e4650da820987a3d092b8d9489fff2aa8189cc248ec5b017894ddb4a1628fb78cdd25105c0b74b92a832b2e725d3c6b8a6788de3fbde89f1f47744c22ba86e144b41781bc98654ebfc8084b0cc980618c74a14f61d6938af5a3c363a3929e064d2041f37f6edf21a5219a52bd1cb5eefe6a0ef15b0879611b715835608e2dcf0502fbd64e1109d7e73c9a72dab4aaf36c6399369195d9793188429597859d1f449f6818f580ed7fac3c49142c438c05476a0164b162999c6971ce66b9091f8c43a12dae63e5f28f8fe4a0e76990444fc6640aeab34a137fb4fed7ced90b0bda48ce75de7eb3480728b181b4fe5a908b4b74e05ed6d8e832534e9d38bc481182e6a5a6d320a8db5ffdcf275d6f4e8f4210c235a45ab69d53a719c3c6d4d57a8b97349ed1ec26d1cc5f1ca230fc16f50a0e1174514ceb686fe7fdaa7a265f5025c7481b54a72ae6729b771ccba513a23f663be5cb1cd82fa975832c8c46f2c5ff35d4262c5c47abfd179b6546b5ffff7a05499c8b02701051728dc9ffe09ee24750607a3be5c4374ccacb8d0fb37835551909e38c6e1e64e6d7286605afa2f7b3144254f385a525d47441e7ccaf4d915cf0579b92425c3a718bc4dcc0b4d6b18cbdbc253ec762130a88b137458b639e3587d78874a69aaa7705ce441b1f3fff113fa61832f1c06526b2061a2f41ca1d7d46129e4b5efcd8bd6ad4146fc96d2db409e34f297bebad2fed11aab48dcf3538ae718adb0099a37afedbbd1d9e04f50d3d503cc6ad9527266f471467ff357b383869d792857bb2a9354dd11dac0473ce14a66005385996bde6d3a140638b70036c161e62c88046cf2e7d728a6760d39c07db50f69dd85df82fd6fb0473c3acdd0540ba94a468ad1e1166555dfc24c3e0a3e2808ff87c80318cc20244cca00b12eec9e066f0ac6ef9c72358b0e6f31f661e68949f3f0576e96e2dbeddf936e4c690f8d931484ec5764f42c9b6283eedf40033fe2a48bafa15642770f4292eb03b99341737d5a599a2dd862e2fc96de0fac6ea5d914aabd75e88a1abb345b2ecbd1d05e292ad12cc84826069179fb80234e29629a482914b19e9f13ee4cb84506442af9f43de7fd4708a780b2d70d17e046f425a6192a19acb6e02e791040dcf60579a19ad54192d1ec0db30e7bb66aeed5346f42e4a893d5b964cdb3dd29fa14707dc4fc2e6b8baa97cf18055331a9675ceddaaf3bbdeb61400e92d718560a14bf1d7c159505d57a0d29bc07503e1014c324386cbf1a1f0b2c1326de160f7e10bd6bc55a360cfce9c71e897d68401c11aec8ded9234537ebb3c7d258c2190e7427d6b71e1e33a87a65788167125a44577a566ffdf70e98e4c7521011dfa7d17c901db50d1a745c72625a4d96b7ae7f3472e37fcc52e59c0a6db2a9a75c4b8c10da2c5dacb33a2cc5402792e74f8f6de72a899e25cdfbbad881f3aeaeff5f58298bad77285f602a47962bf852ca46f49312436d26ca03304d26f2479d0c8b44bcfbce269d5d61ceb8d59ea59aeadabc540c6e087c4757ef0e7a9e8193ce06ddab563d44ced622992cccc339609eb5664bae24a46ea9d9c793aa48a56ba6cbb8c1f253034e3e07c6ed274f8ff6a47db2bfcdea4af171e899dbc9b2455f8b16af996e50bbcce0836b4baa849d05757e2f607ef49b0e8ac3a0f2ad860bd9e0673faa3728f02c7d3be18f5816065cecf6e3b1a8748a4c239536c57d1d9cb107bd4d1a50d5877c00c72a2fe82c5988128f605f466d226e35f306d2b9b9f2139c6785a262bff12551df87127fd44c0a6076a8a7f245a7a77ff77fbe42701aa8c392551620d9276fd3bf8dc5f7d370a60362df9886ad46f43eddb982237f9d3e93b25ffa6e364d8fdf68e5e67bc4858d28efede90fadff848f37b87494cca00376d19d959b642d60410e418903087adc7f68fc84a041a76b5f4d618d33fb8752ad0bad9a84787e7b3d25ee7384c9759cd14d1dbfca4770ed31d464cbcdf61505057eb83f6a07d4b3b6de1521a095c0382a113bb9c46f3994f366ea974ebd759d2ad3f2cf0366117d1206684d78345293d23a2560ef704805f265db54f3e830b5adb149e7b43601b77b83d0ae1e030f5af012d984cd5d475068ce17aa81f827dff922a5ed603ec5c8b1d696330d57db72cea7da81b4ef154da6e3ff6440d7816df5f562b6bcaa89d274eb073c19e944079339ce4c35ecd16f9e5fb0cc8ab5f9822a431cf774518bc8af48f1766231a3e33e3676e481d44d6ab87415ee280ee42db5e374dc41933543400343faac17480c679e1c5e54ecd5a48ded050b2ba9a04028c7c4cfa4199c8d7cafa3526c41e07d8952387eccdee8b78c5269aa7ca763e181ffcc834d73a2dd85cd70c700290c157960af926860655017d096b9d5669f7b71fccf838ca4d807f53425a0ff830c7c6e8860e334a9fc9c65a9ead823a40ac05cff02415ce70560edf6da6a6522cc312eab6a19b4844706ef74814349b62796d7471af1a62d23c2da5d84e3bd9fb7a6b7f01297b7e2aa4c1103bd63f64deedbf4eb9bfad338aaefbb8cd373157623bc7a8a0ee3f2e8b60cbb7c9fba8795ebf7ceea5a0a58f99a5f55c9b7b0d456a04abd921f9b2f1f944d35109aa93a9c106c0bf2eec1131d47b2a85557863641d03344df52660dd4c1faeea87e75c22605993f89428212d88bcb6e4bb442b1449db6e061813c2897203c982f246c91f929b0bee69e513f2870080c183e23c9cbac1a5145d74e25a6a6c94c92a238df4fdbfac5e166d6ba521121ac28c0432a354c415ede573d6c2f8cc4de7c8a666793ea76d21edd36d7d1b624dac702c07514dc382ebc4789e263516472325788fa7ac7507c157693de1d12d273d625fd4fb20f75af2b85e15a2c0c7672396b7669166bf60ca6f69232190bcaa461121b858042e7b60957392a9b20ddd243a59e5f76439aaeb090439863b00e596026988eb6a5589b9c1119a667cab2c039e02e9127fcf44b79a0a61b05865f0f4fb20877d807f2a4ed4b2f315402ec162e1dfb12048caceb22dfd914a5230b455cd038c33c516d3c13cb01bf9df3815aaf41f3198abb72d0b721ce0b5602e17e96e90eecf765724f640ef7c41cbbac6f0650f47533fa9dc4020e4a3f4e875971a5343d5e1dffc98fd9812f83711120b2ff5033481bbb7da88efa42ccc68edd479656760a68534d6ec8ea68db1b55de0001bc245118bbff28a4842f799bda0ff09008a03ace9ebd39b1212234b1598462a5514cf84dc6da1198f9f394a4f40c52a386544b7d5a0b28431649256858d3edd180cd4306e5d94297e73c5503877d00d17c602b7cd5e05b77f3b862c1779dd441c1d2e1434c06e0048396e98288b2507442ea79c2e7402d8bf4329836bed8ad59465c436996b2aa51398ea0fa28ac0b9be36ae98e97730eb567528553d073ce4a3040dff1cf9b3cefc03d7f74e550fa06aed29c26bb6801505edc7d2a0e75264613543910d44dc715fa496598e8fd2ffc960c934f8d863d3b1d7d76ce08ab422eb541ffefa72b10b2f7ed6def182b306aa68bc8263ec37bd8e4a494ed37b82c34c274300ddfb0993614b0a4bcd3b0a8052d86cb8e805ec9c4be893de40eec8b2b1c00461b510fe1380a76e9f9712838e694eb1edcef591c62ef0645c34e15871be68787bff88c3bf0f53bf9cff5fac64f27f8d3a294f9f10bdba00c9be5401ae3c416760bbef2af4ec1a9977f97142768870d60312c33721959fb105f56f31681b9e0d94f79d17b67b871b572629db02cee91653c75cd06f23a9fa3a44441f5a4657955c4bd23143924325dcd8dc6244c743f057bda2bf2e62079d200dd548031e3cca752fbe1ee3b0efe6ea42f62d6faf7304db65d7c472e685134146b7b259fbf9d04ede020d126f867cab6a2123a4c0e9c18ab43a60f8a298c2ebef18795f742d79e0d562d10e402a03b8255b8a58ba7b287873488308d35c492090a55da6ae81d1f7c48e44fb8a7c568e5637284889071397ec309d3142eb6caf0a3396f2f484cdfc1829d82d35ea560d0713e67539329f5ea15e61df4d805f5fae96da7a3b4b6bbe15ab4a83479a5d5380b0b776d0741ea2af6c89cb96a3d8a009602035655536ee73e34dcf1b324ebeeba5afd0e672c19218db9fe8714b7504ffaa7bc90d6d268f461046592fd410055d24909f43c7949f99ffd82d6b812a7112928d533fb5099cb2e9bb5957c3d77c4c7ab8efd6ef2fcafecfa46aed41d176afc35d1dd5ed3f05b6f8c78ac214e0c6910e925e79061da195fea9714698910c021b14f3b15f2379c89dbeb9dfeb5c230bf757bf7a3641fcf6b4af966170b03f70f73e0186a27d89494d2f466f84acf151246ee48700ca89464444c0d763507afe0f9d23813b9d91a8f7a09310dc3f4838f662cc939e9183eb26a25199a6a81eda0f896f18e1e6a29879918c40340bf55e4fa8ecfdb736dc5cc6a6e3b60ae8803d1267e92b224a43be097386b522d967f46d32f5cb0be8fbbc3a7260b6151354d36f66ddf391269f04a9b1ff4c3b93f877f0a47e9c6146e2d069aa35d9f8648f9022604a701c5e1930a25791a9529e9db5a5fd44720016150fb890ae747adcfdf94dfadb9ebb9d22d2b5ba74613c1967b423574f00d98f48a573a9b4c2f11edeeb520ead3b414f8aa5a01b1a90c0863c5602477d1ce12c706bb75608c23f4d61257105d2ff7aae2f9509a057a637d2268d83c9af02184d21a1ef32d2bedc464162c0472163ebd4254c8f90bd96df1324b9064e4ee9be47cefdf4131850f03e555784d52c98450120c9c0537784e1a9626a4cedc589e6999103591eecfb8e112ed2e561a93f275b938c67b9e920ac0157a3de4c7a02e21562bb932958222ba21057f4d5aaa6c1abe9729be30ff378d1125bde1a3400cea9455126d4bc3cf6467029166c855d510e33a7543386507a2e15cbc5fed3cfef227b11d52b51c883598a8e06e2a2067a402587ccb1f21b886644de9c8ec4ad8e31f964f561dd1a8f787abbdfee466a4f17a204d8166cd4d1d10b79be7011641824c9c0167d1bdac7e37f0565f9375d12f5849d6184b44692bb506734d39bb2ffddfd0859ac01d63c6409334383c3e93b27a20a14a9a66ed6bd193d9069afaa5f568c8f49e9c6e6c6788966e43bd3d176befe541e797495e6d382145023e6db9c4c20a95b7f5ef9df5b3e7fcc11e45c3e606bac63bef53c62905dc7cdc18304fee070ce04ea81d7d4d97ca6f36f8e350e560fc466dabfdd0d0887f170d86c6f6a242926052b85d7687197278c16f8719fb086cb72030b92d95a4a888f55a28108feb35cb38f41a1fd8b10d93e3f59bedaadb2f1d8697c8ade004dfc017cf3462ce40da68c21c6e7b485f6ced186392e6c35eca20202e4b5653e52774260ea705e036bcb4fb90c6478f1b7b7dcc85b885874bc353e8028f91b600b5ddf7633dbe9d1dd684a55bb8a5305740fda4bb5f69e5525bb2612041fce8e777ccb8aebafa7a97b943e07ab9b252a1454d1d15d21cef19ba01fbc93df0a71187fe0c606e705b68d843e0eee492a36c18f330f177f7bb17b84281bade001b25b406dfb0a8755f291ed6feb71b23b4ab307de6f18be7f61f21eaf330522a40b9de72780c74f0a252dd93f594665744e7b3fbf2ec6b976e19730490f77c7d66128bc555f3c09e2f24aa39a438e796afc4a01230d22dd61c97573139b4958a339927cdcad0805a4ba26d8592451d2726b7a4fd5c347f68a2de36e78c42b1ace6a3d56cebf6f3d050a4eaa691c78fbe0406205427356315453625201dcd6347ca772f296316f0c73d3c7f028c30c0e2598035672883687522756520d256fa289ee1b5e73b514ef33a99482196be0bc3ce84e300fbe88b971862463a77ccc75e41f7cd28084aa1727fa87542571053f3986dadfc4035ef70e53699ecbc60eb920a88ead3015769941b2006aaa74adc49fa8399faaf8ed2d764bb84de0bbc66975feaa36894905414e345df856d0f736799725d51ece468ee8d1bb60807d77d48e521732692ae89f18f9e64f5a20ca1764cee52e13b167d4572f83b302c7b313eb318d8766ed668199aaadf4266e8b239b0d56dad30e69b62f864a1294b5d9b112002d39232f49b3536c9b0f131930df81510cdaf2479e668c8a41a1b8cee40f81c868ea811c6dbbf1a25ee69f8581448337951cf119ad2ff133e72cb7755a192a1077a0a22e2344ddbfe3b26b365bed88f4295e5f7dcb1b560ce3e8c928aa4d9fad4759be110922e2138db02cc3958130d120bd42a74493188cb67999e16013f24fde2e8a435c85415f7807da53ef6645864d50657f3db1223db784cb7cac9db72b4734f6f07d21802e1e62ab841153f10d6d6c9aa92fc44f89c192f7ee43fcb4392575b06b8e1aea38d239a762e4727144a3cca101d764b788773ae57fe27e798b8a8c67036ce63672f9a2d395687e2bab4c81f2320e052b1bdb8bb078635660743775e9850b2b79f535d4a9518eb3db0b8c133b2894426a047abf33cae46aa8ebe592ad73a8a7b473cc52a0f03e365a58fe68033837a791d7fe7deb0f57fee7e535a08ca42d55eb132c0fc8379c4e8030cef85d60f7cdd0e934ab61606b0a2061d9290457590340827f09b2eef8663a456001f613625a83fbab33e6ad3b49d6b759edb416148a022efe54b184cbbfb5df198cd8b4debb87169754e559dc5d5df90c8b6476fba2943dcd927146cecde624088071c38e8cdca85b45756d0696f62544f38aae2ecd059975f32bec56b5fe61140c65bffb4182f0d4fb7e9317150bfaa84d806edd351401de0e372e998da2f7eaa17676510ef75c4ff69673996cd380b94b621723d9d7dce1533b5bb2561551ede0175d627478b474284e8531ea6f46d8ab99f86dcaafb3a542a4c2fd645774df6f84f0724ba9ca70e82b1cbec8836e8090bea62346e51020e5dbac5a64c8a96fc657c489974883a72eb100f18f951c6564b60fc2e7c5eeae2e1efdbb92f08ac9e678b9cfc19a1f3899cad1e054189953992c4f946289514bdce88548d6ac6298305b8953ee4c02efe1f02f67a3da01326dd12d51be228c2323f116b0506044307f30a4a8bf08c6f272aecc54eff91031febf0346521a59066032410357eaed3b2a2413adacd6cbb52bff2f6966923fe745dd4486addf026de579e2d48bfa1b20f7af6a3f1ffa3054e2c6ffdd6cf2f5ccc370d0db50978acacb60f3bf03cccc50560e6754ec0a7173c64faa26c136124ad74e56309894dd0033e360d9045fa308348cb36966886e9d92df39b1cd6b6f552af79835890a0862a38cba1cf3c54b3e3732b4552f55b107ca54b8d43b1957be0bb943ccf0813ab5f0512f813fae00afeeb0f73a20274383154d3f1cc47a0d48880619b875fcde1bf1579a2c454548418e9b0fc0a65e71231ebbc928c76ad80d662114b2f4ede89808df38838c081fc07f1ed0b77828e0fcbbfecacbecea7e217dfea5df8cd4b0eff42b61517cf4fead6c6a10de90482fb96f143d543511a5d6b29bb445dc3edcd4cfc07a1b41b9271c693378c91165472d9e5f3e7322fa918f30b12358478dd9d67cf8fcf20e030504ebaa526574845196123511e38d882d6d97caef4cf473a318c563d1a36527f02a554ad29c9829b70623922898123de29176baa47f9decd95080a85b0f136fa7b6d0117c30b74b3f4e869ffe94c85ef2b94aa09208f4764ea9af3c045b5cd0609b4918e544573c67d41f4865d862432616cd2c01ba50abb4322b00517b519364eae3fec69dc2f6867ea7596766a1caf0da1594bdd58e8b76b6cf42afdda303075593b3edcf6de3a3bbdf9d2ef3e42b99976f058a457f6c16ea94894c624db9cf42e3cf9bfb4c0c3c165f82b659c7a4afd4e003e01f3d021a001f2d9ecd70fc0033e26f9dc72ac5b704d7c8123477b65f5c7e0a0626c897a69250efb7506f384f5b64ac723a78109012273cb9f189ec50409ad3628e7a22a12481c91505c2a3413bb9e4426335c4f482309ef284558633a8cc8004657d466fcc46bf7c4692bc573a94473e65a4f11912736c6114d434955785fa43157a7cea214ef677118a906aef9c2a0cc90136481ac6504cf06775670001127c077677f4eaee5ed02e9096205831032d39189a4ba71bc97ceb43883dda4ae500e96476b7a4916536720f24e65e475b7de0ed0d05c87fe4386945d45cbaf832bfb8825e2f6279a8a87bbd35c8769109dd2097b48c3e4f76114c8abef155248cde37e61f8ca24ef2cbb86d6c73bb34d4f3b8df855df4db62b086dcf3b3d77104a648176facfb5d430f31100c244fdefdc2c979bfb78422d824ba02e82fb44438ff669dec06a9ddaf5d033f54e83b9222e166efa77695a55e44228fa9442618aff4b9e757712715e244ab895cbe2d4837024bdf123caa2be98ec4a45932dabd6dab99970e2551a186c5673fa6f471545a53f0850523a712833d7303fb75dbf0090c497f5a5146e97e12c3e56cb888bee1c8df623ba095468182fd16b8404b63e249c2cecc051b3d3547276ee0d124bcd8962d396e9b2461aa2119420ec6886fe81c5a037d8a7f3549100329d1bb07d761869f9d86022d5a6c55466b7824e6804b9858720b82454681cc7e27b7e819bfc030b5c48b411f0591853ade1959557e9e9e4ce33632f6da8036a842840c93ea22e6a6c1cf6e03b488ce99dee8ec885970b2a312a20224b6d6da2e39614732ec9654a99a60f56ddcc3976c0253d3742dced7f07e996e7c22b61fc672d2af29ae0d3c9aadd89a6e78dccb9de6974daede36ee49579163df42ae52c1a49cb65f9e324ea6fe910334de4cc87b9d7d9f5539a607045ad1a63e7db5479e399ceee4556737a550b80c7862db0c1295a6aa885110db237240a36ac57ff31d906b37e446aafaa4ff03641653e889bb1b1da6d47a7c13920e220dcc3821e64533495105a9aa0dcc0394af11f9533ba191b59f0499add4c9d3af2cb214b1a718647730b26ed44750700129297467e86a1e5a806e9e7da9857201ce1ec9a8eb16f4cc666561d4615dbc0e8d7a02bec5cd08f6749f88a0f056e827936f79f93742b86fcbffd700419df772e67fbacab67eeea22ecb07307a2d8880a8eddd1d350ae21ff517a692ddb0ae23aec43b435f695bba47df12d3a395e62d2656fd01597b74c5e7971f9b73d5dd4b8aeb628b45b3d9647b95252cee52ecc75683016010c603ea2c17c047c0535bec1f4efb34fae738949a4fa0862dd4fddbfba533c46495e4845c616cb83656d23f916dc4c985f43e951da0f2c6fb948c6b8118fd43bab5fa6b0c2e0c9e80feec6d4876979c058d79991a8fddfee14d61398ca80be6351137c22d8c91d24a40eb93074d8855a5dee3cc695850b859849ad44e0b62ff59d84429a11bae4406ecbb6ea6b9c43cf4eec211723f13d37dde1919c129964bbd24d47cbeda2dcf5ca06ea40b829b15846fdd9da6a4313e37487788e44741e858dbab94d05dbb97bd4a3b8dc524b2eeec016da793f418f64d4921d85208f334ed5ee27cb9c4c421ff00291dc7d1e6dc5e5ae607a5da1d84406adbc9f9d1cc6348aa2fd5d80493c55354ac966f49f33eaa50339d6f88083ef1003610b6f9bd15ae21c041c2db3570843352a1fb558762a52a2568e1151ae521c0b0f6659569d0be984639068f744461c8b6dca350849f424f537f01c05b36a124723b4bfaf2658551d70cd089b7ad9ff060c156c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> hypothesis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研交流</title>
      <link href="/2025/03/15/%E6%9D%82%E9%A1%B9/%E4%BF%9D%E7%A0%94/%E4%BF%9D%E7%A0%94%E4%BA%A4%E6%B5%81/"/>
      <url>/2025/03/15/%E6%9D%82%E9%A1%B9/%E4%BF%9D%E7%A0%94/%E4%BF%9D%E7%A0%94%E4%BA%A4%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="679e0b7f3f4c501ef6eabdb8004813e2a2c945436f819c08ea5d52d50d53ef60">4fbb2435fd3b6574fd4f7bd14582288411baa04027e1f23082c91553eb7a7a05bec5489930d5e73a9e72cfe9d95803d35c0f46edad8e0703cd268187e7c80967a7d4451900019f62c1efc0cf450f3ca5ac88dfed74b87c35ef2b2f7b8401b6cc782443c34b5446ab6d7c8642265f494a95991147eb038b49c3d9d53272a330fdd6f0924c08525dfaf5f02191aaa6af3d1ea2bf1ab747fa7d92ade0c7274a5af77df794a6edfdc8e939ca7ae64205e3d6521addc23bd4b72fc2c7dbe5ee1bc0862bb50bdd3c87abff014a0fdf647d5dfcd0c2e8f54817b3344735e4cea19fbf58c57db359e3f46ad9bec9c9b2df371d7cac7a9ad3feb12f8cfd863793a44933387539f24403ccee0f65e1bc0e824917e27fb616cd29aa6cf2d46922abe487939a94b67c60e9a4ff017ee24a1bc8be678ba29a64733e490e1c4ac5f40d4bf15345b7ec7cc0cc7bdd3b2c56cd7a1718affe9f81a975f60dbac7dc2f57fb93c2d43fcbdbb9d84ab352fe9a60a51cebc57239f8ab4d96139333480bfbda6f206bf006778df748505f5af1d38bca2e1d49e9ca9c7227877571ef962898f2ae7d7b98b98d43a7b3acd7177a9dad6f8f85d50f12dd01a042b9f92009169877dd08452a227e64835bc5f137d02d8b2cbd7a2613d501fc812a36cb8af6e5a921dcdcb108fefceac659398a344d982479978ebd25f4cfd02424529e4dbec284395bda08544c58e64096d9283692b38c853433c80d37d5dc6d73ec6613a38e254febd2bebbb0bf1626f8c7c0db6388a43f6ccfc52a6b82a3266150d9dee17220e1f5afa3f0ce74b30eb0d27b15826e128d1feb8bf486ccc41709dd0018691e0812c59ca909731287aeb211b2d6eb364fca88778137da95dc45a959ac4b372dc0ace0c6181b508cfe810747662fa1c5e1370ff9f7ea641529da9816c54149f312d35ad6ba670356c20c8383611d3ced2fe04ebeb84eef1301cac6f72f82c5f59b6a8f2232d5e6c6678ca88a7860c8118bae1ad8dfcfbba855488b33a281156ee8afcc2674cf03ce4727c0f78248e32b133d51f31d6ebd8bbcbccb98145e0dc6a8207b7aa877c33b340da3ce8f6b784b0bcbaa0832c53b0b0d3f776944744c0034cf5afa76f5ff1f1b7b5a22a227983ae2b2dc220faecbe32cf3fbf1e741096c9e96cb28063ecefaaea75ad29da66b7e49c1ab65a45dbc8244fa0100987da4e7330d5fb928faa1d149c8e5a67356494691e467d7787ebf8ba390f715cb4cf2fed89f33a3694a285948820691c7992bfc970e35931d404d591575bee1cfdbc7e003303ef52c8baaa7919c16adad3c06764c3fff20772565c47e955741a761ca7189751469bbc8e6699a2662fd63e2dfc7d3b575079748fe08fe608d06e5a2ee6ba047fddace4d095b7e83066d20714bc1d857e4a9d8d5eeb7c504e52113f44983d571d05638ef2841174143c28b9dfe2899419a7584e632955dcff63df82221faae2ce1ea9d47a807ddc0a1d66713eb59c557209a003cc6a6d6be9464f52e231a1acaac5c2ca9bc6e7c7ef43eb2a194a2dbde54571fb506dfb1807fdea7df13e64ffc42f244f1cd97753fc6668aed037faa7a928cf9799af606d6e68600bea4cf7f8b358531fce98a7955d64b886eb8ac10df52038fdae6599b2f8e07ce03606ac868c92e1f7b171f52b60db537908165fc3c6f7487470ef91e57174480c4e2e690b8dc6e5967cf565b016b5d2fda74ff8ba9f7b1a854216023582f96990d5e02bd2d8d0ae2737cce28f71c2647939021dab3e07c320ed2f9526e3ada481bb22f5d7dab909b920e1f10d1868721f57bd1205558ff870f759786b9dad60a4fbea82a197e4e5c77f12911ba3a3e8060c681eba3a9d8c16e31506689a2e5382940bd55c065fd921502952155326e4c697d16fea5ff5800d90466dd2d32d3ab0920198295e669ab2aab9fa0f2342e0070fd0adcd9e8c0a9b49eccee13647408ae22b0cffa87ced7a5753638c8d4056332236331a16f415933cb7395a38cfd6e7eb23f09d82af9d5f2024536700ff87398dac93b69ec726295f7d144acbe66815b14624c41f63938a086bf7638f7c2b1e2f423e5cdecdf705b0cc8a45948c07cffff44a1d892071c94df3834a64dbbba23991c4606e804a5f6d64c83d3557ffc858f300f30bdd794ada57da418ec88d801341a8e3ba929f0d055eb54f177e5bcea430e903d8b946034b37b90aa362971453f3a79be55fa2d7fbe056b6dc33fceda8571e8fe18a7f60febc90db741d314f8e0cce909d8eb84f17e78bab1cdbf42b666ee25994df09bcb00329e4484421d48840d7ca86e6875418992c579b8c98724fbb3ac1f269f93a87be3d96d872c13a3d6df4b0a06f65f0effcf81a65690eca5676b4535b8f63e2568ce5fc197db569520a2a088133ef7433402d3367b2470f7de54665cd0165bd93f63cabf3cf62ea0dfa67a77473567f93b84f764e81539e82807cd7472a62c30788ae085a42c5c2d16cfe2a75f78389e741d74e469db6ac1abf4368975c4fa6aced9357c31ee2a9059d7458a4ca8dd1983061ba5a9b67e7c096f15740ce1c4a4d4b32ef593d9c27cc98fc97b879353a7d6565fe407571f7b4af7ae90d3d68f523c0f2c087210a19f599d360e71b9a7141248a71f18abdea987c7770d1a18eed280f01c50a0ce2393b8fa8a4e61b9e1a836d9e2616b63af9855005163e4c63ebfb8fb80b43c051037244fe3a602eb4928c498d0a395031fcd411d018a8df574cef66960362ecb3377017b8d7b5dcff5f48693b11118990146730a30d8e04bf6e5a1f7b9b164a33be835458baea078747f205ce243ed62e4a2bc0ef33d5a0bcc576916f12a38b27c2f7f27c90a3107db341bef7ea94d7066e4ade3c08ce7f81589a57853d8c6d0c628cb1f632d79588ffb7082fa3be014c00ea4e897b0ba589386f81b4d531daee80f99fc9dc74c060ecd5003078ab1a964db67ee45f1105f1e4daa805fc5f391fd551c623fc7769c622e61b5b30d2e523fe918578f5fb8bb310e0854d43a560a78379b8b37c95d4e285825c1dcfd969b94c1ce391d4b7d923d586afeb2b82cbf5523f21a3032bd4b7795d972b771798291891e964460b3741be1d169bab847a971912f07139b353070992fdab8a60d448aaa73b750d1b064e6cd691abe99e8e07c0c11877b7abdb928aff0e485c86c12071a162e25309516442156addbe5520e60e771311ddb9f4b6467eeb888fa00e6be135a875464cc773c04df994a1bf4e7e5545415acc89dc6641d0581a88cf2d28ca5b210b3f2990ff4cb8c7875b27f2e3f2bd7b4a4b6dcb937b36a5aa7d6b77144aa4ea1f12fd8e2eb7fe46de76dd6d9453f93efb45cca9712b0ef856a114066c055dab3fef29c5376b5878e0dfb7353967bbba650e0293369fc58a4e57f8a99ed5615700b602b91db66b8abee6f1727cf70c0b0371ec9a4bee862fca0800588d9aa927fd016c9fd90bc96a0d3de07225b6197021debde8107677ca101d2a4eb470ff5ed034058d1afc49b1b06d4a603c1fcaaab7090096c1f905c21e6ff737fc7e40262cb686c09a9b7a42c83c47deef4311a41bceac0ac663d2e2166f4db8b9f114897ee6c99bc1198855121b7da28ce89a37e8a03f4bd60de665f59880ae150824aecdc612e7a881a1e15b8a2012b485e07ff9b80a07aec2110178a065308fc3b3870b2b06f944ac4efb55b6d3dcb5d73e82e9daf153e18c4a93213b43b5ee7318b3806a6b0330475ff3f6e7b3704cdfb6ce1caaab798b87f22443129026fb5aebe58a158d5e9dd137dd60c5f0a177faec9eaddea9262d1295a124558800a3275464d5536c2398169a4e22e40ee00bbc5377b01ff85fa3655d92c8f42568f2e823e7df9930a54a8702ba7e55356a36837708bbb22a0eaeadf94677eb4958bbe9b57515590a05f43fd12157f7d6723088af27e68ace845727c7cc1820e5683ff74a920aed7b7f7c13c56f654f2f114c5ff61f3c0a14fdc7fecb2e3bf1749457744015362b8370c71b4533bc137c74365c54f4a587eeafc4f1be0601737d8d5a9683fba9db0c63ea6a912c04825a5fc475cb5d2a4b0bdd65851939ea41b8eb18d6832e15f436d60e4b01f6ff74438b0b8a1e0bbf730c34fe1f12360632c0d791dbe71c1c6428debfe6645c5be4c1691f8f6be8bfbe6d4c028d8e176f9192499d974457420b75df62c05ecf3d8707ef30119c214153f0b5b7e17b8c46dfe9c0d03793bf6f92ad558d7fff5dfb708530a96e81fd8856bddca3bb0bdb9febfe82a7deaaee4d727b83c70f375772aa7415c2f59aca6b0eac4ffdad18d9e2ec8ed22966e42accf8fd3e141082b3c48d6f4deec532b4ffb4c1cbfe434ea874f11dd22aa553e128825dc9d5de7f5dc6daca3aee2c4ceed71bee97931fb334c9887cc58de43cc98b0f86815b3ee841dca78db947667321ec698d2b181ce9016b4cd0698c7a3856b52e0e58f19d13777675bca7980a169a37c173ae2b757f3cb95c5b5faaeea2c4ba45926b5bee4ad3d188a95dfceede11c4c068648579ca64b399b965fe79cb65952da5ae30908185f17c747d156ab54368f25965188de12dc6be501ff291815c95a412b58bbaaac97ca958bbbebe27e22eb2a667564318c68267e3e0c152a2e25dc71ab82e3889673426f328e2951b813c67750a73723d885c13c455a2c73c41f6f3c9ffb34b5f576b391c1a3d82fe43d20e0e82d528d34a290d008e433a5f9739d8b88b56b8857c1b6d1e3539e598d7623b78e765d2a75a0cd550086934a439fab12695ec58fa0835ae734f82713d4209c5b0710ab995699b494478b8e89fb33a95f38d924c8cdbdc725778a0ae8ec64eba405b1b4eb2ea3351918a572610311003ebc3f13898e58e37fc84384db92af6b6927bf99a1dffb83c9b18f1f98c074cbf90dbcaf80ecc80fad3b9f8fb31d2f8d2fdb95d243cfaa6cd23841dcd799e4d51d8626815c7cabca35ff53741f6d39a3bc28768696a8e0b7658c57ae1b55949defe9e9edbaf848041d5b14c67381e8bffa2281be2007e7791a92a034d42ec8201ab9a16a6107566cb3d6bb7564b0466706047d711ea1fb70d4a3e4a3a73b3e55ee6b7cac7388fb72fe25ca5669e2b2f8d2185deb2368cf7a8ce1aecab0534470cfb06b73b81b0e1d5948e3ee032b270659e69fbe4cced3b6a994bfb441f6bb18c958816bc7ce7b7d9a608d05164fe597cb591bd6f5ddc55d7694cfa58187e030aae24820708b1d7605d2f6447f8b44248e5a06318aec9bda17a708c2c2491d768d07e7edf3e677e8ac9ad2dfffa9fa0a6568ae21099bc72465c35352b750b3d6df30ccf394cdf0da59d34a29f7f717cece2e5f76aa0893f82eb3aa128c522537c478ee338b008791545f199051a22e1441f5906c2243b31c90d96e58ce8f55496abe367039f2f79bbbcf3a9f5c6dbed168b7e3767e2bf6e3599110f73e7d9473286c83c67130a24964a239da2f9d03ba4617e8bb8f215dd73fad33ceff1dae16bab4ee4f0be020ceceb30bb23ca15ad15b0401dd2b0717ba6332c56ecf1528742232da2eeab63dd86f430e58bc7a199f1c3adfb3e04fd82ff268d7f6e98ea05d73c9d07f598398cc25228b74e88145cb94222ff03bae7e1046721fc4a2b23f41d0ec8809b6d7c1ccf6540f333b7165317f8bb920414e81fc5a9f5d94df33b21e78c7e7b554ca53772642c91445d25e176301e459fa00a8acc672256505a25939d1a7f0766f2ef3d2b6a5cfcbc92b2ef406d536eeb14339f429dc3361b91f409892d41ffe487ea607c0e3aaff0a788731cd78c4a9eeb808d80ea6fdde8180ffad18ba2a64ebcb9a0434b57bcf63d2df09e8048edd528ecef715dfabbe0265a37bf86f2a8d7b710e0a2c8073b109a2ea2217e947959716a7613abff86f5037f4bb518e42da9a6c362af0ddc440923c7d1dda90c60cfb8076a9e8b59ebc82a94f7ca03f6d5a42a5a339ba3cc2b36104e14ee225cdcf8e7be40f64fd0e57189f4725cb9bfb4ea53b8e11615309740e8b0eb32166867ce83d6e0b9edbde0869853ea155ad553dbe68</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密文章 </tag>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖</title>
      <link href="/2025/03/11/java/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/"/>
      <url>/2025/03/11/java/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="c1b129103ac98c80f6cba4ca462177044d27474836a3449348e1e2fd72c9ec5d">4fbb2435fd3b6574fd4f7bd14582288411baa04027e1f23082c91553eb7a7a0549f732e881030ada605f2e5718115bc8e2e4da3637dd3e35441051c3ba4048adf2fa5da047f3a3c3c3dcd4a42bb1c9444ac38550df54ecd13b61361131f9623d81b99e7612176a24642b1658d8360a70afb61db49ccc479040f4be2275f6387a26bf61e91ca7b3d8b555d06be9f1658f63409fdeca59b3219a8367dd60b640b7b9c92a58c109ab11aca47091d54bd4e80afbd84625125630ecddd82d8fa13bc13011a753594924cd6b24f8dd0f2bcc50d8b45bf8f178b3c199dff3bc038be4eee154b6d665e165ff46b537a46bbf14e8adf2bdf84d3cb789a8453939077cc5a8665a88010ef80b73160e91ed3e59d3af29b1d0f708423b8de3b3dc305528d80b7737d1130dbcdde6495faeb74f8b113a05b85dd01876c9d4358916f0061bd9824aa3a186ff351fdcaffbbbfc51dc60783345fd8a6c390591073c193e29942cb35670b83fdecd5080d4eda2c303d2bc9d08958cd5479c22905fe47fa6bf3f1a859f3d4054570ba1eff36af1ee5e309c2e6b48e0882a8b2c66ecf1b612bbe103b593bd1fa1d8c33d8198bc0405b9f88978c5d85a297a64133733dab7b890df0e9948af9d8f8b4e8380f5532b71786a1c1148f2716fd85c93ea3a0d7ca5144144660787b1fa1bd939f76846b7b9330874a9ed30f21e85f4ffee8d528bea9f9f4ede2fe18d943b0a4194e0e96cce1776a58276ded4965d7514b414547323a02748b6c2fac5ceee834fe46cfbea46521d84a63cf4d7dab7457e26c0b39b8be94500e84094ad1e445dffb11920d5e0573a1dec6c314822c55c4926392fb0e22d8b3385bf8d98bf36427ed4972ca2719ce3df18ebad3fc0acdaa96c30035228cfb37df70368bc63037d874b245aa008102b9e6b3feaba0fc89f6e03511818dcf7c5838ec6e584874fbbb232819cdc16a83a7d14329c302c63ccf1d2ed770408296d69a740c34b4d29c7500c9788915d1204bb1240a20178a93c43b9c4d30f019e4fe4c541db120b53547e299869d7ac70d9d9fdedde058f6b9fa9bd2cd1925bdd6c9879054bf36437db9d7e5fedbf71854bfc48b47586c4f6ffe0cb3cac934e0194ca4fbec174666a5ec0b372d8c266ae6c06ed64ad40171b4100a48f1dae78eea9cf1e1233be01dd1ca81975459be1f864844b8208d80e19aa0dc8baa6136d4415484386820bf09b220a29de7e440f3aaaf1f80a62a47f8d600d17908da59ed93bb25c798c75803a0d0c86aa11ac81cd5c94896a870618dac2fc2059320090e55c6bf891e407bebcb930bf07f25e601a0312b744896da7b245abcc5b375d62901bec1792deb82c41927476856dc31aa79b63c8c34bdc4025dc37d8cfb13bdd620eef11bdf151e45908eaca0e120d983bac204326b20d1217a89a752a50fe1ff65db1983ef882722661288988edabcf00321953f3f4d9223a4d151c22615b3199ae92cd508b74b42f1ed237ba1e1aa26396f01b440bdc04717e170b6aaa33ea18da5e5be39a8b53fc94013809a1a86c2b0d218f7fbb3fdb4ae95f298f02a06adeeba5b2e630a437cbb011b87518e92e9fbc4204dd9fed4b7d6098633eb99423ab3a5245c24bc1194b86640f2a6242ea7f696cf924d43e2248c069dcecdebbf9488fdbfa528ad27ed2c63ec973971d8e7ec00bfe909750d4582bd3a88e08d0d6366855d81c621654b52410965835265ad247ed7de0af927b34308c62afc7e4399d656190f6a2ea76b0d2215af643365d32597ce477f68adfcc080d7786ab0ec53c923569e8a72aea5daf2935d0f2d852e4b3f97038ecf4d2630694451d60519d22d12f3c0109766e5e1471089a3dce50756d9b14ab4c26246e311761b43f74517d5a17f41a9b07486bf5a1430cdcdef8bef6c978e3f32b5bb35eeb1a1f49f99971015e56bcb55f16f5c64971b3110d925be897a5311d1bddd2d83a9435ddf9a5f658b9a732da433476c7a50cea9e9e1be199aec424753946a7b9971d822dc801c5b43f775f6e69b36e0d9e88f8e8ef2f9f3e5698185dd9bd7fa230c9e9ce49ae1dcc6f44ad000bbe29ab591d641b61427e392590af2d8f30dcadb456012ba22cc0890a670fa35bdc8a093f760b961e4865ac8ef79f36847c16873c24df870766621a2098850ea29c1ea0b67eb49e185737c6a772bcec82135f78045e8ea30f38b3fed13ea3cf26e12cb60c1029bf624a472b0f51f92ff371bac28ba848d2190c4612f1583fd0723c80946128f1fb2de53387215aad60ddb3b0a3b2544761c37b9b478cc111aeafc5de00c7435526ad45175d5fe41789e050b5805807cf5f308957c63129b3b8300ff4064126f512144ef4e61a5e54c5f064832e38adec919ed1b5b92c3415ebdf504c1ce3ed2fe60d6913b554db11af3cb0f77639886b063fb5c5869747347a59c2b54d983557b547fe2855bef1cd9b765f1b8a27ba053e710bd17af36a3270ac721adfddd41f540da4de67e76a51f77d7de49bb4aa1faf43023ae2236a181f9df80199aa0440e3a1087f1764af92285efd9bd5fc877b94fb2e0f9fd7dddccb20203ba7ef0d7a19fa327c460d9e93cb633542aeab1e5373d505ecc92b8480e649654899ead404f6cf602b3fdaacbe7624d39dc7564d44d73de5249ea1393e3f358cc8e5baf7a4600825d97dd6c2bbe10bc42387defce97922a90f7707cc3c9a62d597c3b53ab1e8b24e32f44dc6b020a605afcfeedb8b0f3b0ce790b00539acd0b652eaa0cad9eb1a21081a72ae0fca2c56751aab43918a7c7da3bd3c0332c52667f4e7a661e86182bea2d589f472825314580b073201a55ddd18890648d9300ef476095ab3fd1cb7210699dcc6c0b9a13e47e15001c7983ea1e7b570fb3f9b14c05a4b54d5944245bad36ef5f8e9b21acb68d380dc728634effa59984ed84f8801e1fa9fd7130e8ba39190a8f46b10f8819246eaf8603e411f8df822d8d0e54007bf166bceb67a3f86e0c2cc4831caadf58612df53010c4054c579909171f920876f328a0dc8145ff7869d442dce459f4b9e2cd8fa694e519e02fed130e2bbc6f0ec234765755a0f70f5ae6c44a11f429b22c10ef62832b4f6327c7552b7862b64deeed3e25117ff5bc733a026e798ea54ef4fa85db8a46bb0743b1ebc0d11a04cb53c339be58c4ef9bc8a0677d0d94b47b126ca9852693d60451c995b7b59557be6443f575336776d854a34a16e4a1c44ccb312a7fabc50d0cddf4c26c9987769176d36f72745f31834e57f03f41ebcbd2c2a68ee6273b8fa8e914ebfcd58badbad8372233704eb511f58f85b589c65dac632123a0dc0155a1b4340ea10d479bb2b23b68b5ad3e9523170fef48753bb373fe3215ce935019e5be8d5ff0c40450ecdb397af8d3905043ff671c6403ca835a5ac76efec8a6a970c569783e3d1a1d219cd0f772443ea6ebebcadb4bfad5c73de0a5d71be79cc239a66a24dc54bc3dd5e52aa62b106a95edc0c2af357db2a5e37103e516327576b7dab8b9d16dd335274ee1c2de1396b26758073722c5224c93021977ecb7156eb5fa7640ce42bc2ac7c753fa92f76880b3fdd6d53625478e5970adc0d0018222b9f8a116f03ec86b5b47460dd240331e7be0f66276b25a4dd38dc705d108f92f86445862fbee28f28698ae5f43da20a2c83a6cf6cc8eff4ac33d1ebddd57fb4b4e1ae96c8364ab6dafdc8026bdd4b2c964d6ad6b59dac7e96dc4dabffa26969a46b691e9d67e6eeefc2633611837ba8cd89e99ca36169a0bf974976d62ca65f8cb8b45b0b48df9e1d3999f81c87303c755236541a42aa48bbcd68ad519fe3a6aed874868291efb09c63e954f87a660a1361d608b3e61846255d5ed9cd4203c023405da965c5f12d3c953faae78780f873c867d53aebf334ffb5926fc2f532bdd68e20a4b7e007b03d11e17804f0b57c308b990e4e4516d5a4b9e1de8fe9c1d41b46e88f831c418b5fb5fae8e71d2b20a7f02e51e675b43085538eb297d3b0cf7fcebcc74d9f4963a19d3dc4aeba61bad78cc99b42fa9570540932b2af53467fdbbb79dd7195a560ee25860516fd4e98c124d9ba78003863b0cf9762c5d7f619cc74f48c607ce9580c9d1117704837246dae787161d1bce61623666af4df097afa3bdc8be481a30e6110b1fee89a3f04cb1078d7a6013ca2a452ee1da74e06fed2f2ef334ae6fb52cd09bffaa581c57751d368365dd03542770ba67596884133abe49c8dfe2ddd2e888ac29e328370c4f619287d803d28b14c3f004b425d7fd508c698b8ce360d187d55239265f8d31a5b1f4cc1e9551ad951c16689f514db9686014491970462a07b33ed9e2f754536e8d0f2da5dbc6464ca8870a950bc6471e7e71b21ea25d030c0f811d4f3719f938f0354f5c22c6b49956e6f77d256603b226cdec5f77a0079aca0fd91ba1e85a83c9b5159f83248a3a16d2c85826c1f361fe3959944e5e4c645ce645f084216062cc9a6b1a6855f0b9edacbc390c2aa8a7423b56a414fcb35a4d8eaac6483aecc29625bd666bf2ea00ee6d92151e0964576866c624af5484e3340939a29c9bd58f4a4b499332f7afc209d3ea50d6c2122052cbc95312857167788a86bfc9ed889a4066ac08f1d4e3367dc2e6a5f3a8bdd63e7532a4d353d17307f458e5f7578f6b4f47802541c02f5db6df350c5f0196f2c33dfc83f78abdf1e0c7b0f88e031c7218948ce19f431d43f982e71d5b099aba0d8d114c399b2bf0fb64f9375d05987ad2817b4a7e5b9ded1f3378d53d06cba2defde8efbe8ad095f670ea5b17e2af6d25def27c517255f6b7024db3ea1afa649d8905038e182f56eb2bd9f04dbc85f0abff949768155d5d8418e3b55e92ca4bf3d8e8fc52e09dc617f7cb3d88bd8aa3d243595974bc57b4950ab6acd02751415a11e7e1c819bc8b3b9e9ebc6fbcc7d118d2f86e0d309239c5fe7578614c8c11fa9ede602e34e142213943b0fed8d0448f8aacba7a490fae25b5ecb6800999326c4a74d3205fc333b198a73334edabb434fe3949e4668443ad4e63da4f19674579f521c0f9033e82796bdabac95aac9b1712fd5ca866608687b4154fd94bdb1429289d54a7fab836fd1509aacc5bc12c1d781b8fae861270545c5caba0af0a688c80bb36b617b8973569665721e7fc66f35a6a43002edec82a49d01719e864be11e9f5f88e7cbea55e5ff3c81831566940db2fc89668861094706fd38065d298495c235b218eb0d8d3b124ea6d4f166a7343eba8521c0ccab69cc7261fe87b9b48d98b5ad724e45131fd664a48fc2ecaab0520bc2ef201f76914708d60e4d0cce29dcd5f8c6ae551171fa13150ab7082f0d49d2cdcf2e280e0c4fba149e20b029c56c3f6101c50d377f26b8e2e6736789aac35dd30c3307c149606164b43f31ef8d837932c8d147bd18a1310da30220e675ad74de96686e17bf36451af18eea86c79f16e61f9594543f85430dd98d7546b9da78438ca0fbe78ec9ea8cd52fa777346c9105464451bcdd0e542f6607607c22b9ac24d17a0976614086d80d5a85d2476501600dbba14026c4b8736ba117210d7889bca0519a393deeef8c4c12c7fb6c218c156f9e5e64081648ab8fcbc146253d7a6cf36e318fd9765b5380a741132e76c557d297a3656be6199580e8d921ad219d489f237ee793abdf1275b70afc88af62849306698c8a6856edc7cdd21cf325dcabd9ee8e14a7582ed6cd2a353b946412ad3e774aa8bc01a45443d8fa795c6a862fb190fb0ed51185cf6f216f2a547a658fbb87ffeaeb315084517d88d239f25b00d7cd080ef3b89e1c38fc6e2db55c6eeab22e4f5bf0eeeef6d681a50bddb1011d5dd7a0db6ae636b5faa7493245c8aa1202f80cee3a801768c9de1ab27ee20b6759541ebef8ff55abfd863daa060157feff2d0243dfd4b04506ae756726d6ee0b8cea7ccbe0e3473fce781a313873d0a5c2e6197094e56f26b1d845817ca40b32e9bd178d6d86edfb0b4dead370cf23335492c39f5c13ed3a583fd932b4e846c9d95b07f706c0bb8b9e18f133ff5d2ea3174b2108db0c19900bc0253ca0c9c29b8544d3f1bce366d7e203f6d2d17b34cb607c3d71953bfba6fe533df975c24baed2f6b808a03e977114107c714f1dbe85898a3ec7760f86a1a898cdbda949f9bb45e627ca9ac31951d06ba812651ebfc5e9e44694bee3b0365231d10660e0d01a92228439931126375ffa40c3237205052eab473a1519267a9774f2137efa1ff064dad7beb7cf218013f0ae7c3aef101ec0967469dec5d44f13834c9b9ada50a4f486758e4bda55cb78c4ffd35270a41efd04a71d56b6f895c183db3750bed596b19663afcbc9e51654281e0a6ab16c241e1a084d8c812420233f4e81ee014ee981ea4f88d23c217f61068280abed251f1dd12992de376098ad341934484c7444c89bb303c75edac268f66b3aa87c7e187171a4b6b1a9a34a21b66c8715e348345d6631288fb7f343d1f98f7d4c8e42d18b47e8679007b50373701ff441b72432563550622efe6ff62b9a407aeae5e1570a57f9ea12841fe3519be3bdb2db6281a5732be973a64848615c97258553cb514d46125018c6da2faddb2cc7f8def0eeed8e7f3621cdaf4802b61898c872e3735168e87719bd774a24321fb03e6e9198fe176f762677fb5530c558e78a0dc2e0448603e74c769c85b8e67d94bb3421dcc06a9ac20c3b71c2fb13a17578dca7aac6c5cb60ad51f921692eba5b9f9faf7e1e15a767b19a3171eb7429fd8104df1b1ff307958e0e866578400f4332b42e11779afd62e387b0fd194452f8f1b14224744253f48f89000521ca33ea03a81eb4760dd07172cbbe638fca9e2de3396195d3df4bdb41ef19ec6629cd23d3da8871c4338910d79491ac25db158b1c7445dae2cde7ba4e429a5f18f9f75199a82aa00073ef79ceba0b5f2343e7e413a2d7d788c51357872b5337bf436cf2840a66780696e9df42ed002e64a871def5cb7b6a220beed6462c0fef600fa41f2cf269b94aa54f125891ea0fd1ed24d10e0e60ecb965de13a33b936d9931e28b793dcfc81f0701742618af03361e6a6b2489f56e40e2ee22751f25d90cb2228e5fdf34ce9c3063df3acf7dd2bd8c8d13b4846dc188d11aa0ea51ffacea786eca8556476b4a762fd6149d4803fcc214bb509064c050d1ddbf95eb76d40336c8c17d8c3f5b0ac3572fa88850e5bb2cf69b3b6a825caa1f0594e5114db15283e037547228b6c4385c82898c52714851f6c0c2d2cab19ced8d0b728eae3d9b0ee80582f65bd3e9a2220e3272503de80f3784ae318be89e61ccb2db7903abfdaef6b13784755c712797bac988bb110362ba70e66d5c866c520912375daeb66ab2c1b9d66fdc6c78c02c954ad393fdbdb96af7e4b7ce3035483914ca1d9ddfbe0c806d4dfb1a5997a35145d4cd1adac8312100e091af8131cf9c726727db35d03aac8b7e8f077a31bc5b3d25fba54fc8c5550ecdc38a3ffd67a054ab5f39d4a12f59b71bac98e472b62c1c4187c6f99cc333448ad6a59acebda446d56e82cca5056a562940dd78a91059d1d32392c05cb19b7f5dbf72d9438ca6122a532875798502082553377af1d9fe2ead8eb36bc91ff6919b79e27c8d4722d122732cf72df857269507878ebd37132c93646834043bdd3043e4ecb106caf5f06a089d1d58c6ad85bba3c6be583c6ae4561eb2d95625f032037b49444bad569b4f5b303752a79b429b4b2bd457d09a393a14aad52c2178bc5f796e34eacec167225feb4b48ba50571cedd4d5301c8a8139a0973e33df7761ac0fe41969e9e5c82ceb08c1fdb5ee8024717c7a528adaa8d974c83a8c9ebbed5eef3835933c0e4dd5139530f52fc7e3d9806edc5b574a7a8b85bfa3b5f83ea43f85c93d3d8f3262051e3d535348bc2b318e1a1ae97f1e1be1993750a68c8ff0a537d6acb0faf1faf7456e7753ce7d669bfa59e1744bff9acbbf3b587e8bfa8397e14f2b97ce56cb7855a8dbaa9722730b7e499582bdc77685b2cada1b68594a27193438ae90a2f83902de39d299f8d2ab88eed5836f04b5b3c127faea51709b635a0d16ebc7b9a9efc3848044a405919308918a688f7f8913c82ae133682735549dfa4c7fbb1cb1a1450164eb5f75e079ba645cb052ab6fb7e0bed693def05da0ee92ace44e9a56ebf855af0bc859931abfdfb32e997cf9987ae2bd4e127da4d72339e304d4eddc48cc7c373d71af448f5c0f87e0a63e5da13acd61346fbf1fb9a5cc60ae7449fd29d57e98f75484dce85ae5e44790b707a266e941faa56d31e9bbbafe124f3c0f2c3fbd2e1c7adbf1bbbe9d07013f60859e945c4d91123da2d3fe35b5db2b2e15120c706d46dfd2bec1a78f17db7dd56359930f3f9986710fe62143c02664a512711fb372dff683fcaa0d832afd5cbea4d60df11194960a931b56ab08451eace4ce2bd92a2d2f3831fc21935ef034a25e636399d2dd9a1512b428a93263855f333e019e2c9d03f29c4f4879798fe80db7da486de1d094c4b0e0ab2214710c521b577539914f79ea43fa373613aaeefe977407e3bd8f0ff45402ead0ef6f935f2c2041d1e8915d9c5c8daab62f54841f01e457a7261c693b6715de3cf0e765deb9dcadec57c73f33e3c7b24313ac00b31ec1a018868195bbfd193c41aa99f2a3106914235e36f96c7ac76033b0e1c15ff9c608e584272ff0058905ab7c12abde61b80f98594475176981d2f69f49ce31aebffb5970f4304a3d937afe5f5999ed4d2acd15a16d13bca063c172cb0743bd3fe58e7cb0daad47ac71abc0d7830f6f5d85a05940856de9d3906b2eb57790effbf503011a0221533fa0fc15021432a4e54502548d84498d2936adb0e29a2bd41808c3d11ee43040ca928e8e2ec9f0d18c273b8911f5501875038357bea1f7bf026757604607f6561a6a78cfc6060c786886324d1bd7c157903c12779990c1823d8b3feeced855d33a7486106edc4252dd66bdd4d2d528cedff8415df558cd5b08c9e66617d4951523f45b4e22d3948a298b365c8a466a243bd09b7765d94521f135a88e1395b4f41ed2ef6bba1117fbc1c6cb4518c22acde536179d51f01dca65bb7b3574a40578a10fec81b6e979e1b8d63e88f07e41e3711032834ac550857ed43b4e6adbb1736cfc4b26e0197417e9915aca8cb9014404527f3e22ce26b3b4c9e3b5fdb915cc172050592afe4090072db9f972f9aac718f07f16121d47d27c804bab724ae4d5136f3273ba8d14e6cbbcecf28f4cdf42febc532c4a1735d81ab4ba044f9ea3c61a70081f16b9b3f66856ac6032c82d10c8dd205abc33c87753573da7fee81853b3103c5129b11a666ce537d9f45d7e0e4bceb6a8618b6cc909a93518d8d6e39cc8d71b855ace580287a7bd00d8e3a800ae6f908c67c2cae9c849fed1b1cfbc138dc7158a5aea789c87bd09a306e11a732b2a62e7e9504d33ce0902e145f92b19a2ffe8772de4e2c52d096202e4a4a9163dd5932ddd84942f38884e50f685dd966d05b567c2dcb11c148c14d28136926386c81f9eed9e68f4ae8844ca6acff62b95a9da98406c1247b68508ec2d6a6139d318b40cb2c65a28e2dc328ff653774ebed00d836a4944da70dab038039d2a50ec6a457005b2f67a76879eadd25304f9370c542473cbee9095849beec986a4d1348ba44194c242d9da7250a21a12f117334e8fa0ed38806621b7652484bd17ec7222138d3d7ec8933aa6edccf985582768fb35415030ac53da3fcd4094ebe3e7a012b23165869f8008982dc4150edf44475c0577efbc6bb84b1b81adfa0e474bfd500f3c611bb3c6a3be789e2cd4486cb34dd9dd834ff3f94592a4c228a623cd82b161f6d60741f41da727ad9f26bd597303d14490e96798f7e73f7537db24d425579bdc63a4da76515b42300f6c07e98a89a79a430feb3f3f9d78516ffa16cf742be9face607b078c1764b31d57a53190c12b317b319f52c1896e1a0a4210104d90e8baaa09445694c6b85b376214331ee641d8d1df8c7809d49175dbdd4cd4e5d098ac84c1412a142b24a68022c87564b30624f9e1b9af5a04cd5ed51a633eca5d503bdd80b4af71b98b3dde6d7ab9c07dbd57c8c7ee2dd58c7870d6fe4db2bbca9c14d9b650a409e1b1016f2a539ab072a41ca029414e545c0f736b700cb81aaad2fe107f1f59ce55d64e826062e9e8228935ac613f232dacb6c2d53f775d1aaf9535dda23e7a6213cca3a1b84cd522f885a6ae3493eb6677f22bbdddd42f7a2723f5f5d7601bf6ba503eac225718ae389bff1480bdc9d35a839fe563503ce42532880fefc99ebaf25a7a7ca241faf27d03a472068e3e726d70382a8f6e6f042f5ac91a77fe6722766bbe350935c39665204bb6cf57784aaad7488198a4ebbda48517db2d5a01e4a98eff94d3cb2eea96125a8f406acb280d2244597add91bdbb32c9dd89487ee1d203719f5b8e00cd65928a3f52e3851691329084a954e1fea0975264c240899fd52a978893277b6985d1dd304b9ceddb00f9ca2d1f2e0fa202c5ba50c4f0a9942c4ea4c0ddb7e51d6a61b0c7fae9cc9ccb072eb2df82e007697cf5fdd10e9c6d2772d78782b34693ed36263a6173ff7fd18156021654f4f3cbf0ef755dea096ba8a72551c3de8c45eba539c579b72199f941aa4966ccf98e81ae68dee99d9d8965f0a93b5798c5e45cbd7534561ca68564a780c2c746bd91d427728411bfaa0931a498340d3b494a9639c7da3cd79b7e93b35c6468b4d567e435c8adae008c24ca98cd9254d869d9f6dbcb799402f7244ef748b23587e3c39b311a515faa4c9a6b31189862de9c1cf1eb00b630865bddcb9dcd9b3859daff1350af8221f979c82b67bbb40dd9945a8f1e02355f0f83c54a604608dc4a248a23996ab551aa32fb2322817a3230a7fc58761daf09ea3916486d4406311b5c54f64518518e621b6570261b28fd0f5e07add51a1bbf3e3fce50574f74f061ce78ced882dbcbae2ef3c5273eef1d87ff73a439d17a846b4f413b85b62252024f789fdc34bf1fab7458d17f0704d94bd37cf67f052b132a22101e7042e4feb2b039abe6950b254e83e03449aad8095923628cf56d238a1c474f7da7867f9f5416e13de21cff1b8744cd3eed2f5743dff78ead601ad9cb2574a7aa9bbd9340e6d8c60bf0871e64c3f85add1cbe04a2d5e4ff8065439143b7ed415e7e098e4f675382e6f532358421f37ff44c9c397997267349c8e29ec2927e4f4d1589240d41277106a1ab5d38ce4166d7b9a9c4388a9e4cbd4abe5a5445cfd7aa1e5f7ea0d15d84beb5a8ee3d7ee287516fc251dd1a276d1fa9dbd171103f7299e91dd0106900a1789c06c43c86f4cae67ad62462863e7b57cdb7e639e50e398912278a00f1c31f2350ae0fa8a8b3bf8875fa0c76305c3d83d5b8f1b2dde770f9c2f470a1cc0a61ce451092e31a81001699e4dc8ad8a2e595897c082e027645083746c8b866ed74b722febe3ba81d09752e65e21a278fed96a3aa7514b7338172a31f5e48f1530c550d70403b77c443f7fb5b78ba0c51bbaf22e2a4fba4e55ef09a8cefc30edc9f75ab79b5908b015155c92d2641f737513f991f517eb4be28d55a755e976863a5c93cd4b409d0ed4b441c573e3adc89c3b6a4d790d0dc1aa4e394f550c5e8f0098f3238aad80e589cf3e9bdf4bc53de8f460a6cda644a71fc9a3e0e3194875fd4a2ca174989f362c0c5a0209987c590e3caaa79a1b848a3d9f503e2d0b434e170219baaa723fa64c4888c8e5bc876834995b1c1c610a5bffe366bcf3a0dd5198f873684397921fac4cbc203d557371abe95b74d2695fda2e15f085fc7428935feb371928c5ae21e9dae0671c8bd7def5c2722e7c61c8a57b4eb7c5da25fe7e56d60f233681712366c92fa2f176cc478a1e30fcbd86f2a3c901d7e53ce4a75ff9231b34449843330ec18236813b7f0ec758bde421150afb5d3fe52e62ab7474d1297e7f0a313df92a3c3c784c24615cfd44af688d53edc798d68866454063a38ebb3b4ee9f1d95345db23798478a4ad1c86ca8d153ec0ea49e990882a0fdee93a6edc07b846a1f775b6cc293ea4ec76bec33fb6eb6c1dea06f2457fdb02ba913812d804f2fb875c9a92df351a4c6c596bf5fce053e5d09d715ebcb0c7c617e87660cfac66fb7437d049d21625c15368740bf31f6fda49e78340aac3f2e23335e58f9b28f66b3892b649b2b9f1bc0bb4699d2c882c885d4957a2f304caedf94d1a3b72c495674ab78357e84cd1c63b1fcaa43a2870ef72983bf1afa39e91dcedff6a606b3bce343b7c88d101bb58b8553d2e4e1129305b90d123b3d62ef6ef408dc1ad4a444cd8011dd8b9eefe1ab1b4789723d6cb51a50ecb36bece77f0d129d93949c0fdc3aea270d444e338e846eb92c446df22495c5600b9e64444989c49f36059ce1a616ca5f9c0130aa1c8b3888030cde05c192fe2d34779aa651b757c809c9ad2ceeb1cfb4cb6766c39c3f2fe7ac5e5bb7bdab2b6f5a6cd34dbdfb4b8281024bca9dd232c92373f45607d38172aa4f92533e9c47100cd759d8af2fa7955a6a64e8f1edde6c1e45a147951dedad32429dd461b5dd3281d7eb00bc9c6472079a0d7cc2f4a8d122b9ebbea668dcaed1a281d8dbfd1b3ab58db31dd633028a3e19282129fc25e94471afe40ed5a66c088c7629ad77f7a55bb40e65ad4d3348c9a44c70a66d646239b8d8f828cb0248697ecd14a0f2dfc4634c6079837335a8d10add29a4242aec44d0bcf8cb0f29e07c060103526516877e76a0a16888c44305bb46ddea771ab062a978815792a534bd49fa64742cd8a0250ea83333be9db13b0c1e268773615d8527511f60db664914cfa1d2e4cbf9c537de717458988806b0d6cc607c1636f88baadbc713f8aab0f5fa25b18e52de7783599cd09784a168f3c46aa0b2b097685a94c53ecc08fc6b042e0daef5dc561bbf2d1f787930183974a71a841afa3cba07e24b724cc4726b400934218038905088e1af4a5f3642cd73182b9d6a880525d42607cdb73adabf23f7aa4fb5dd8b7c531b0a420eb94495fc7b076ac3e918b0a3bb191e92f96d157228e93af7590320e496ece5366f9ad9a4abd7058ca6d70fb043f8cf7c3129bd3a5d09b222720c63fa8e299a792b9485aa6d61c5f0d09bf45b9fa506b51abe13b550c9d6ab248343cd80d95741504ad76b30af1407ba3c9d8f0784d6631595d47d0acd6f91072cfaae60818589c39b0918e2ddaeedfb1d32c0c5230a82d7d294e857c49c7af3c705e3ba5b2696f92a89eedca8f1dd871520116032cae90bc1cb6a4148b93a8c5ef751e692eca0472e6d8821cbc0ffffba2e6f900be16b68f32210ee20d9fbc409148122bd879f2121da21aab0e9b13368ea99c6f430345ccd03cd88b9b72846528708fa6a506beb92e13b2f223bcaf89f050c9e7f6bc0a34df62b3d31da33a58baa6dc203d227a37de10d9e77f9871f7abc2756ee072b3c3f39696599d93ba3b90ed3ff600288c0c76295a7cc0aebc75f69008ddb67b5bb598c5863fdae4f5d2486b449f8a690a85867aff0eeaa7b0e53eb077b1fd611d695bc88f615425bb6b7ef051487905c457baf2e36554743762b44bccf08d526312ad500d4ab79c9e3d46c627a86b03499ec263bf9654a73180fb862640aa34be8b8e6d3bf162fa67cd5fa8de00df6ca56bf66075fff504d804f2a5af1a42f3a2289a5535163f54ce5dfdc944168e0fe8a8524b4deb929a66f94d34c99a021938b09e25363c09a405fb2dd639744084428c6bde89829f7d603536a0368aafbf280ebc5e0498e274d9dadf88b7143ca1d19f178804a22872b64133e6abafb28c9d05d027c0e8718cc2c0c03f31403cf4821facc4c8ce0a9281a3f971e42d4062090fdbea60ce4fb3a397c51ed086cedfdce4cbef208970e6f3547f7b250442cc15862c6b5e53839e7f64942ec141a5ca9df780b937f92b8a630ab136fd51d3a6d723f6f8dc345b668728f99dc68980bdb6478283fb2dc08470535cc336663674d59358807fe7cbd7f382c6bc97d7b1ce3941156da7cbe847a87d86485526e590666fcaf430ce459c8172bcc03c947415986843796fefadc9cd9b8b2d3341eeef9c35b44a2e5a5ed0a152ecb09c8c5fc7eab23df93b45b2d9c0ed67f56b1f16954a850e322139ba92ce1c50f3cdb08e3152c18e995965ea6b4ca7079565b2b8ee2c1856b7666ce36a20815ea9e27b50ad5b256d7bb0ab665c4d6cae4d496851a574b4cc1f177c7e3de35b631e56155ffe8ddede4642336287e464fcb8a779efc04c44ee1f40242e8ffa480c9dca664ada1e3bd8261d71a6aa2f537307951b8f3097a27d820bfda02f37ad85716fe26605d70e92d5af638abfc9105cc4342d5868e7748b2550eaa54c49c96bb32bf35e45be3d188d73a44739247808f572ad11f19b91ca0d2722f4160f24cef7311ae8ba0d4b42790a0308b02642f46406a67c0ac2cfc03ed4335151cde433ec4eb44358cf35249b8d2c98a7682bf8ed055f6f08952ccf590ec5dcdf7c471cd40b4d213f91be176b7dcb6dbd244ef976e979690263cce25a70b496412179c18e8ecbcbf5487d28355589dfbb0992f2199b3454464314c99f80ae025c868c909ba279975e8d69a9151163057833319e1dc0975a8608cda9009d26c08043e04e1596263bf8f084059ffe1926423a0a4abddaae414de4502a649d57a3516272612390eabaa86fce383585e79e94e359db33684ea9fba0a517ee7b5130b0368a370c039d54d693b62120fcbd65285d8f4216f95f3f3928723896dd3e454478f233b014011bf7e81ac229871a79a9c04a6b558d150d45db10ede2e366906dcc6b1f8c2447a26e9adc861a158b2f5039dd5d1a954051ce31c0da532b952fc06b53b2ed4afbe9fda6b0152dcb63899667dab5a283c5027f22c5521f02f0c18c39d312b65d34339f86f3226e628d3f847796c10d5aebaa2edde2739decd6b5b3b53f76981313e167ac477c316e04049b99e5e45675193b4a5d52c708391509282a2883ad16867929f4d957f675b9543220b24d7e6bf974ef6c71ee9acbc075d169a35ece90d53459ce8f6899699c44efcec819cda42431c02e8a13d095aeae01dedb48bd9b1bb2a528bf535f2168de78d1724a171b12d266373bae707abc6fd5c6aae0799c0294bf60771522883c45206c1e939a4e582f8d7992f0d1153eba2a46f73ef34f3f14555bb11eb06368b3977f3dd0bee287850447439ff87969e71fc670ce74d3b41bf64a1d6647cfbbf3f3d6444d5d3bf397b133954002fb083e13a28952111317708072ecce36bda1d3217fe5c6b59689e2109e5de1453a43b998aed3a2ca163f5ba2842d6e5603cabafe0f5a68b88d55d4e69d7859b7844b07dc4d91d548bfaf0ae7684765cf9dbda5bd6b7072f1deed32a981d2907c65c8c7b60c8c79cffb6c22cadf3bfc133ec719226f1982ec8d1790a2de61248528bae82218e1dcf6126578c91d4606780e1ccd98eb6aabf7358363ebea5afbae27a5490bba66893b627fb8dd7d0ba4c6093fa96cbe1e6a987c769f3e8b599f2e54bb7737bdf9fa68a1e251e3c0020fde71f1ca6d40d4e7262003806fd7e2d7035ff2833279ee9d74db13c07deca0198bb53545e7fe69000588e358f87311669e0f989d7e10b9dc80b21fe0bfe2aa16b43c04d81d8c161a4439a7101a2a11b752fb677a7092dc454bd427dd959158ae8495c2215f369aa7cfb01bf62743b2597bbbcd25c6860755e7c2eaa55faa3a7c7fc573c4ff1e9ec211c06ad54d8931c3ade5f5752c32502abb775664caefe3052eb514cea5b0ba83e4b9990bd687ccf8bc7ed4660225adef259f8781f1e8dae00e652cb462e254a71c05c554c8c8812e378f1ec9d2f8fcdd5cf70eba9a6fb36f805774439278e1232366e4cfcf48699f7669cc3aac7f6937178160a8641460e476203e8ca2895df82765b7f74f274f7a2483a1ae2dc26fc21213ef8a0814405bc05e93ef40bfc041e9ea3c6b8e96b3e93738c1e904ce9695411f2132385b98a09936becee3c43b51fc2829ed2fc1dda3ce07f033737e86c1345528b80afc422525804d0c86b8fb51fb46531a4d043be0bdd7ab8cd2658a4c555e685897ea60c13623db6ceb6c969188bac1730861d3e8ea7699f85d99a30f6e9f393bd829ba703676b02992e933557f2e227a30e6f1318d7b233841d60c6c54d4bc7114d4f8e52832d9cc08aaff0eeb7d3475622d5abd98c472b1b13e9e77903648b00c0f324bbdce6676ad0f4c97ee9f57bd3369094a5004ad2488dd25ed2af7d3dacfddfe083ee33c12b43bbd108e87d3c4f5663031f960325e09b9db1d0d0f40f3e2903c875c1b1d4b58d7e49a9bb608489ef09dec33fbd1dce136e6cea7319b2ef1828dcc0937cd9e86964562fd3d38b1b17d16e022487de01788cc38fd9f897c591d4718f3bd803c0d29648495b6f7e7d9030cce6036b7a4cd595c7dd522dd0c7e7c1e16faaa9be8472539df74d721b66505606cc07470fdcbf7cc300ea326d0d1a404bbb07c849ae427494c20adae57391215e626d7fec8a00de4e22783d5c78b49c58ecc2175dd4c7621caeda9e461f3c00355cea04cc1a00412d61b513ab65bd260ccee839987aba1595856fe61147ef16472879a9555371d29352210373478935cd307bd52c390c465d2d3f00ab01080653545e632ab83076f649714363f92138fa46b4a96981e287ff262d2f2e8a425d4dcb0c9e2a3c94e5b2bde87c273c2b559cd0d3aadc2824aa534fa734b35b56367b64655ba3242ac782e2bac0d9a6a71c73ee733c317ad0d283e3d5d1338f5cafc1dc5fc3e85c666fff86716ae563d9fd87be681554c95069c407f5a858aff8e08dba8da48cfb602e4895cc3c4c4cfc7fbac1cd2b98c1e2c3c0968d7afc948de0220b46c6e80fa1e59480b4ee0efa5a5845340f866f450ec9f6f69df2ed1864bad1d06cca0ff4ede4669935ad937d44b4efcf3b18991dabbdc2b350a01584554753d2a1d8687c715645dcb46f08ea3e63bea95ed811155be4f29269d88805ff616d0621cf73c76aa8bcedc3a6d68e6f3e514703ec8492f8886d249233350e0fef4bc43da70fd4b57955fc577c6990dd75c8f7c75b0b1ad0da2d88e03e0ac456fc9a7d662c45701cf33deb0090c8f67addf1d6b26f7807a3dbfab7dd5151da2d45c4a675253eae6e9abddcb2757fb984dac065abed13cb62216dd78eba6d962edeccc2ce736570e43f95a61cac6efa7bb3c9e6864baedb61e3a43839f73ca61b52d60330f92532760fa4250d1a02a68033517c4347247722b78af8582addfd1463f84d06ab003da0f10f9287939e5beccaa482a02ff53548a79ef3e085460960c9deb706d8a25a9ee06929bb977b0f52d312f155c28e6304203b4de0c4e46bdd9e1901a6eb484453265da0f3d7907c1d7ce4f433570d88aa2f518cae1a4da039ad86300be9384839efb6bd841bbc0038b29d76973cda8daa193e2ead319bc58bab4c54a53620e4d7989875b8242d4deb99349c5c05acdea8c13b546e916abfa41c0c8a53cc90e5918099040b69ba77b99a57dba945dcabdaaa2f6ca9393143e7981a471a55b24307f79b40f08487df1d309bdd4ef45238fa206e396f92b11793a284807b0b09e27b36b8b41fdf629dab0cf680f8d13c67a2a633ef03bd571a756edcd6e5f048553e725f13bcf5104b6f7e5e3d97436514507c034a12fa6b096272f2a9b8ba49fe8215511a8564ec4e41e52b2813a86b1b42a52bf44ddd3c39c41be0976849123759d4f59e310c669ddcee0b71b00459ce8e87f434dc928eb86a2232db25648812cdb0dfe8f74957c8349dab90921afcf57cbd3423349569d7b3fff0f3c8ff4c4cddcfe800e92dc2a43426df398f806c99d7465d4f15a7275aae3f0271295f1afb4ccb4236c0e4ad30c88042a8d3e30604abb2d50fa9b1219418a5f689a5947ef7e4f256256372e6a5a194834a2da4eaf036a088e57becd3203c8530d286c0d742fda5c3eedfc77d93eabfc41de681b75e701a77495ae6c4cdeb0656f285d1ad6f371716f8f80d8c186bcb8db7411e799059214ac27e425ad524cf12676947a3c0c9f12b752baaace7fa737787a4874ced35828908d9075ed38d5e99b94668e799310077d475987cb18595bd46f60298087c1810c6842997dafe54e375d9dc102a2f9349d3ddcb8e0eb563d8f27082b4abb3d64f099fd90cb553996f873dc940542974208d0a2ba20d2d47cd36c7380cd5470261dbce64cefc0fb1420c066f6ae9b9bcd27a7890012d85a0d07cedba5c57881777665df5b748db528529c73053cac44d498f9c7b2386b96ecd97c761146a9001bfd665a818b915b4c622f7733e4fbdefaa60809b7149c994533ad782eeacbec34a1462439cab303dad4143e7d510c8050c14be32c0a9414fb57ead19c9a5a922b949bedf2acb51c93ac193c1ebcb722dbbeecd35798205b3203a57680eb0e55c2c96f4e41d68d4a991f846d302d8365c8a7046223fbed87b8d231326faac6c6c49bdcdee3105208dffd220d2d87122111892643017ef947f83c9527f0818d75b446bde093839ce5512e8525d21e402c5a39e805f5d64bc06c056c115212d44478740c76623712c1bb8002d2429c72531f3c617db29ca864b4efc4f09247863e84fc5d2ed0ceb7ef86160648b1bcd6c0fd22cedf538c1954509c18b2f3b70e356afdcddf0840e9bd117e6482f1762309c702c3ae59263f146e8ae9ab533701eb9eb44ccca1a32c1b652e077120d42a3236420ea266008d4767c9c45cb9ef3428dc1f7e80a50e34318c9a0e3b19dcfbcd36a1f975eee5de103a195ee469c3a7416c5489ba647d6f675119ad065685b287167c66e695ea9f3eea7e353dda1c349c1fa85b2010d7afa737ea30172bab0097705863eb4a19215442b261f0775a7435977f3a2d0d5156113c5c8acd6139343773691ac18fe1ab480697f52e50ecf7de4773bff1bdbc1c5ab4400b15f193a0e7d554ff9d0ce2fe86661a2e8dc5dc0342a572ac60153d7775562f298473c885f5fa114a18cc15227e2754684a6e27db196421e865af0546d46ceae11b236795bf026fd80ee0af2440a1c438b390f9329dd3039e39dddf7ff94018ee21ae4bf23b96dc16c7d44028734d223cb09094d0fa2cb932127c31fbb19964774441d3ece57c80b3c47b1d7de1e77625a5a965b13281bd99ff18e1cece41439ecfa1bb06870e8093fea52e3808f94ad6ca0d24ac46229746821f0c17e928b2423667b0d7cde57299e0dc731ce92d95f81ecc561f644de47c78f63178795d129a3af9d449492d1947482ce83f3b8bc7b5b6bca60a74fe695b997bb2654b38d2a93b10b9b36ab0bf7b6dc6c011fe584c76ed9fd68e4f63b672aaab4831da88057bec598db234255ed7b0d15224b498731ab8846285f901c5d7dedeb818135c48926f555cbf6c5e24c2dc005b27a21df1140e2c63e6fb2e5e7fe3dc7f46392b2f22c6baa769426bfe4ec0ae8243bcafa0fa29dec2771e11b53e1c061cfc82b729b286804ccb8ae26402f1e9bb672ba7eaf692fb5f7bb8f47e36d6f64a4041f69446fe4db75668dcabb9fbb893573f1fee42d49267a34adfa8f78df2b5c4ea802b4913c9a4e5291c70c48f417c7cfb3e2a54acbed9dcd9e1fcccde8bd87f50c02ccab645141aad3bd43952426107f6407b6ba096ea4ff8caa2643d887ecd72ca2f4058c813876f7cc9cfde0546fbdce100faee3f4262918844972ff4ef3abdec60b15dede6140f1126a73641db296e434aa42192b2c050a0463be1f07f94ac01f07dd7f77ca5c88384ec46e0689c79c966e6f4e7dfe182574d52552730ae28317f89211269511c79d4e82b4faa48a14983c4149b5240e14a72d01a80b90092f304d7366365c7e4ba05d79abf3b99577ce09aacad4c7e76280771c76ab089e29c2634d6c16e92726a8987066c500804d2665b7611b5b8f61323b4988b4dde323a6579ff6e7c44bef1299e24c7f36887f2420f85fb489949cead7347adb27b9d210599e3d9900e0a38c6b13f62c421d0619cb1c7c633b1ab9d187ff293e768fca628af44960e778e813fef5619116a30535b141086aec836f2d55d679a5b2124e6c2527df9f102e144754265d8602806fcf73214649d1fc9764b93785f69a734f99804b14fafc6e2b8a45129ed94078abb857861ec2842e81e1e44b6bf1d616f2cf551ad66c105c4b4f817aa6c57f5612e0ebeef476083438a144b8828bf04befc935180ff15736b3a180f5f6feda60e4c3e3eac83af3f53aa2116c7411b6fa059bce04845fcd16f327d7a1c063588eb9aaff81de05fbc9254acbac43bfe225f97cd7fa0904cc319df0e7a2661654712f3343c87ffbd7f68311eec5eb58ea2546c19b7c052520981087a3f875475176150ba09d8fdf2a8b7acf53ba2082e31aa80795328afef5cd947d461722a1bcbd35d7aa4ea9738d1f97b1033c45978163153f2091ccf4f8d6d1f391211bcd91e1c8c4780a734cfb8c7508b8e9e6cb4ddbbc4ad696fe148af8d0b4ec0ff300fb4eeb623ee19c07c700d1e8067cf7b1ce576b5dae7441bba55bdacb5ff0c4a70270ccd8b4452f3bbae6ab24ecbacfda1bd862ace242ac336ee67d888c7b452237d70f136b956348ae8db857020c2bfa4e8c3d055f416d6dc9a61688c08e8c8db65be6928c8223b1495dd0b0b83ee8dec1a95123c49f61355dc6b5fd504a6556e596c5ea4978dea02b9444613f5a0d6c1db37e8f995d9b20567b10d61e6a5e6dde24a582cb98daa91b34f6322ee09db5f8445767ae64895c6ff549303c76080f6201cf431dcccd222a4f6f83c2aeabe3346c1a6db80faafe8c4f9bb3e98facdb4f81a825226c1f7ebe5f764325433a8e69bb8b0b6ee0793879439dd86d7b073d42933f5e47e5b2c9623788f86546e397f2dabf63d60bdbd4fe81bad722eed5730bd037783c92c9c3b0642534c441ac8c88826cc2085522d69593b54652c592fbf30907bb5eb386a84f9429add84dbf69215886e3d6bce9368fb59d68532366412cd00abb8b213091a1fa98ef5c2a14296e2daabf1fcda8f7d97b107b332c5644d8ad9b3766dd41ad3c83e4a9adde29b32276f4df7c12fbefc0ce78331f3b6fba2f94990cb63aef9a94a9b2b88e826ca2485f725089061916e3b06c61af828cbf8153bb9ef05ef9c4cb22f6969a206741f46790427802ce6445b56bd3df7e66c46c5562a89b5ba2b897512f61caa6e01c8b5b857efcf85579b2c59ab8ca1a598ff82320eaa01aace024950c075153f564dfd22b73eb1ec551ba41cdc0248478ba803ead8ca3ff97eedebeb43864dfd7e1f6191cf487e98b516fa21b4ac8ecb0999cf8cd2773a6d54a822c203fbde24d952708cd9c21c4fa2d970c72233896fa9286a76a2a3b1fdb4851d00f6b9e1db0a886ddc72ffdbe960f978914df9a40e6a494567a3d33e30dc6c1e9787ac598fa95390ca9c33aa137e06a3b3c405cc3344fad305f449a5987a90dce4f1247a50de083d3bf4faee893e4ad53a6ed196c2fc92dacfbefa1b8963502dbbc35313dbfd6b68ffe88f81138372752330a161849f7f8a7df53f9003cdfa9e67c10b77fa1c8fe5310d3f669cab085b57cf6eb9ea9929203daba90dd5480ed05481f062cd1ada13565257c192ebe612c39582992baf833740782e0db9097322fcb04a0d07fa1305f3bf262a2340546dd87258e205b686821eb99bc5251af0284904c7a82b4fcf1c000d0c397f732f1e55404197d60aff1157bd9035c0f4699e1fe385bfca67a3e785d50af041fe28be0ba89d17aea461e3d4e98f6d37621820857ce832c7a6911598e2e2ae9f6d1bf2f7cb6230c549d78d306a567b5a649b94ded582c110fdb9a0fc7eed9d64938ce0f5a2834852985f5bdde105e143facf1c0ad59567dada3f8a036d3552e1e1761f770797ac723659f530d17d51165172a43913bcb2488a407ad8371604a1f86005a651b40cc930d9b79e29a7aa18b623eae46b98352825fdb5ba67d58b51594146655432e6bbe926e8249ec01c842c1e46de4d4c4a2fef324039c85fb6d7e80faa5f3ae925cf947cf281710104a37ff4fcf2a0f8b0d458204b088943621c4fba1d2a3faec39b9de852be576dc230c8342dc959feec5350d01f43d9932f94377b4ea48ebf1e7989310a1d577b7e3dd528f2e5543241199260ac83a0fecaba97f5178e04210bd4223f83db7022a35cf7bfa0352f1982b1ab8a2b996f8a5314ef2c53ca3e3c76548719e3cf8a39dd7a139ee86cc05689fc1819b33ac684faf29c5ae076db5fc0dfa8a431c64b8ac5cd2b85addf2be7f961c4294a8f244048f6083713c5625f1bfaef498a6f3b5dd18985d2061d43cc9ad20c6316a5e1620c34a91aa741558fe997289d62283220fefdf507877a6851e5b12a0057002b5349b569332b5a51108b3bd3e109cc1393df6d01fb7c5dedb093fabb07ac8d144c8b2f7abe7094ebc134b1bb7d2e5119c02687824fddd865676cde4c2ed64fb23d6da52a09bdcc25197559617ac31030c797d400f08a2f78fedaa911b205861dbcb72026ed120a3534f2ca383ca723f0cf617ea5e6fdcf36ba7be489dd71fe1d63f4aef31962df872a2977193297ca93c214c019baa7cea9c62d086954d2e2a464b9d62c2596206151e1059283631674c4a886297cee55139d20b1b87bcd2e3722aff43fa7bf24d9e144173a1c8d93bccad48af2803563aed3c72ea348ff9da61915bf06a9896718ed3020377671ff3ea192cf985ac3f9b97313c4364b2096e52d96049086ebebdf966a075efa2ac66aeed9782a38dcd30536b24b3b85e8979770f6ce0ccac2beab984c953b984e950303bee5bfaeb70da9af3580283da22b48289e51d16a86aa8de9c2db7aa201963f4c11983654e60a8ea416b761cb5688af15fe3f4bb67fd3488fbc7aaa1ffacb7948e3e36233da04ff7719a634772854cf5b8c207958adfdaddd09f32671c3c8c8819fbd0980590073e88a366d78c403a499247801f26d07ccb481c9cdf50b3b685875d5b6551217bac6121044b9929d2e4c75674b16622ac0d259e70f241c2dfd2d0fea0c0bfd1bf17a1afa360d19715d5797ac537ce33b0528de3f63d3e14592f4cbe403f71ab5b2fff6ff00cf2ace665bd13701349e17df269b98051e043a7ab8cf1fe0752ce368957a7d3ac82169fa8d8770fafa5579580599613ac0d199bfe9e72766d385436a1cbe4198c207c1deaab6cb493b17dca004cf2b1dd81a9e36bda50dbb4ed1b006b3835871a6dd742531f1028511ebcb3e1dd531a7070d9c4b2f8ea965b1706c48ffac6caffd3dc915d033206840d003866668e1b5a5698e74fdf639619954a7c9b5df7e598180208f934c6de7d51d99a02a2a7017100a03fe8ab47cf7a4d1f22f77d3392a66b24201e653f2393a71f7b6d0e487466ff4e8a035092a787af88d76acccd6aa0eee54c353bd4a85abb3921c4731a5fdc4d0f5605cfb85ed98d96c31b79735de606f49cc1955ec998f8d3757c3dc5a3d9ae34cbb8535c611455b52c681f91a4f10158b38232bfbcb2668becd9cb119889f6c8b65f47d4c03ad8d28a70fe757ad0086830bff3cefb11c8ffac97aab75efc9fdadf6bc02d0bdc6049b6933c045f7a727c834f6d5c6c4edd7f0e7ed915fdff8c7da7e27548234a6331cc71c0dc5034d212c447b5d9fd863c02ef4ecbe50d22b47c994370d29caf5e326ca1e8c8777846f3604a132e1c8125ad7f44738baeff8f339eaab5767fb26f20d0f16373ebf729fce56d53d81a91e1388e708462d97e4b4efedbc8a97f757256824acf0d765a2924c8ad5ed39ec9fbc5ce952ef835ff0f8af62e22f64cc2525a087a42ee0aa8cb0cfbcc5221ccb04007fd802777a02f82fea3131557c08bdebc8a04aa293be952bb1e9878107d0e45aceb06814410fa4b7cddc85d0076b96c64acec5bd1cd98c90a98c4bedf808feb0819bbe1422de4ed4a6fa5007da23807e716e2020c2346d822a6c175ce2c0d892297ca36b1ac172c933a1dc693e498c72163d64575305d14d21d0f83e0a8c231cde71747c0d67bcb05973ba8efdd82b383da368b15cbaddf3186d54e386b3c5e126660aa683d91deca9b52d095008b107edc30233d7ff9fac556eba550e543a63accbe0a1dde77a5e10df6e33367ec572c98f058071356ffe907879f901f7ad2162609f26368f6e9606ab71bd1b262295cfe1961f129c3504b2466ed02b9c609e581acde4d106a28109fe3c72a1cf7a0d6ed9f24b9da2180ab493569617731677228f00d680a4b1476e6871965672d9a8b9b7ea27399680e68d2d9e2a21b41b94486472099fb60cf61a0ccd8356fdbb57670bd95f4c478160628ba107322570194c91b43566eb13e10d3c13665d601c3458c0d60e53cd61adab188952558df8adc0cb06ac097eb57c3f788b0e1c3cd3522ff44898ebd674bbf5fca539b71fd276fcff39bf72b14b5f27f9198fbfee7c53d024e59ad291ebe8d140d1cc1591820fdd0466527cc572372242c8cfb4788f1cd86fa9b19d61b7dcb6fa7fcfea6d4dcca15b75e311083ec6f754dfa6af7dbee19bb879aac8a5f4f01016fd5e49908ed814a5e4dc92b2527b15665c38b8176bbfb6c84bfe5a953186acae51f596e09cf142d5805aed4fd4853a728c84e8f7197029d164331ee1fa3385f8060aef4e2d49a6e399b568ed787f20d3791a603540d95b18ef829ce16a6d46ea4397e57640f248ef6b7d46e6018d29fd2c35e4e2180e2b8a7fe3caf0cb451c7acc1a0e96fd887da9cd5eac21e406ee265a17747f272f80289f378b7935c657c7884da1033fc54489311f334e035d8d0d6e6705758ed74573feb7c1bbbf9ce91eaadc10cbdf2373f286f85ff4f6ca23ea0d8dc788d97420e16e97f7edb9508c4e207166a6f71257270b8aebc42528ec5673f8862d8ccf7d29a2a9cafaab08ede672ab933e3d9be38e54dde70b6b17d39090862c719ad7f7d468db3cdbc39f8d3e2deb546f9c70a4ca6a31626c550ccecd5947573a0f83c05a358d99435304ecb340d3243f8794deeedcae7968833a197c2a1d08623691a1fd90b664713c1113bdc4bf45b28bae86dd4790e2e0f5cd9c155682dc065c7f4da336ba349da98c52bd0805e0a74f7cc9fb99d7e16c11625355102ef04e1ce114fcc12bef44de3ac2fd3a2a54ffbfa335075570ec7ce8df1887d5d652383908f52e2e9801541d810faa684499dbb4775c24227f5b1a1d8a228aea5ec53a3daa5203a66df2eb5b108fd9f43098037c6cab2fa3a19206f72f014d8d02b8984616890c0e2dcb203e3db2dece4dc0a4f566b4eebcbc062f2d09a0b434b4e0f70c581c883a5dff5f6d32383f6ec1f7d66bd6bacdc670aafe6f923a04eb4462e35ada7a3bd2c8bbde6383136681e057938164dd9519a41ef008f2eb78f605f0b01c37bf034b1d58c3e83bf2751905fe35cd999e6db3a8e047e20baacfcb0fdb72a817ebe0658db1ff89731e296e8cb59a6d2150b299c6921eaff4c9844fe1411473ca4e4f91c557086a8ebe64dc23818bd0b33f33dd3fffe56b41e1717e0f5fbfb83c4f6b27b21470d95cb0e5499de1a98a492118492df6a89134f690ff8976c6ed59300e4e155707d9b806f3fd212c2a74680290cae6617df6b265dd3acd3515bdd6fb6d62e936c0ee8bd94c1beea4d5ee2dcf39e453c152fa05ef323bf5a0b15459d317d88205f20685e64f816fa11a60eaa90300e0857d3400d099cb2cd48f05c8ae48e4049564b7e91887446574b7fec6f65ac408f9e6d3c0488cde4db5271ecc35b8a156d8d4dc022dafda0a705690f89ae053c84120069ddf9d5e44869917f651a07954590d0257033818d17260ae755bc007694fb891ff3b84704206c75b4e0323848220c198ffd38211e88b45302bae38dd0b50e80b4c1b908329228f9d30ff1dee0c6b6f3551878b165cd8bab3888ed5c1d2f623151db957044f91072cbdbb4d99b9ed0c1f8b9e1527bc289206e3eab5bf095fc957e5f66fb074c634a703fc266e7f4c3e4f33d42a173fd0e6c96d43de95efb6498e4a577fd51dc5b5c9ac8fb74c40a933bc0440de6f089e546d04c7aefc5883510917658c483dd46832c97eea4311934301ce79fd569bc61da29c0332f9d738a143943aa1d445285daf28ecc5f94c9499adb1b314e0e8a0afa013f149286455cf254969caedf86d57422a1aa762b01c354e19447f01b654b47b7f188b32f32ffc1311729a456c4a0a530590b27129b087d3ce16e87ecaafff09a1b011a48efd62e626d0976f56149d24760be2a1998d5b53a08dedff79d3ce684d15001f7a664c4ca9ec37bd9fa782734830946995c6dd27e2a7ee6cfe32cb57718044a60fdc54bcd504f1540fd24d5d52c17a9dcb823f401b8c64d058339777abc94298a80863f7e40978a949321084d09a24b600552ce2a887dce36a5529631bb4065e3e862db457a77f9d11c50d199d306e0d5fa9acd800e93687f3f47f9fb62a91e925f2221791716eac31a79b8281942583101ea7d8725011720f3ce0297ee787be1228a4db70481994280e4d48f867b8c4ef9010c5b90fd6cb243c79dcdd374224a4cd6b3ad0331f2b7ec32c19dc755092c20277f68a2bc9e6eb9d07d99196f11b81fb9fa95664249f6ef00d170329b1f8d3ed7dc3aec309605d69adb80f8e42ca51e72909036ceb2edc9bba126f85002babf224df1e4dd1c63b1a219b1b9d0abaa3da506511423fb3168bcb30010d49ff0ce2192b63f4bc0470464e577a840937eb34f2450a8fc8c1dd0b80aeedda335171e9cb58f15b342f99f23e4735d6858cb5de4c65c6fabda60eed0ccda5e8be5d97c8ad0b46342e2530845f58b5d3f1cdb03f97e2bb01edac98068163af70ad77e071f73cb02fbae44047ea221732471f3265a44cad13bae59e4d5a9165317c90e8118227616d1b5fe2fb65a9718aa1f937a052e8ec5a483c8ace09166858bfe6ad498d613433cdd5ead01e0ed346040b2e7de944e26ec968756af00ae4a9bd3859e5ed8fc823cfe3213b7b84aad91c9f9efe92ba763584a9874f8a3770d5b921547ccae4bc2e6d021839688e732704365848b18b7dec81d6a73706b2ed0455ded1caeb85b8f2c2626c7d419140e76b11f6f889e7f9fb5f5adbb8f6b3984ac9e9f3405d917acdc472f11de01ad6254caa67380480966ee490943c7f82f839fa7ef822de8c96a7b609df65bd2679d19d0d650cca8f6403f3c7304f06ccc6586b0e812b365e22a190d23b41cd59635df6a9ff2b7203e16bb9789d698cabd5b106c8fe7d4131a55dbe1a26da7e874ed868db160a540c2c771bab0927f1a90798a3e7a8ab75910233c291e35dbe9b448fb80b2d8856eac9c6eb8bf4e25e6c3783bc1cc078f05ed0b37ae9d55be11b182c0fa114b5615c1adc2b7c9f57d572773af964b9eabe9783efc00c83bde075e4221def0f185f5dd30b241e59f57f0dd2b21ab85471897fe17dbb61732b86e650732f83bba70c48900c93aeadedafd4d9177e3cdfc1ec11e858cc9a6a8e2e92aea2f30c00e669e77b8f419173caaca7f7bf423d0803a6c6ef3fa3bd817c55c75f0dcc06ede3dd13559c1f2918d41af117f4fbde29359827db848287f7ce58196b3cb0084e091956b82660fffb05c0cfb1c1a1358b54ede309e6abed5f2cd7b597f53bec55b23051b7cca73cfdb28b6f307abbd3968fc14453424ad9450bb1319db49b4fbcbe80bb9a3c4d5c563d97e8bfc9d0ca511c4cf6badbd3e04ad73784c45ff1f27bcc2012bcc59313739b1d84ed6326a1659f69fd3700b384739265c357d15fe0baea0c9ccfa2cbc9599de4173a6f3f71970c7ca04e7824f6bad1e24bd8c88bb1f86ae38d67657f034980596247f5e96b84a81541ca10b74b2201763cd805e0fa55672bbdb48c09f6af117b797b0f15a20d9c9ae7ac3e4b670a2aee36f9b83349d2b33c3686560c63780354a6c36b852a488ecab288e7a16a60068ce967d48ff01f563d8f086a3d25b6857f8912184a855726a4620d8eb1c65039b321e772fafd7df14989e3718930b9c951eb32caa61a64cf042d135e3b122bc0c19b42e973263add3fbfcb633a23b84f8c6a270c7bb99924902d0d1fc182a587a62db50bd795d4a2f00bb1de42458b77263740b5e17ec29785947f790f62370cf8ba8e8f1c47fe6e6167d9b73b6a49869abd994600fb82221f42c1f444f502b969dcafce37eccb683398609c90dbd5ebb23907a54102fd6baefdacbff6e5601876bf4038e57b619a8b903d8937c6dbf4e5cfc90575fadf0240c3eebd73aa7749d1fee3ece22ce420fa085a72aac49f60115cb8791aa27c3d5d42f0e62fdaa3b94b13ad30d01e4840bf8ee160c411d88e3b4daef0701e8c90ed03d80e10d3e7ae423c6e2d3475974a935ffb1e5541344332e96c0ffc8c28e38900b99b085c2cc949d71cc264978448e06e3484d0608b5cd74c89fd722b47ffcedf295c613bcfffdf1b6d6332122a20e5ee6cf42277982c3eabeb5101de1a85d929a6043131a178b031a20b7e4b95382f2a69a5d2c544946717ec951b3d19f21bde1f9ac47600b529dfb7a77127d1f99aa532feac575ba1f2b3d636ec1618e5961eb87bb69e7724f535ea74b32c39aad8760a93c8061b446a9f416ba6bc9de4ceb09a5cd84fa1481b632045bc1a29915c5d7458098b8c33de4ded39eca6cdb3604f8684e2d64dde0542c96c935ad318604e0242bcdbf9d67b003e68c2d221f163a082bb365883e76cabe008fac5c37ad650ce8e3569a616b7f408894677a46c49199526003c11544349842940b66fdcebac1898e6d4cbf682aecaa34b10d1671e83a8f286f0910f6547791c78af3b331c517139b7194fcf73801188f524df3f608477b32d9aeef8938d7084ccb7c0b45ef1def3895f1cde67fcdd3d8088809792eb2fbf8733bd29a1c4bde4a7439a6dbb3f7a23e43be2466b7e4ca286603ffe1e598a41eaeafa1b9b0a10225178203734eac78d9d029a95940f7b647ababd250bf221acf6dad70c9f03c05917272cc8c62cc7d617370138641b88da09e3617d61690d548c938395abbe16d4b1efd00ee5608d90a91d03d856e2bbfbfeea773ef20523df59a8a5303ff8696efafafb63f293d1942beb84a95f5eabac00caafcebc552abc87273f9c4ca52361ab3c996020501ca3af5231785a9fecdb97a1fd96967e737f72c6927d5355f5c4fe202bcde67924209d84b7af32309e14b1f486ac13ab63c9f7586439c27ae70155b4cd51109a0c5bc7374d1e5ea6e1bdf9b306c1787c60fee872fc3f8ae458ea8d515a82e333a81965b44e209d1e27134879d9a98750c62a47328effb3ad8e7ed9a333aad743a03f31945b2214f60b0f656635cf923bf07f0e3a81b522d9d3f8a9fec1b3eeaa64b620f3394020ca7ef530496a4a170d88f82b7eee8f45639d40c48760a4b73c745b3b8620464fb58a1e4ef01c091f33ceda01abd58a33f043fb75529876cb5252c6f3f8ed8d9277c3edc0dba9369bac2689a02ceafad20b6024448061adad091e9e95c768a01f9b786408e2194f66df93b584b11168e411dc3235e60cf9f2fa3166c2c87c34030b09f5e6a9d87935f98774b7b18c77c3d952f01ada168ebd5cbdfe70ce958751b73486125c542bfdbc885c1ebe7d2b4378a641e26a6a2340944b44d41969e68ff0f647170d187eadbaa9b0a2d1c82f49f7839669b140d95d3f4cb122841600be9312e5d296d16cd28372f8bd3d506b12db9d6d0332f5e3b75fc2e79758225be714a698f4091c5aa88b1e767a56eac2777ac748110fb036563187be6047cce88199d97d956801484d7b12f9105839af656cc6cbe5d9b903eb359493b8a2a7e4aaacad625b810ac40482711306ae4024fb0296e6ed9a003b8dc4ac5aaf7c98c65c788963482dec8f4cfe0cc907f09783ebebe56a53ea5e1d00a2b6749d77e5c8451fc8ce2001f9c699cdd53958470f29ea9d36e2e2d3b73cd005502e001b9fd4d81c0b0b837ed398d867d62d972f6463cbb6f94061cff30068d3c4ecea208e088552834789221e50584d3733db82fae660dbaa35b25405839c9bc7175251de5f67fa34813c3f59b5b94a7e447aededf94640a26cf99837d1367afcc28e212d4b5e949c232354af2e261c955ad6fc05b497eb998dd23df642fe1207ca091dc9c4636dde58efb99efe5f272de02754d5bc6863b6cd18bd3b48fe09ec5813699bbea42d731465683b3387f27b9e5f57117c446304f708c76bb5fa523432f3d9ba00a826e1daf577ecc9de4525a62db229f5bed251a5d5360c2fcd94808941fc126081757d78a049261770b777046a66541c09158a46fe5b99b8be5c62318ad9e052af0a43e1a1f37a1b051bdecfbd136dd39976413dcaa8667a410c33d986c3a7d8038a117f0e18c273a3a7da8bb36097c319ee6ef9ad7d4193cd61e87a682ccff108284aa79914e61b1128145dec7e48888fecc1eaaac6bb64ab9451ec0d648b85c538aff41534d85bf614a4e9cae829b381511cf17638b0cd45353ad353ff88f96426626b53437a4f32b59f9c44fe991c9c1ba0e95000a780e7b426b70faa0580112cbf0faf61650293ba5148c5a12e3014305b5645cc95fe49bfb013e94faadbc71df9874aedaa2d6abe89e58bdb80b6a7c3d58c0a4b716ed57be81d24682c3d9a8226c9fc46403a015c4f5ea9f712a81613e645b422a611eaa4028371af44973d8ca7ad66cb0e12b2d7904e5880f6a2df1a9a5b8796487b6f70430b511d2665d98da284a10e3f0821308039fbaa455b2d510c9ec60e32160e504ba6b04af73e56ec095f35b2bc00f9f62cebeeceeea8ac4e117ba0d5c071bd797dfaf36c346d3aa3604b5b7628bd13293c25a01d07d3df5e754cef4521b362033ef063936fa762d5f48a8199b2508caa9f042807c139bc54d06c310492213444d79916c81e57805f75f51bf65aa4aa7c53e60e00cb61a3376da9894d91d349bb8b9f6627858fe19f9af707f938c099760a2bfcd73cb26a43ce09106e0c9d138f9036cb9e09a8e12bb9605378904785053849eaa0999d01bd7bcd760440073696545a7f52b1e0a6c43edac04eb9fa3b521fb8a37b47164ea867d87c83002b8ba07e3df244704efe90c6dfb226147b489daace86fe8295a48b6bd28fb06de8ec42891854f796010bc045fdf538c2e79d2c3a6337a15772f71de77c424e6cba556f5e5aa1cc5e5072eb854d9e39b1f90d41471cd8742b35db2b10ba1211fa4fb25d5071411189c37f08a0a680c36a3b9e06c7cf3fe511fa4ed538c4224bfbfb01777cf98765c5228248c9aaee9086c7835ceeda8bb0202c444a109bcd180efb2749f9b8189531bac161b3445ed2b34cefe8d677ffd17039139ced85fa3e845d094c98f9fb5ad867a38707e5156fcc516db91fc503cc8bcf2ea0cdfec199ef98779d4c27ce48f875ae2bafb2ecd5951f7ead101b69f377c8406d494e5bb627b5eaf56b477366fb06ff326e23c85382885c7159bf56caee625c49da1b6ce6f8c11838958dd47df3a470fe29193c0ac152031d9f79b435179162f5e4b3af241704555e0a643931faa8e15a2b7a6d2103220a79f7bc6cd0fd83aadad328397cb0978c5cc9cdf5ed73b682f9acd90da94602a1cda82676a17da40c646777d6a7e03db856435d2816a423275592c6b082367f377c423010869e4cb170e0a41ddb31614513857ed7143a049d791ba544b65acc562cc738179a2783672886bde62843f3e79ee1ca0b9533f980f2f4d316c3eaab10d33a7e6b57abaf31ad3237f07111092268a6e6e3a56e9e2948a94165ffcd7ea471bfc7df8243420912eb5428d34af666c096b93364d543e49be4744a77d39cd22578dc2f667aa9668d11d922d8e3d09bfbb9b5c7fff67badb2de78770cf51ec2d621a0249d92853fa4b7e1b0c9396a32c13c1c4f1ef01235862a5de6a14cd1f8113d7967374fd90846245448d1bf9b470416d3c48edd6478c34a2605e42b57f98627c94b7c8fe37f7d56bbd595d6c9030953493f6a6ca977d814656a72d9ba3f3cf41ef718e3cb91f1536d3775c891a0c3c55357fd286fb069ec20416915e06138e3f761fc52205cd63a86e525bf0e102748199bd8566619ac6e07a82cbddc44aa7715949f4b4259b3bb95c133922a4602c7fcd9ff23e2bce88296c74ed02dc062e785d8afb73eae3e6f4ef2cf8ec6487aa7715786530fd38154c43933504d0ea2cb8fd8b05691a6436dfc3450fe2322c757cb9432b1d913b46e5b9b9cbf9da34947861b4cb45094c3de5841414a2d54aae774f357eedbac0a91f6bd4ed73146042e8060213265bb7565dc96f68026d370e7eaf1cb8fa844d7f0f908d7592f7166cfda4255f42c3ae5c2d8b662c8da850afd9d7795066edb6308f7fd63942f2a9acb8370f071ec79b32ad92969240adcd7a4f0c441d7564de6241c3990cf950f78492d7223e4ff57e2f4ae6cd7a648ab95d5634bf53a650a2c23bd797c66af73a5d5d3f78fcdd0db461741b068031798b763dd31b76efd4925330bb1aac0ed417edaefd9d3394258f5c9e476d552283dc10b13e21cd04298b5293e699c8d0f76fde16a51015b6d9956f7df659bd252e0269b6c83b13b92149ea069c43776e48452e85881c87f9fb25cfc62129bda7feec9ccb5ad48e1268307252fd1d52d662d9453e1774d080dd49f292e4ea16474de8928c591b35d49ad93becefde5315f729e4fb865ee73c67767b4872396b808a1d8ae8369126bb7d4ab8782980120cedb11e8606f1a5ef0a48cadf3adf73d4bbc5dfff32509077523e1c01a6bafce4d6bef9b05ec2c4cece8cba4ad31ef3e5167e139fa0f4d147708354db34147bc2529d44f7bf529fd1b9a744f4fc23f0b1d3e7a69b1872d1308c956c0a46ed508ba17d1e58fa311ab5c42daf5e9855ca167cf0788149e5543e558cb3ce1d918b8c44d2a6147bca62a0454c9f7d0753e6dcf10a37900dcad12795d3c09158dcb4f0882ce77ee9ee7c964ab4f557c3305f2c0d73ea93a8252de05035aa7be13724dba38d88256b2faacee93f6d9c55f0ae1b09552f2994492726a8c013dc029d35202d1b2e03bd13888b11ca13a7367fa144de734aef97af17b2532f453547695d4b3c55b11e070ea50683a8c89b3c632f09205ff34d163e4d8f7a0e45c7e826c79dfcbbb845c17049db81b0aac467e6dbc7f49164b8e0dad5279e4d4de5c73fdb41b89f4cb9ee45a441513c10d3a18a1b33d234ec7c6d373a0d574cb1bbe57f9a511d962972c57ab39020786c626eab27077405b0994525407da650f8941cfbdf5831914325d1eaccb691ad60ca039db91ec4eefc2f2080ab04fdc10bce479477b4a5a44c807ec857c28180ac19f9698709b2098d0cee11e9aa3cbbec9498febcd30ba3f76d592d94fae32a1ce890e098d4e6a91b3b64185f918bc87202df17594a532ef4a42ae99235dc83f1269179ae299a86047d17040f61eed4ce5879ed3b9c520adf65f74d2f4a8c4953f2b4513ef6ba807bc745ce3713732775a92592ed68542bc6e098724d8aad781cb9a8a70e2fac1355b099951320b3a3389c16b75833264d690d3a38ba094d9ccc1baebe68c0ca342777817309440e2e8db4141d77fbf3f5d405b9948a3407f18b93b632ebe7d70532fba435ae29ed0a17212da23fe58794bb7a8d711400e9b29c2abecb94cfef7153eaa72a5bdc2de2c14ecdaf6f610042ee8013716ca1c703a0f3052e63bd12da865095c3282568a79d5e51efb077d2cfb0d9c13c1075ae1444338feab7bd9fd2a679e35bdca6b8cf674863f94d0dfd882684e15bd3e54dce090f45766f562078a8628a427b80994a4ea853784340876d19c5435f27127584444cb15774a26613ae7e9759f378a06d833c1ea2e95a78188a2bb1eb1e1e1755fae0d1c256f9a801f9d48317077cad8efd9a87e0bdabcd873b3682b8a702de272e66b2317e5e1d5ae9989555ab61d78de0399cdd8b60267953ea3b951407c09c583221ed55644259335a95c2e8bbe80c1a35cbddbf30547d73d9b220bad5ce852ac8ae300e9453913af37764f52e1b0a6d39d792362907e313b616cfec851cb87e7544ba24da828b469116a17d03c9e4186b1147fea3efada7a8fd10707606326434bfe56bf7c509a0f1b6a1ca551c662df0153db4bd7b6ac77c1f92a74664ef846a1489a4c32a8b70c7c3c5931cd917548a5e21a76aad0da226a459a6f974594ce77f96064ef0b8b46dea55687e4781092d82a4ea2f4a9159f2d647adac2b57d56b6fc4956a26610b787c48edb8b2e6437f3c1835925aadc192ca6b96a8e55c6d105afd2d99cba84b1c087810efe6492edd47fb25b6b6c542a3506b57f4c3eebacc7e7ca8ef0c108fcdf4b5a2ef1300b7e7b06429f24121a5ef358c2697ddd1db070303b041f56422e81a0a7b265c63c2143e9b05ed0b0effb1ce6246a526050eedcdde3577d0db90acf26663410f3dc4bc829936acbddc0055390c627d4a713b8f5eb9f382dca835ecf8cff360a011c343414f8188de8ec648706a3aeb3ca8f563b17bba7546200806691f3ccf54ddd065172b750d270d256b111b40ba76b43b0c928deec7f6d61621740b2d990e94f8bffd704283a70f719327600d171f62ccaff04a29c70bff0893f01fb06309f2edf4c8c749f1b36b5ad2848cdb065397730db67f79c7a82a65a47eb3d02b1a9a2a28a2492bc884342f62d4b4c1b82fecbf1ddb5eb85e5bef1e783a3981ab0f6c37519d9addc236005121137320ee1e512274288c588d90a70867028af1b1c7c327211dacea38136e2878bcc517bac6bb8016d28a37b7bc5889d4ce5f06a3ebf6489ed358db2fcd6ba882c92ca91d5a2a80b9fe88594fc2018bdb98ab3cf7090e1d8c3c25e9877fca2920e84ae8ccd5d722710bf834e682e81effa3f21f195957f9803c23a5ae9cc98b259fd40dc31cd27341ed1a29c6ef0a3b23b73b1c7ae5dbb3e238293d3d164cbdb0a9e06e91712aef53bfa5c94b7d815ca06d7dba9bbf265af96cac192deac31e49f05810c767acdaf675f01f8e574aa1204ff15cfdbadf24960bdfaa7000d00ab7ebab208b4a5a81628b8e2a402e12d8993851b67490d5e9515c52744bb9695a2ca0811807fb3ae4afcd0e33d0f284de2e07bb5b062bd70083c83720817861606119f7136701f9e4e72c302e00d371160aa88ca7f9582cfef20c1c1ed6189ce682a5f9e7f80bc45d7042382ab8d2348727d34caf4d21d87c62f03e22d32cf7e69cc419cd9384a6f3cc3b0a77056d0f803010acfba1c2ae8f725ec7222a8c274a1d48a8d52733428e78018f1cb594384409229b63734092d94bfc2f13dd3e9d0b49da9ed7cdcaf7cbc1766390c273cea02e7b308663083efc0012453fd38135e3013cd8affc258e42c274e9ca296636afe75dc4b271ccf12c53f63e43c36d565e5f9345ff726936f833cc5debe8a8969402368a49342192be717051a54128819883b800e6eeef47798991fc39beb601ec060b981484a106115780a23551eea93941c98d020462fc99f02fada25e3681a6f1eaf51689da8f8213fa2c58975294029d0f9206978473e8df00087e68e4f3958c69cbf595feb0322b8ebc16c0808ac5552f331d7c3e06eddaefe7154a229f3e915a216ddf7f618b3f07b2100bb9ff685912b5a586c09566a0d742ded1d894cb52ee2d000a5b7b2f2ee593a95e5b80e79daeed2ee34240d13664e21c10c8ed6bcdcf3e754ee1a620680b47c86210724011d52b76333c201a96cb8598a11b826ddc502d05fa06a8f9b1c37de80d1de4b635cf2f9781bf7df4a077085762699097f1c604a04da90ab96088c77b90f654a30de0bcb2a7929a64649d44d68452490b11b15948624b4788863bc35a53b054b90321826f32f4a74ebf9b4fa7ba47d5b14693032216034747b994069a5a43ba5197a7fc69fa1edfd3baa9dfaad2965ceba7a7f4cf6c1cd972f4b1f314a3a87d5a08925c3cb2f4ce77c2dfe0158c62f530aad9de453585f87d6473528062b0f18c0d42b7054616c47f3ea9dcdf13d4f492b24c50e7055a5bca04996e417eb19982f78982178fefb870ce3c152419fbf3db4b7876a23664fb7271ccf1afc037300557f1f9e07f1a7585ea4f541db7329e7e77faaff9889479d46433d9aa85d948e893509ed301f233acd4d97e9d2262a82030faaad9e2626087a9ba1184a1c7c18c7b22117cb57b534662f03bc08da68d82ecd1e94282baf797570dc045cc09d45b58661a6a831362004253d4a9161dcc654d5dee3a0d4528265b16b9112fd69051129247d5bad2d41c7adf061f7944c3e7686b1a11b7167e7b875f2a1a97f8d2070a8333728f18a1748c2f6d8a8b29b696e4f835aa40dcb249e7102cb2310cb479f86277f09584d3fe31256b428598bf909e430858c5cfc8de25c315e099db9296b21bf397865fdb7928bc884576edbbc7d1ad0e8fb9dd3689691bb051f6bf23380016852ed97aeb8dad24819c50c008836a2392eaefcb4ae6f2e84d7da43dc84a7c9128039c41694d7e31f017c41e217a230ff47674a01c8ee3a2b625d58b318a24ad2d977973293633c089d3d810141af3252abe111fd70e9db16b4a7cf68bbf7825bcd42a55b9946b57da9245fc7516cadef6c04e4eb135720fb4e70aa317b5b8fdd91c40fdeebd6daa03553740867c7929cc565e08584b514d756e34f8c68b6f4bac1d602fab91c3ba6784a5055552c30574c2525b2a37e0556dab5b142cf7ca5ab21dc2c1a722dc028178dcece1a6dfe3d82b0056947610c6eee8cbba22146566838854b26425a9b97a4e68782072dde8c8508f0f7166b7575d664de26454490c25af8132fb52c55d869f0f32c3298a173c480b94583e4518388203273546a32ded9860452538b69d8d503fac2ba2d99b6e39466bf5cca3f7a75cd8092f0b6a295cd5ae40ead99c56aa6b4b2fac42f9e2818ab2d43291814bd77c84dd21516cf931832b4b2ce9a0448534443141041e84867368bbedbfb7286b7e5b8bb4287851310dca4a9490c01be26813781db0ed7e8cae9e2d90a6117b6f0025fac2c8071e364e9b40e450fa5191503fbaf6bb543ce488bd6b76c0f846ba2c47f527360980a9a6e8c5f2f36fad1d5d688a10cd1cfdc081da387a98f251c1358ef42f1dbba6f55b8c1acc88b4fc8388ecad561b38f981a4ad9fb8c0205cfbbf14d5ed6293fd5395a92448b605b2a6aeea63e6930b4c920df5eaa9727724e1d3b6b3b212c530e257b9bba83fc74f0cf78efa9b6fa025417e79a02585eb59ee7b9af13ab162e53c43d966900d80813607a326a2d2ac0429d44812330dc4c1a69f6a4d58d629153eb61edd05ba9ca2b5c10c118160e9b985843c594cb91d8a159ab77c36e471d68126abb19cc939e0c6a165e6fbc48ca3275892cabcd21d3237d67adeb983810af0ae06dcb21c02d6ca136ba44a31f41db7759f7e26c0d0827a9104bdbecc34ba6e20a0af075dfc59f9f6c07da9beefc695220dbe446cd060686dcadf6f2d3a8b6c68274c7ec6110afbaed0c48ea70dfd573044e8b72497b430c78fff50ac35fa75ae70ca8ad2a80606d53751e69644c09b537b6a9376ec53a7251a2130b5ccca9c6fa562edafa1026967968b44eca177bed5e93d4d0177dd5cb1d5e82b855c31a1684818263a2839fc989f74bde5b8e742b4fa2fd8cd5d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密文章 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器常用命令</title>
      <link href="/2025/03/04/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/03/04/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="一、程序测试的常用命令">1. 一、程序测试的常用命令</h1><p>其中<code>top</code>内存监控输出的文件里面，每行对应的数字分别与如下对应。</p><h1 id="二、运行的Shell脚本">2. 二、运行的Shell脚本</h1><ol><li><p>首先在Linux系统中新建一个文件。</p></li><li><p>之后在<code>mlcs.sh</code>文件中输入要运行的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kill -9 进程id  # 提前杀死进程，只限于咱们自己用户下的进程<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>&gt;</code> 将内容输出到文件里面，如果原文件存在，则直接覆盖。</p><p><code>&gt;&gt;</code> 将内容输出到文件里，如果原文件存在则直接追加到原文件中。</p></li></ol><h2 id="内存监控命令">2.1. 内存监控命令</h2>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">top -b -c -d 2 | grep &quot;你想监控程序的那个名字，能唯一识别就行&quot; &gt; &quot;输出到的文件名字&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   例如，我要监控名字里面包括<code>mlcs.exe</code>的这个进程，将信息输出到同级目录下的<code>memory.txt</code>这个文件里面：</p>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">top -b -c -d 2 | grep &quot;mlcs.exe&quot; &gt; &quot;memory.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   其中<code>-d</code>参数代表几秒监控一下内存，这里设置每2秒监控一次。</p><p>删除所有包名称包括mlsc.exe的进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkill -f me_test.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   断开终端也可运行某程序的命令：</p>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup 要执行的命令 &gt; output.log 2&gt;&amp;1 &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   比如我要执行程序的命令是<code>mlcs.exe</code>：</p>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup .&#x2F;mlcs.exe &gt; output.log 2&gt;&amp;1 &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   其中<code>output.log</code>就是日志输出，随便什么名字都行，默认存储到当前路径下。</p>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">touch mlcs.sh  # 其中mlcs是文件名，随便起<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   比如我要循环执行某一个程序：</p>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">for ((i &#x3D; 1; i &lt;&#x3D; 12; i++))do    for ((j &#x3D; 1; j &lt;&#x3D; 20; j++))    do        # 要循环执行的命令        # 其中可以通过$&#123;i&#125;或者$&#123;j&#125;获得i和j的变量值，进行命令拼接        # 比如其中$&#123;i&#125;就是获得变量，将最后运行的结果输出到result.txt中，        # 其中结果指的是在命令行输出的结果        .&#x2F;w_mlcs.exe $&#123;i&#125; &gt;&gt; result.txt    donedone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   一定要在Linux系统中手动输入，不要从在Windows系统下输入，然后将文件传到Linux中，他们两个系统的编码方式不同，否则会运行失败。</p>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 777 mlcs.sh.&#x2F;mlcs.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mit6.S191</title>
      <link href="/2025/03/02/python/deeplearn/mit6-S191/"/>
      <url>/2025/03/02/python/deeplearn/mit6-S191/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">1. 概述</h1><h2 id="感知器">1.1. 感知器</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302173357938.png" alt="image-20250302173357938"></p><h2 id="激活函数">1.2. 激活函数</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302173418796.png" alt="image-20250302173418796"></p><h2 id="损失函数">1.3. 损失函数</h2><h3 id="分类">1.3.1. 分类</h3><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302180326931.png" alt="image-20250302180326931"></p><h3 id="定量">1.3.2. 定量</h3><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302180340787.png" alt="image-20250302180340787"></p><h2 id="梯度下降">1.4. 梯度下降</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302181222102.png" alt="image-20250302181222102"></p><h2 id="反向传播">1.5. 反向传播</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302201710606.png" alt="image-20250302201710606"></p><ol><li><strong>反向传播（Backpropagation）</strong>：<ul><li>反向传播是通过计算损失函数关于每个权重的梯度，来更新网络的权重。</li><li>从输出层开始，逐步向后（即从神经网络的最后一层到第一层）计算每个神经元对总损失的贡献。这被称为“反向传播”，因为它是沿着网络反向传播误差信号。</li></ul></li></ol><h3 id="反向传播的步骤">1.5.1. 反向传播的步骤</h3><ol><li><strong>计算输出层的误差</strong>：<ul><li>比较预测值和真实值，计算输出层的误差。</li></ul></li><li><strong>计算梯度</strong>：<ul><li>使用链式法则（Chain Rule）计算每一层的梯度，这样就可以知道每个权重对于损失的影响。</li></ul></li><li><strong>更新权重</strong>：<ul><li>知道了梯度后，就可以使用一定的学习率（learning rate）来调整权重，使得损失下降。具体来说，如果权重导致了更高的损失，就往反方向调整它。</li></ul></li></ol><h2 id="学习率">1.6. 学习率</h2><p>学习率自动调整算法</p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302202502602.png" alt="image-20250302202502602"></p><h2 id="分批梯度下降">1.7. 分批梯度下降</h2><p>？</p><h2 id="正则化和早停机制">1.8. 正则化和早停机制</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302203604219.png" alt="image-20250302203604219"></p><p>随机丢失部分神经元</p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302203650285.png" alt="image-20250302203650285"></p><h1 id="RNN">2. RNN</h1><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302210306088.png" alt="image-20250302210306088"></p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302210728169.png" alt="image-20250302210728169"></p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302210739335.png" alt="image-20250302210739335"></p><h2 id="顺序建模的设计标准">2.1. 顺序建模的设计标准</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250302211357941.png" alt="image-20250302211357941"></p><p>Word prediction example <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=1910s">31:50</a>  - Backpropagation through time <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=2020s">33:40</a> - Gradient issues <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=2235s">37:15</a> - Long short term memory (LSTM) <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=2400s">40:00</a> - RNN applications <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=2640s">44:00</a>- Attention fundamentals  <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=2806s">46:46</a> - Intuition of attention <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=2953s">49:13</a> - Attention and search relationship <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=3082s">51:22</a> - Learning attention with neural networks <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=3465s">57:45</a> - Scaling attention and applications <a href="https://www.youtube.com/watch?v=dqoEU9Ac3ek&amp;t=3608s">1:00:08</a> - Summary</p><h2 id="随着时间反向传播-梯度消失，学习能力下降">2.2. 随着时间反向传播-梯度消失，学习能力下降</h2><h2 id="lstm">2.3. lstm</h2><p>通过忘记一部分</p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250303154530054.png" alt="image-20250303154530054"></p><h1 id="卷积神经网络">3. 卷积神经网络</h1><p>获取不同框中的物体，两个神经网络共同使用。 </p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250304202546754.png" alt="image-20250304202546754"></p><h1 id="强化学习">4. 强化学习</h1><h2 id="自动编码器">4.1. 自动编码器</h2><p>将数据编码，降维</p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250304220654243.png" alt="image-20250304220654243"></p><p>解码器</p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250304220912390.png" alt="image-20250304220912390"></p><p>增加概率扭曲</p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250304222137386.png" alt="image-20250304222137386"></p><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250304224849011.png" alt="image-20250304224849011"></p><h2 id="生成式对抗网络">4.2. 生成式对抗网络</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250304225133095.png" alt="image-20250304225133095"></p><h2 id="强化学习-1">4.3. 强化学习</h2><p><img src="/2025/03/02/python/deeplearn/mit6-S191/image-20250322173651016.png" alt="强化学习与无监督学习的区别"></p><h1 id="致谢">5. 致谢</h1><ol><li><a href="https://introtodeeplearning.com/2021/index.html">MIT Deep Learning 6.S191</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cate深度学习 </tag>
            
            <tag> 麻省理工网课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy_pandas</title>
      <link href="/2025/02/23/python/deeplearn/numpy-pandas/"/>
      <url>/2025/02/23/python/deeplearn/numpy-pandas/</url>
      
        <content type="html"><![CDATA[<h1 id="NumPy-与-Pandas-用法总结">1. NumPy 与 Pandas 用法总结</h1><h2 id="NumPy-用法">1.1. NumPy 用法</h2><h3 id="安装-NumPy">1.1.1. 安装 NumPy</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install numpy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导入-NumPy">1.1.2. 导入 NumPy</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as np<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建数组">1.1.3. 创建数组</h3><ul><li>从列表或元组创建数组<pre class="line-numbers language-python" data-language="python"><code class="language-python">arr &#x3D; np.array([1, 2, 3])matrix &#x3D; np.array([[1, 2], [3, 4]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用内置函数创建数组<pre class="line-numbers language-python" data-language="python"><code class="language-python">zeros &#x3D; np.zeros((2, 3))       # 全零数组ones &#x3D; np.ones((3, 4))         # 全一数组arange &#x3D; np.arange(0, 10, 2)   # 创建一个范围数组linspace &#x3D; np.linspace(0, 1, 5)  # 等间距数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="数组属性">1.1.4. 数组属性</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">shape &#x3D; arr.shape               # 数组形状dtype &#x3D; arr.dtype               # 数据类型size &#x3D; arr.size                 # 数组元素总数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="数组切片与索引">1.1.5. 数组切片与索引</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">slice_arr &#x3D; arr[1:3]                  # 切片element &#x3D; arr[1]                       # 单个元素row_slice &#x3D; matrix[0, :]               # 第一行col_slice &#x3D; matrix[:, 1]               # 第二列sub_matrix &#x3D; matrix[0:2, 0:2]          # 子矩阵<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组操作">1.1.6. 数组操作</h3><ul><li>统计操作<pre class="line-numbers language-python" data-language="python"><code class="language-python">sum_arr &#x3D; np.sum(arr)                  # 求和mean_arr &#x3D; np.mean(arr)                # 均值max_arr &#x3D; np.max(arr)                  # 最大值min_arr &#x3D; np.min(arr)                  # 最小值std_arr &#x3D; np.std(arr)                  # 标准差<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>数学操作<pre class="line-numbers language-python" data-language="python"><code class="language-python">add_arr &#x3D; arr + 10                     # 加法mul_arr &#x3D; arr * 2                      # 乘法exp_arr &#x3D; np.exp(arr)                  # 指数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>矩阵运算<pre class="line-numbers language-python" data-language="python"><code class="language-python">dot_product &#x3D; np.dot(matrix, matrix)   # 矩阵乘法transpose &#x3D; matrix.T                    # 转置inverse &#x3D; np.linalg.inv(matrix)         # 矩阵求逆（需方阵）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="广播">1.1.7. 广播</h3><p>NumPy 支持广播，使得不同形状的数组可以进行运算。<br><pre class="line-numbers language-python" data-language="python"><code class="language-python">result &#x3D; arr + np.array([1, 2, 3])     # 广播机制<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="Pandas-用法">1.2. Pandas 用法</h2><h3 id="安装-Pandas">1.2.1. 安装 Pandas</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install pandas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="导入-Pandas">1.2.2. 导入 Pandas</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pandas as pd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建-DataFrame-和-Series">1.2.3. 创建 DataFrame 和 Series</h3><ul><li>从字典创建 DataFrame<pre class="line-numbers language-python" data-language="python"><code class="language-python">data &#x3D; &#123;&#39;A&#39;: [1, 2], &#39;B&#39;: [3, 4]&#125;df &#x3D; pd.DataFrame(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>从列表创建 Series<pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; pd.Series([1, 2, 3, 4])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="常用属性">1.2.4. 常用属性</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">columns &#x3D; df.columns              # 列名index &#x3D; df.index                  # 索引shape &#x3D; df.shape                  # 形状dtypes &#x3D; df.dtypes                # 数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="访问数据">1.2.5. 访问数据</h3><ul><li>行选择<pre class="line-numbers language-python" data-language="python"><code class="language-python">row &#x3D; df.iloc[0]                 # 按位置选择第一行row_label &#x3D; df.loc[0]            # 按标签选择第一行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>列选择<pre class="line-numbers language-python" data-language="python"><code class="language-python">column_A &#x3D; df[&#39;A&#39;]                # 选择列 Acolumn_B &#x3D; df[[&#39;B&#39;]]              # 选择列 B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>切片选择<pre class="line-numbers language-python" data-language="python"><code class="language-python">subset &#x3D; df.iloc[0:2, 0:2]       # 选择子集<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="数据操作">1.2.6. 数据操作</h3><ul><li>增加/删除列<pre class="line-numbers language-python" data-language="python"><code class="language-python">df[&#39;C&#39;] &#x3D; [5, 6]                   # 添加新列 Cdf.drop(&#39;C&#39;, axis&#x3D;1, inplace&#x3D;True) # 删除列 C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>数据过滤<pre class="line-numbers language-python" data-language="python"><code class="language-python">filtered_df &#x3D; df[df[&#39;A&#39;] &gt; 1]      # 过滤条件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="统计分析">1.2.7. 统计分析</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">mean_A &#x3D; df[&#39;A&#39;].mean()             # 计算均值sum_A &#x3D; df[&#39;A&#39;].sum()               # 计算求和describe &#x3D; df.describe()             # 描述性统计<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="数据处理">1.2.8. 数据处理</h3><ul><li>排序<pre class="line-numbers language-python" data-language="python"><code class="language-python">sorted_df &#x3D; df.sort_values(by&#x3D;&#39;A&#39;)  # 根据列 A 排序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>缺失值处理<pre class="line-numbers language-python" data-language="python"><code class="language-python">df.fillna(0, inplace&#x3D;True)          # 填充缺失值df.dropna(inplace&#x3D;True)             # 删除包含缺失值的行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="数据导入与导出">1.2.9. 数据导入与导出</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">df.to_csv(&#39;file.csv&#39;, index&#x3D;False)  # 导出为 CSV 文件df &#x3D; pd.read_csv(&#39;file.csv&#39;)         # 从 CSV 文件导入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="读热码转换">1.2.10. 读热码转换</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">pd.get_dummies(data, columns&#x3D;None, drop_first&#x3D;False, dummy_na&#x3D;False, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>主要参数：</p><ul><li>data: 要编码的数据，可以是 DataFrame 或 Series。</li><li>columns: 指定要进行编码的列名。如果不提供，所有类型的对象列都会被处理。</li><li>drop_first: 布尔值，默认为 False。如果为 True，则删除第一个类别的列，以避免虚拟变量陷阱（dummy variable trap），即多重共线性问题。</li><li>dummy_na: 布尔值，默认为 False。如果为 True，那么将生成一个额外的列，用于指示缺失值（NaN）的存在。这一列会在原始数据中出现 NaN（缺失值）的地方标记为 1，其余为 0。</li></ul><h2 id="使用-NumPy-数组作为-DataFrame-的数据">1.3. 使用 NumPy 数组作为 DataFrame 的数据</h2><p>您还可以使用 NumPy 数组作为 DataFrame 的数据并指定索引和列名：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python复制代码# 创建 NumPy 数组data &#x3D; np.array([[1, 2], [3, 4]])# 将 NumPy 数组转换为 DataFrame，并指定索引和列名df &#x3D; pd.DataFrame(data, index&#x3D;[&#39;row1&#39;, &#39;row2&#39;], columns&#x3D;[&#39;A&#39;, &#39;B&#39;])print(df)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="tensorflow">1.4. tensorflow</h2><ol><li>转换为tensors，不能改变</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">tf.constant([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>转换为variable</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown_基础语法</title>
      <link href="/2025/02/19/%E6%9D%82%E9%A1%B9/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/02/19/%E6%9D%82%E9%A1%B9/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown语法">1. markdown语法</h1><h2 id="插入引用">1.1. 插入引用</h2><h3 id="单行注释">1.1.1. 单行注释</h3><ul><li><p>示例</p><p><img src="/2025/02/19/%E6%9D%82%E9%A1%B9/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/image-20250219113809368.png" alt="image-20250219113809368"></p></li></ul><blockquote><p>单行引用</p></blockquote><h3 id="多行引用">1.1.2. 多行引用</h3><blockquote><p>多行引用<br>引用文字</p></blockquote><h3 id="引用省略">1.1.3. 引用省略</h3><blockquote><p>引用<br>引用</p></blockquote><h3 id="引用中使用其他语法">1.1.4. 引用中使用其他语法</h3><blockquote><ol><li>表项</li><li>第二列表</li></ol></blockquote><h2 id="代码引用">1.2. 代码引用</h2><h3 id="段间代码">1.2.1. 段间代码</h3><p>这是一段段内代码</p><h3 id="段中代码">1.2.2. 段中代码</h3><p>这是段中<code>return 0</code>代码</p><h2 id="插入链接">1.3. 插入链接</h2><p>Markdown 支持两种形式的链接语法： 内联式和引用式两种形式。</p><h3 id="内联式">1.3.1. 内联式</h3><p>中括号内为显示文本，后面紧接一对圆括号. 圆括号里面放所需的 URL 链接,</p><ul><li><strong>示例：</strong></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">[01.Markdown语法说明](https:&#x2F;&#x2F;github.com&#x2F;appinncom&#x2F;Markdown-Syntax-CN&#x2F;blob&#x2F;master&#x2F;syntax.md)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>显示效果</strong></li></ul><p><a href="https://github.com/appinncom/Markdown-Syntax-CN/blob/master/syntax.md">markdown语法说明</a></p><h3 id="引用式">1.3.2. 引用式</h3><ul><li><p>第一行：<br>引用式链接使用连续两个中括号，第一个中括号放显示文本，第二个中括号里面要填入用以辨识链接的标记。<br>标记可以有字母、数字、空白和标点符号</p></li><li><p>第二行：定义链接</p><ul><li>需要单独占一行。格式是：<br>（1）中括号中包含标记文本 可以用三个以上的空白符来添加缩进可以用三个以上的空白符来添加缩进;<br>（2）接着是冒号;<br>（3）接着是链接的 URL;<br>（4）接着是可选的标题, 可以用单引号, 双引号, 或者圆括号包围。</li></ul></li><li><p>链接的定义可以放在文件中的任何一个地方，比较常见的做法就是直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样</p></li><li><p><strong>示例</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">我们可以在 [02.Markdown中文文档][link1]这个网站查看MD语法样式。[link1]:https:&#x2F;&#x2F;markdown-zh.readthedocs.io&#x2F;en&#x2F;latest&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>展示效果</strong></p><p>  我们可以再[02.markdown中文文档][link1]这个网站查看MD语法样式</p></li></ul><pre><code>[link1]: https://markdown-zh.readthedocs.io/en/latest/</code></pre><h2 id="致谢">1.4. 致谢</h2><p><a href="https://pamarus.github.io/2020/05/03/markdown-1-ji-chu-yu-fa-xue-xi-ji-kuai-su-ru-men/">Markdown（1）：基础语法学习及快速入门 | Pamarus</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vmware+mobax</title>
      <link href="/2024/11/29/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/vmware-mobax/"/>
      <url>/2024/11/29/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/vmware-mobax/</url>
      
        <content type="html"><![CDATA[<h1 id="VMware-网络连接失败">1. VMware 网络连接失败</h1><p>转自</p><p><a href="https://blog.csdn.net/m0_37259197/article/details/78221016">VMware 虚拟机无法连接网络解决办法_vmware 没网络-CSDN博客</a></p><h1 id="Mobaxterm-重新连接">2. Mobaxterm 重新连接</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组-链表</title>
      <link href="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>感谢<a href="https://programmercarl.com/">代码随想录</a></strong></p><h1 id="数组">1. 数组</h1><h2 id="滑动窗口">1.1. 滑动窗口</h2><p>不断调整起始位置和终止位置，处理一块区间内的数据。</p><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li><strong>窗口内是什么？</strong></li><li><strong>如何移动窗口的起始位置？</strong></li><li><strong>如何移动窗口的结束位置？</strong></li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：<strong>如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。</strong>确定好移动的情况，并处理需要优先移动窗口还是先处理窗口中的数据。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210312160441942.png" alt="滑动窗口" style="zoom:67%;"></p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><h2 id="螺旋数组">1.2. 螺旋数组</h2><p><strong>确定边界处理的不变量，确保每个子问题的结构都是相同的</strong></p><p>然后按照不变量写出每次循环的次数</p><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/20220922102236.png" alt="循环数组" style="zoom:50%;"></p><ol><li>尽可能保证每次循环中的 量 是不变的</li><li>进入下一次循环时， 控制这个量发生改变</li><li>尽可能减少控制</li></ol><h1 id="链表">2. 链表</h1><h2 id="删除链表">2.1. 删除链表</h2><p><a href="https://programmercarl.com/0019.删除链表的倒数第N个节点.html#算法公开课">删除倒数第n值</a></p><p>删除列表时，最好增加dummy_head节点，删掉头节点更方便</p><blockquote><ol><li>fast 先移动 n+1 个</li><li>然后slow, fast 同时移动，fast始终比slow 快N + 1</li><li>当fast 到达末尾时，slow 与末尾的距离是N</li></ol></blockquote><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt="增加dummy-head"></p><h2 id="链表相交">2.2. 链表相交</h2><p><a href="https://programmercarl.com/面试题02.07.链表相交.html#思路">返回相交链表节点</a></p><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/20211219221723.png" alt="img"></p><ol><li><p>求A，B的长度$l_A,l_B$</p></li><li><p>为方便起见，将A始终未较长链表，否则将A，B交换 </p></li><li><p>根据$l_A,l_B$ 的差值，将长端链表对齐</p><blockquote><p>使用方法为： 长端先走一些位置</p></blockquote></li><li><p>依次比较</p></li></ol><h2 id="环形链表">2.3. 环形链表</h2><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/20220925103433.png" alt="20220925103433"></p><script type="math/tex; mode=display">slow = x+y \\fast = x+y+n(y+z) \\fast = 2*slow</script><p> 计算得到</p><script type="math/tex; mode=display">x = (n-1)(y+z)+z</script><p>代表，<strong>从头节点走向环形入口  = 从相遇点出发走n个节点</strong></p><blockquote><p>意味着： 从相遇点触发  一定会遇到从头节点触发的节点</p><p>相遇节点 为 环进入节点</p></blockquote><h2 id="交换链表">2.4. 交换链表</h2><h3 id="交换相邻连个元素链表">2.4.1. 交换相邻连个元素链表</h3><p><a href="https://programmercarl.com/0024.两两交换链表中的节点.html#思路">交换两个元素</a></p><blockquote><p>链表中，没有头指针，增加一个虚拟头指针dummyhead</p></blockquote><ol><li>获得cur-&gt;next, 因断链，保存cur-&gt;next</li><li>获得cur-&gt;next-&gt;next,  因断链，保存cur-&gt;next-&gt;next-&gt;next</li><li>获得cur-&gt;next-&gt;next-&gt;next</li></ol><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917200804409.png" alt="image-20250917200804409" style="zoom:80%;"></p><h3 id="反转链表">2.4.2. 反转链表</h3><p><a href="https://programmercarl.com/0234.回文链表.html#思路">回文链表</a></p><ol><li><p>使用快慢指针，找到链表中间节点</p><blockquote><p>slow 与 fast 同时指向 head 节点开始</p><ol><li>偶数链表， slow节点在中间靠后节点</li></ol><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917212330639.png" alt="image-20250917212330639" style="zoom:80%;"></p><ol><li><p>奇数链表，slow节点在中间节点</p><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917212525497.png" alt="image-20250917212525497" style="zoom:80%;"></p></li></ol></blockquote></li><li><p>后半段链表翻转</p><blockquote><ol><li>需使用pre节点存放前一节点</li><li>断开链表后，需要存放后一节点</li></ol><p><img src="/2024/09/24/c/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8/image-20250917213101697.png" alt="image-20250917213101697" style="zoom:80%;"></p></blockquote></li><li><p>前后两端比较，不同则返回错误</p></li></ol><h2 id="前缀和">2.5. 前缀和</h2><p>将之间计算的结果累加保存在数据中，之后使用时使用结算完成的数组</p><p><strong>需要更具题目要求，选择计算什么样的前缀数组</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while (~scanf(&quot;%d%d&quot;, &amp;a, &amp;b))&#x2F;&#x2F;按位取反，如果结果是eof&#x3D;-1,取反之后结果为0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="双指针">3. 双指针</h1><h2 id="双指针指向头尾">3.1. 双指针指向头尾</h2><p><a href="https://programmercarl.com/1207.独一无二的出现次数.html#思路">有效的山脉数量</a></p><ol><li><code>left</code> 与 <code>right</code>分别从前后遍历</li><li>如果二者相遇，则是有效的山脉</li></ol><h2 id="移出元素">3.2. 移出元素</h2><p><a href="https://programmercarl.com/0283.移动零.html#思路">移出0</a></p><ol><li>slow 指向新的指针</li><li>fast 指向旧的指针</li><li>将旧指针的元素放在新指针的位置</li></ol><h2 id="右移元素">3.3. 右移元素</h2><p><a href="https://programmercarl.com/0189.旋转数组.html#思路">右移数组元素</a></p><p>依旧可以使用<a href="#移出元素">移动元素</a> 的思想</p><ol><li>slow 指向 新的指针</li><li>fast 指向旧的指针</li></ol><blockquote><p>需要注意：</p><ol><li>移动数据，会对数据进行覆盖，应复制一个元素</li><li>fast指针不能越界，需进行 <code>fast = (fast+1) % nums.size()</code></li></ol></blockquote><h2 id="左右元素相同">3.4. 左右元素相同</h2><ol><li>left, right 分别代替<code>i</code>左右元素之和</li><li><code>right = sum - left - num[i]</code></li></ol><h2 id="排除重复元素">3.5. 排除重复元素</h2><p><a href="https://programmercarl.com/0925.长按键入.html#思路">长键盘按入</a></p><blockquote><p>情况较多，需列出可能的情况</p></blockquote><p>比较name[i] 与 <code>type[j]</code> 由两种情况</p><ol><li><p>相同，则<code>i, j</code> 同时向后移动</p></li><li><p>不相同， <code>j</code>与 <code>i-1</code>比较，相同，则<code>j</code>向后移动</p><blockquote><p>因为 i = 0 时，不能向前比较，如果结果不同，直接返回错误</p></blockquote></li></ol><p>比较完成后，<code>name</code>与 <code>typed</code>有可能有剩余</p><ol><li>name有剩余 《=》 <code>i&lt; name.size()</code></li><li>typed有剩余， typed需要与<code>name[end]</code> 作比较</li></ol><h1 id="感谢">4. 感谢</h1><p><a href="https://programmercarl.com/">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 代码随想录 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++进程管理（-）-thread</title>
      <link href="/2024/09/21/c/c-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2024/09/21/c/c-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="通行证看着不太对，再试试噢🤔" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="cb7f208f3434da8475a544cfd718ddf09dd062cc47c28741f3e9780822c9cdde">4fbb2435fd3b6574fd4f7bd145822884c8d9e8eaef92d87a149e20adcdb20de268b8e83e618e97ceca7990a19dadfb992e460fe0a6770b9a324e533c6cb4b4980173020950fddb42c6ac450637ad56d697225a2d92c5b03a365d1cd79f8040a6c4ff36021a63c1a9e4a7804e35ba83c7fb2239b3d34be8fd45a26dc682699c30bb1a574f7d1b12dafc8b6d5e3395cf09ebe039e4a03ccddcab8641ab1e6db7b94fd38933f816a10cae5b8258e76dd77769d4f0b1ffee4632b0ded6cedc2842a479de4fe9771164240549336fd15156402919039290ade9cc9f2f55b994780d13ed4a2a9a1af304209086346990a28c367058701fd79e97b773cc24e33e687c7ba2552e94731b9fb56b94e62bc08dfccbe23768a192d379bb4c5b28bb31996ddb603269300cf70d60f23b4157eee8dbe606de533d76c20f6631ae6f5d8a22536ebce211594f33b54610f283187c553485b0624302132dc1ebaea9566904724ba1816c5c6a6b4cc33e508d0118a7930375d47483aa05a42713ffc6eb6d620fa0a25ed66e4ef863c70c66e56c4181bdb237fd7575cbb7385226b138ff221666eb4a2ba8f7d93799f4cb1cd041b225b8eb49aa49fbb1ca6136c3fc9066de5fa89c77fb9daacbad03ef60cffdc9a8f441bbe71cfd6cb961e80caf0de1ca6069d12198bd2f83dfff5dc2bf25f824a0e998eb86966d1c92cfbcd852bd640582f53c9c5a449288234979a066b2a86e68043db40b60dc4d16e86d1f3537e955e2564ffac2f61fae818b969ccc4058e07e835dcc5ebcec68c041bef6c761b96fc76026a676b849efc9531298c77f56760a275d20ddd453e9746bd183256943e856e490b7a5ff241df8a49e4e3371e0fb040534cd0af79eeeb1316b195852ea7f809d102029ecb878ff12f8b0765ba4615029b082ba7e7ef8bbbbf7f45ba735b6baeeb78074ff29239b49db665b7a1ededfc3f3187ee04f3adff60cd984e457cf1919d6fb7cd9993c59eba30feffc420a198ab997545799de5b6370ec6ddaef7d3bcf0e726443eeced34001c0d6ac062a1a498ea891881a3042763f7e8c8b19f64f1e30ed7914440ebb7a7749be42792a7c35a4ac3b86c49d2ac4ac83b3632c81bfa0d6632064157bc2ff6b59e1814e8e1878462c4c3917c3774aef6577d61ff9c93ffa88923aad9f78d0773280d3e58d22bab900c86e7da28dc87a11979c3201e8e83f0825ef83428d2ef04cc3034365d9c3bfdc445353d7b6523a83815b5f12eb5c6af28b17be64a3ec6c7b466379bc95c38561e7bad9b0c2d032ed10dc2b63cb732fd10372f9ca9dc4555d0eadd3f6502f58967d11a0c38c8d952b9589016352bd45f7c2db74712094df508f92176b375325d8159db5f134e011dca01b63473d4489e2439841440fb14f8ded1ccd386df731f87b3c5f4ad7fc3e48c4e953a2b252299f88a3b982c23b9956f80f5cba3b14868c81fb92b8c874eb4b98ce38d5ee7d2623930803a8526498e0e62da16c8a1578abc7a45cc479ccfb8bdc6857bf44ca8f5413306e8abc3c633d1c224207312166af874679b07b5a52a2640b55c81d4cc252eb351d7b74da72c12b926bc7272bce66fd7d5af91e8273786cc8951051866d98bb137bc9328143e6255ac1cc0581476808ef23cdee0f684654a806d6b47aee5e21ee34fbb8eb404ad85e229df736b0bb3b1923aa354dda9d573c3e22384c057f3a989c38ba3312d473852436a08d725c98796c3042a1a02a58a074f2500671d968f79a54ff1891a1806f2d997a0e38560b7e98f5a91d5a4cbb2eff60dc28a59be8e76847e97558049bb808644448823d6e56a2976beca4fbd6b1bd34e05cb53aa995460860d1f96e1b5b46492ff45f2092258feb141bea66291c17a0490489f4e856f02e20291d20771f223519e9f2b9c361e5c13cea7c66eac677e2f1591c0646dbdb813d5ebfd26d891cbeaa744746563e6e2996e1bd4a89b5d0f61ece8f9b2cfb4e05210822eebf953e375a57f26e022afda025e1a0015374041e335a0d9392099d1073e6924d30e2015587bd48f1db68adcc0452fbf9823cdaefab39c5e9a784df01724a2c96e58410b10b0562a2c5f21cd8622aa2b00a5095344aa9f3592c16c9cc65bd09f6b34ba7368e1ec49ce29a45a854a37a8ac54c2834773c1686fddc9c9b0d1178a679032e1beab0b214a4688305b531f8f0fc26e740085db530c4c4ccc24e6a719c23c37cb6de379fa1b9a422f52c2421b5c9f8759850b21717fccd6e469b9281e9e8b576e30d28bbff73bf3f94afe092a4b1e8426b25367451a3e5852e9353df04b19af6cbe3a212bef8f6fd51adf40f89182320ec4e029b7fca769233a7d56f8c43a75cfeda3afb77df7ea67dc1a3701e0abf8553ed38c649a3468d99816502526ee374a6f2fe442f0c477b3acd5b04374b5df86b827213541cff04d6193ee425ae005bf97f2913018df748732eb7b1ff44f4f43cedb4d43ecefbd26ca5998ccc546739268f9e3e9aadfc12cf1ccd3eacf0b494c5a23f4b9e81a6deb2f4e7e912fb995966ad133fbf889404614620f64720ad4217b30e9312f68d2e8c92b47ebc19b5e9bf6e0794d5922479b1d001cebba73108ae5c3797e0658916b65ee1d12806ad82ed40f85dafdac73c67b96863b47da8d24473f074bf052bc44147bf404c16e4594d641ccd388975928b4cdb1336318b3089f8890acb74680d7cc1e473025cf252e9a02b3ebc629779ab87ae7f87193c5525452ddd47dc229c77e513abec5f681ba9a3bdb26aea64181c19f865619b54183383074844289e346aba62a7ef06c6579a99687aad351d8724317105913a1b435e1117eb9eb73a20fcaa67af80b5b8c3453d7a87ff308b0d3429847262b05daaae81a869fe7aba3277aa897d6bc1b20b410933d3f7bda7a0cfdd5fd41d77cabe86246f53a272c193569d8e7b09c7f42d14637b7fabeb5609606194cb36b622fdcae1d97be1ed91c9d8adbedec25fe9083fe697f2ea43bfb8a75b5107657e783906186f4b8d8020bf5f6189f08f4e4a6a0563165c681f3cce13c6762baf0bda23db42afe77a332c9cb2f1726063ae2894d46fbaba4b704f0c25bf2521204434aa21fd6a3e65db474d36cc7500b80ffe9476c95f2d431fbea25ee84f156a2753352868025f5994d0f11fd20b69c1b252b3cb9575b17fcb9e3da68f0a4ea2d4f99dbb7c0dfa756596b6ecdc3d95888699696eba3c31c12874176bcb6a733b6b049fa153a205c51bed27fa47c89187b0d0ea6782bdb65247f41618609abffa65e8bfc7c7a49046a1bd477ebb92144c4688d5d5250196e482d285b906e8f81485699549976705982464d3bf9b2476e540bfeb27e269b688c0216b204288f795f355db9ec5a28621111492a3583b7b5d82484bbe6e46cc8b88a4365d4894757d67a3f6821a4ada3a8ef380352482f8edc88451e2b269da8c75b0ce928e0da19cb48a19026f5b311efcca402d9163759c4d3164d110e43e0eb20f04e5a830cdd9da2dc30062521e987c225cc27d3018c5338a9658f7933288b89ec57453c406bba87f5804b18a7fe71bf3ca51b49154fed0d7e357b66ff0f4266c8064f6ca5dd7c7f2dee170a4c9d69bc5167fb24c06c90b50fb6106b36e91cbf099f3482ea24d516086f46bf22cd555224019280d849cd3d60a7b884853626e701c81d3144cfcd1201953ea50fcfdbe6161485df24435b66b018316a861caca81387fdb8f449708ba58b47dc641c653cbeb435bf80ab6481cdf6c56868e241983fb0a4c5101c3e9090c949d9510559b59d33383910fac3aa08f466f78796cde40d48a230fafa157076693f166a4254ebc9780a177246fb67bbe075b2453f650a4efe608656a4238cc4115a38e1a54d8c605e90d53ab26065f1faf0a58ccf51d5df8b5d9d92062124938201ee5ac048dfd0defd853fc0ccbc4ab3144843e711aa7cbe89edc231e06b248de4eb7c5b41ac92acc1fef3b910bbdfba83a97a18a014e78b2938d2176ab0fcde94e65bacdc6aa159aafa00083382ddf0cc042b223eaaf4e56015682209698d955c2b6f30dfb65818fce29b3f23e76c0936f6debdc0e96fe0590319f081de666a0b4dd20fa43be91cbad5532aefd1d49fd7ca7c9c1261b7e4ff354dcad6856350681f55f64f45e6ef42b858cc4907dff73c539a860b1d90be4db2b0d1f2d01249c326da462d718ee54539f5f3c7cacf0c6f97efab48f010a6677b58ba3f85a44edcd7ca7a2a4a02c1e9c1341b5daf200e93f61a8a6061d1d5546cc30b27515f13f9ee76ecbb07a4ef703f0c0daa207e1562f46a810cc7ece8655eff1cb32e0dd0ae48878cc45763185c58e06a198eeb18ddc79ef149f5f90b01242fa7fc1e1b0b6716638dc83f87ce0042d4cf31c72cb476c98b1b702386169d5804942b9a1ddb8b226d77ebbc9ae7cbff34030ba52d3fa1e380f79cd02f256079146ae4d7232c3c85fcd14980ba423e65f327bfb61877f1849507477ea4420da7bdc837f01bc8dacb50164682d7e1f5b931f4143d9c09a7cccd10fcae500b78b2c5c9de2a690f6951d1276c1d058ce9457f5a655ca5704a51bad25e863704a50e8c4af23cbd3b181a9b4f60cc5d3814768c7d9a47c7ff8e528d19759f7f27e3e7ac7411abf2ad499b441dd282da1a22df58e187dd552a53d2e4d27adf3bbdabe8e04cffecfbd33fd83e68586cb3f8b68d7e520f9a810f7c9cbde20e54184426e4d997e98765c116619a7d817496f6b778ee7b66128f58fa3e9ff22740d7f2a6f720b34626ccca298ce165363fe06464971d8ceaee48e067803b2ba0f1c4d7e50c2544795d7fb5bae0c3215a9ec72e4370282b62446cfb300a7745e6dc3042e6bfd1a04ecf0e99cdbc137e4a4d1d69fd8b494975d8007c1c8c8ca686d03421e28cfa1cac650600d7aa97bbc18656734dbf98234b839fd04df2d453a87d9e61e5a986780a842b3f75173aebbfcdcdd03f5908ebf220f5dbf72604ef863c2204f2504c1a78b577bc9b0376ffe585e62584b99a901e9da3fd1c959dde294dac3e5eb78527f604543243b052d234ba4347b01d44cea927737aed2b15580f18ab2a21defb1180a0caf183a492c599e6077529180c83ff2a6256b3c6d92eab03c11af7d2ce4854b4c4dce7358175910257214a512bc2448e354fae5b7705caabb04cc520b3af9031b212b5deefe9312bb3b18e04bc6a7b6b02b0ad22898d212a722b4dbe150ab74517db06e0cbcc588c7bd1a98bc1fa2a415b587ad8b4fe74335120caeb4cf8c200f9d47918c1d76fc1aeebca53afe28706f44a10ef7d0b42657101dbdd99ebacfe266b4e506f4c3a431b31864ede2717edcf1d57fef90e71923421d65c0d05b7e99208934fa18bbe7cb9010768c62a9250220b9589f874021373e666bee6a2d763c518b3ad2679b0de66c53a4983092e9078fe325526dd83e28d72d44ac0b739d878d7ac4b0366310e45634ec052ae9277d3b6779483c8690dc9e38d4719cf3db1c5bfeccacfa1f456acc5027020d5a39d5eb95c75d013df788f9592f3beab6692168605492a59cc968f20f0f3753b1782f89a3d8c9273dcd8433cfdf7aacebd79fc795c5c0e5e36eb4a487df038678d030144d6ccdcf9281bc002f95baa8848c1e017f8acb2b7f0441f1e0cc896d32b7c4e5114d567011e13913ae75896a010e2ac17eb9e7947f42756a1d7910576bcaa541d8d044c6a81d06caa871f0eb0272364023568b2a29fa79f30194dbc665a8772cae5b3027bee7c068dc50ee485d234f4e41566722b66a278ffcb34b2552b88c5fbc3a1aecd708621e5cb7bf31f1ce9b3830d0a56db92a8f3628a190193d49b760b583857440a9f1e77dfa7d8e06e42155a7043cf5137861cd7b05f7ef1e86664af64ea8fffc9a3366d23e9f1ea53a4a6699cf1935f59e98c7cddea464f956428916d8746281a1ed78939b67b3bf0b1ad4a1cfdae20a7335c93d113bf8ffc3e19ee74d099a19559ff5f620e0b690c0b3469d84f7060f106f918eb37c37ce80e78718ee2a215b47b218764735c4c88071a2edb428007c16d5eea345caa9bf61bcae4330ffc46054bbec33403bf861d9aa85ffd2c96fc0bb36735df1b56362f66a5f9ecb7194b269b8a2f576b652cf704fea4f858034a7cadde8030b61995e41d9d144a887dd14355192f3afa708381d203e594d747a8698d50c32dcd59fe298f5a1eaf26c22cdb2db7373fcad2868f0d79ec57a4819951f999c27392842fff30e75d28be9f9939ce3af43736d4151c47eb724d454aa1309cb5a36471c31c23fe4f8ffa7f7208b8850bd80ec022a18a8125e5ce9de3e2086cc6886f0d7c904f857cc4ab98f9eb6a289a2f407ef222f918bbc335fbbfc6a74190a2c8613f0b44c86e4ab0116482567dafbe3d34b13cf1d1fee9f51663527ea6daef605a73ed5d0bf9ce4b13e7598cd9ca453aee3c0501e6336d379df7eb7dc1e46f4051720464807e6fe802ef3f02fcd19fe6a81817c87b29b2b158bc8951772634e01768bb826ba728aee9e76946a893cd88fc338bf195120a731525100cfadfb5ccb087b79a286d9cea002cf9874eab592c34afc712ad781673b2f634a55f958795e5d197d314b2d22cde116b836cf613094909eac0811765c1662a17ef614406ed2fc7b2aa963bce9557e6a33cf0ca11101800714fa009066d135768f2ef290875e1d4f9745efcb80c5a32922faa0d89dc3d256b64d2c9932013f909295d6562efbb8597a72c8b36d4f9a86fbf1ba3e0f6541948e27e3de0f19cb34d5d0954f7133f761ebd3777074fcbc919d3c920f4da2a45e2a9023b3fe8e1b0dd9a9bd554f9186969a1f69ee6780d2ed9c9f5f5d7290dea83e6a8705753a8c8a8c42fcafa74312807fe4b24fb53e66ee9cc7a3edc245eb833f665a34f8aae6e9a27f3d13f249c859be58b0d1d75d3a1e85c772bd5366845faaa58969ac39c8815a628ab9e7977107915408fe140fe3745a966884d359e79b0473efb34ca5e4f6fbb4296f4b7b4eab798e0538d9428d9737612563f8d0f9fe5355062a5a27ef8796b1f5ea68b7ece9ff7608c6de852c6dc719293ff8ccbaa0e4a490a291c3fa4ffc49284fc4038c54ef0c112eebf3cfce7e692baeb0c925e3a8e2a3152fe4e07187d2029344f5879cef93bece6f3b2165329c51ffb2a061ff93c1bb65531864539b78ff5ece86861b2a5dc69c424027a64452e4b200d3b052949be092f04a3aa8bad61d41a4f89a974850e277716a82189a019f057b543cc9119491d9935c66c16282c0b3d8801b7946e73441a177ae43d43aa25aa5d168c2d93af80a235c491dbc0fac2d99e5d81c45b64e22a4e241804695eec7282235551a2f9353161b3f951332c41f031b176b272e4fcde62b95749c94c4bb42139b4b67d71eef3ab5ecdf118f1a14eb59a920ee69e8c0e0a3a876041b11016b49f2cdffb711efa457ce4238b58b8cc4af986c87f7769fa8dd53c8840d8092791ee9609c10037b5c584a60812594088e901b0ee142fcd15d4d6e7f2821fde11078f227460688ca5c2c0134cedeca6466b898836d02da0bc886ed3133532c671f2e76fad83eb75be595c3fa27d3cb340f8050a5e0c0ff382a0561ca323f234a56562ceef57fcc034116fab9201b0bfa6ccc67cabba2a33e01c43d261ff5cda0608bfa79dee98d34894605bb8a6dd4ac9e5e0a2124b8f13b7b47f445dea737d84194b5024b9b4974393898f038609dbcd4e2025f4e70c240ec991cf47b555ff0a19355621dad4aa2ffe98ffde535673b66753ebfd660cbb6328928083b9bacfe9db262c303a6554e692e27e0ae463f4d5b0a1c4b5245a6093843c2950d4587beb416d64107b93d9f2861e560021b3a0c19487a93217db7c323c98172e6ef57e34b69a43d8acc36a7ff06e1081026074a949d3452d291a116b8386f54b85ee6756abd18ad9396e0462049cfc447ec0a4951600774be64639150cdcb0f9803ee48e2270f05a970a6556ed90b3c91c5b29848789dab8abe54d63178489ab91368749fd41587dfd74e21daf8508b0bdaeb8b4a0e586bb7cb3cacfa87d2a57f190148bc59765877fa244c7c220c604418574a06befe7436d4fb800b12451783630bd6992dcf8a80bbd7f90c4fa43edfc9b4f0284a0e8ff50de2fe5cd415748d77d682001e0bae13cd6b5e2b81b94db6068fc2556322bf274e46b7f349f9e685c5bde38df29159955ca2d8f14ee664af4d125aeac8729fc4667220b27902bebfa40e1c00f7e6a41e249779f5bf187d916c09bfa37d14e54da21bb99f1e477925a15dd54443c14defa8b49300f289168bf6c0d94ec64cdbb8c110fecf25b8351654deb358e2097d5e35915870ce47c79dca81cad052bed440b318dbb3fb6991cc190e89e22045e81f7727cc83cbf12c45848d2dcdeb09fd0b5bd27b0d7f49f922fb3333aab2c1eb94a28bdcf447e515c856b6151dcb182e3314c440133c36d7d1fbad110d4409a6b702a834c78b6c0760997860e9e315e3df43fe76c5e6cf8c466624484976b053b15c25302c7ddf9625c95213ee9408cf219651b13d2a3f2853233f9b518fa6dcaf465a04ae50e567742520761722a24dd219a8ba633280f54f72d4a790f280c4048afeef131d11f282385cdb8d643d43ed3e1316875ce009da3eeb6d9d5d3e09f96c6061aa3dcba26c355fb18af303403f872bbf30ec9aa89aebc2360972975a9c43f85119fcee3dfc451569983d0207b056f43ef9230ca5e3c3431507f9a2fe13ad6b58e6e7a2e8e5363a001fc0010c3486821855017a2c8cce22c9e614f49959328e9c3b8094a3c8255c2688e79598e74feb3a7e56291e82429a8e7b687908dae5c711a2b56b2b7d2ffa0391bb6d318d4804d6aff7f617c3b52918e7e19c7707c42e3cf1b4a46660043dace3a31607ea65f87e5d4c789beffac06e7e2c7a1849cd53406159f0c828077fa970b67afe33dc301e666b17860cb56caf0e4dbd2a1be2c925f1c928762f1da4e264b8c418d82f342f6cf8c6f417fb1c6585a1251b0a2a38ae38247aed62ab59029f51c93d5d11f0b216ec31c3a70be400b974482fb2819e4e5493fee8221293e44e682b6b95d6c09222bfd945b39fdd4fde70cc4cde083d2e2c414bcd09659afe98cab8b42724a1419d1ed498e5943ec9046b3c9ae2c9769074d74e657969a90eb5bae3941c37123a62d0032f44d7be2078044cad0bf37b483aab2463a3f1a8ba5fc18f9736a4c9bf19f6087b62850d7eb82714452ca97474e2cd24a5a07e2d522a7c18e0116ccf4180c44c3a2844f6a42b069d9bae20e330701bf53e87231d1b2cc428e61fb5c569a7a5e98b6752cc0dca0b98509de1c4facfc8397ab4a4e01242d645eea9143de9f202a107fe19fa5c3230b21380c3a8f9a94e469d897983b476202bbe73e703c18099b3f493a11bf53e1ce2836dd48b05f46164e4117dac472227a99255afd6a67daf832764d2d6c36416cf1654a7ae5fa3372bc9e651f7c498e9f14fac3adca0b3794aa843f3ed54fd07ecfb3c7fef5dc96eddd0b67f8da4129dfb3e1bd55e39d5e82708ed57b21e2538a6faa74b082e01eda8c23eb2e52c0f6f15d6c2786bbaf53acdc2e56b03c65c963630f798230be8ed20c3a682f0e7bda666d3f44e07b94dfa8112428c3bd1813e8b7636dd0d1ffd1cc7682fa8a1ddbe09526cd0b57f68a57ecc4863948df3b2740d6776a507d55be675e4125d8126ae512f8f53fa499c4cd3240236729058e055d8cf7f974e71cdad9a39aa9179e31309a89d5796264366928d3a8ab5248db0081a1d95b6aa0b65d81cee99ba38be3e37d4a8d47342bc92326303c6f3e86a6ae4d8fc6ad213be316be17b88767344ae7f866796c888c02b645918dfd35d631cbef07c1d53678ca6d1e6e0471091ea8c48a1f0700f52d14c1d4c5c2da8eb6346d87e0211f61fbf91307fccf20ee03b64c92f019112220b4480c10a9e5416137234bb44b02c76fca0676c2f83a820182043bdf1b1e19a8dac9fc06c51373a3ff9a6bdfdf3db8d2e041a657130543e7aa4c4b974cbb9b3145c6621b5498a3c9d448fd000abf0d3becb766778cebc844ab9ac53935157d655d14723373813e5b95664a143edc10d5f148526a624ed9ef9bf653a46a3a8847226c9e3ae3c78be41aed47bec10bf35c7d2e6dfa4b6e63411fa303055a8fa84fc5054c0ef1eccf213f1239be1f2caaa434053fbb2f11aa0d0f6e29e27c29c090ae68a43b270e1b67a1108307b0ea8649c66cc40e2cc7202343e4d8b018221eb83f85a5810539a8eae2c3fbd321ca9b18ce23a352141ad8194798e858e02c7b38a5a764ddcfbf0d0c531fc2aea5a335fa8a2aa846155c61181ecaae128fd684627ce23d5314018fc973c4e2fa1fe7d64f019f6a69738e60a20915d2a73c87921efb43b2a666695c616142bcbc256bd09a9b1a367de3fdcc44fc63b682c539a54c183957d2293447b75e6f60175eb81e8a317268e94e0234f11cf790525de37d432cd5c68ec28a7e5ed6f6f2e2c65841b9af4964b35f6b7daa6b074e2cb02288d731a7e0a3af0ddaf02423c1ccb6ff2b77b68779fe39ef3bacded37648f06e33dc5bc4d01ddc209fb9e0da062c85ab91215d1c4c94fdf5435c51f919530141f924e339af364245ddc67d0ae1fb513666f1467b6deb2377f388c2633e39e83e1f71cfb06743da3a422bee33ca67852e71995893884a33160cb33397b3b029821eb9b54946374977b0db8b0cf3f0b54565b61b6eceb57243dd0d0e13228dbacdde904b4c9f7b4a26704e673823d473658a3546c1c7a31c2c736398cef9fcfd743195d3cee4c21e40fab7c5006c5e793ab6bda3424b9ba1211b38156ff90bdaa9d39cef6df6aa30f4bb489cde3ace27a058d3f1a9231b0d3c323324af67631081ba8c5d320643fc757d3f5e4f01d353ef04857c1d5474a6e6cadc503df091c226747c9040063d842fcec065312839f7b4fddfb87ad9cc79020b6822ae3648a393d4242143f8a616f254089c7affb806bea3e9fbf4d355df98f0ead4d3365815e6d319c19af3b880767544bf9f27bc5ceb58cd2c77d5cc205801a7d8f144e169f326e671b95be123bbdd1fd721bdd045601e9426d4d4bf8bd99898ae5da7cfab955a6418eadba0e886df3032a44d9a60ed19a10ebc1b4358e30056e92e70426ff7178b6b5ce57c586a852a076f6172c412f25bfef5fc0da4f9abc38f95aebaa7411f4e55caac855d37fbcca8a029fd13eca40da0a389648fb07ced881e93260cfeafcc3b80de6ff0e374d592af1f17ccc24b5aeb7f48da0e8f7533501227b1755911065699ba778134efde18e709b6b7c06fe38af1db7d1ce94c7a8055cfbb059835e812029b32b2dc3f055405712735ce51e7225b68fe70175cda69ece02a2ada0a2dd5efd0ced464b1692873a192a85afdae937a76282712a265147e81673d8b5e8bde45a98387a5d9b6fa903a08b6a1d0d2b775d8ca5bcca29c81aa65b3fff767a0a2a5f501160332d920c1e42cbc939b5db7a7bd741dd077dd26be4b3d44d53a2074d87c40084fd6c2eabcc452991f8b9e7c5abbc12da060b3f0d5bc834f40e2a1783c912ac3de0bb2877b2d91acc54f87fdc287070cee715797f44ca1cedf9a6d23f141cf4ff21d91b392820d08f7f53776d36624aaf3b3da3dab1f984f38302cea81b717e8edd6e281679a26ea65b80696ea521385e3c4ed4225a9c25739460e308f236dd8e26b028f777eff86d239989de9c640fd3dd444934df9622549647f41fb83573cbea01b18ddbe77b4af7b8e4eb45540e516da0d67b8e796aceeee69c2b14cb205a22f59ef202c329b6c9b44c171d832d3e3d37ac41737d501bf0038fd923087f53bb59e72932a0c32c4aa7d3d9ce0d7deb4b3e628400ef205e01ccb6a2da9cc188abe45fcc18f85c65e7097c7b2854e81b4092a97a395d501f77c74e2ae2c44aa87dfec8dba73f06f194a769d7adc138abb5b763942026792bfeb6b21380a259e0673726219be58b24ad46e605d4a1fc98df79673733524e5c201c7998b9c832f69f44154337eb667f62613a51e4bc56b6fb0e73232ef5f73fe429501880428a33a463d89b820df0114d2eee39bca093ba79ec015e6e09f03130516393f551e759d1836de86bec4d5d8b31691a6619b19fadafaa0e2640adf44f397b5f163d9231d003d7ed312532dd62bd7d4ddee7fd453c60faca7e2f483cac5ced1fccf60f4ecb9d7329b7da6c7be7383a92bb588f096b2023c4d1b9ae56fac5239efc56d309eb57e4da1ac7238e4f4929423c04532e1c224e967e035b6c6ca43fb3a5f9255e0fec67f38b655ff9f99e79014258d08e9636b42eb769556b295204f81d502691e6cb88c8cce51c794a2fbd214f846521957c36308cc7be0ca01bc3189b76db9c2c2aaccd397f0bc48b3e23adf346f903189e0833326b463b236c9ff127f10c5e1169bf10dd75e07f2024b896459b50f872fe081f865a2c932d200e055100faf77200fc898e15abd9be2f0ec0a7d52225bc9c20e194b98db7a1e1c4b8fbc9dd142fc4f0d8f1374528a8863111a9be1aae156791f28b7cbf1be28a1097cb916700760779fa99a686d3fb41703670fa32c5deac4d488568f0dcd1264e5056389414d9291413a3bd99248bf913754bbbbfeb515186d06a993b4159615e83cecb921b2e0ef81af84f0fa8ed2f116b1362cf8fda5c2b269ae92efc986f74e75d60771894b3a409d2cdac9be9f9d706fbace81aae6baf001fd8aa0c56635288473da8c5a94e1ae299384d3a2463251d39bba9444560605f4c1f596662a5d98df665d0463f780bbe44ddbb418171754808bf336bba7d835c41e84c312cf9e5dd194f42bec79104abb10a83af99dec212d3fc65ed8f2716a21d5b22c1a49f0b5aa2e3379ba3414bdb902416d7791f53dfb5245957704f4b6319fa398f46fed806247d52e4ba6d3dd18f7a9cd88835b764078b452a1065a72f5589c2e308ca16b11705dcfe1b0d4dab5518005ac6acd57017c715c7983d985bfbf0e811962b3fd34cf63a887c1b23830ffa39cd65c5763c30aee756bdebf0f70a52058e227b862e95581ff68bcb09c47ca83a216a67600eb4e38140f42f7cd16b52b24913bd83a50a790a2e2a4214bcbdc61378151b5de36eb09eafe410336681e6dd1f2d3fb7627f84789f0b2e54f019a4c1c9855b17062fdaa712a2ac99b74a7d80013005840fec18f77bd246f9969bc13944fb135929e532bc1f4bb4f7ddd1b33828eede4bcfac2964b299ee4001c7f77fd91a62d7570370f144adfe84f90fb106fd36da0ce86771062bf88f1062456c79e2a802c1b3f57343ef584e0840cec3b871faa15e062c6a8ceb97f106dc5e0ed93e09d1faff4034d5231f75c62a0c1a17c230e7a07920867971d8e201dbbfcd1f3973b3a10d6618ec5f46b1394ea14d49d4fb3c2be29b6a511ed4e4dc2ef5417b3ab03f3c08b2e6a5ed9dc7912ef239cff6d017c087ceee7ecaa67f0ecf7447e74492a538b526a56d4da312e7cbe2db765014dc1c2c4b1d84a71bd61966941baf35a6cc292f1faa9e458bcc0780e0779c9e97445bdc3633f1338173f0c3b466ca4fd8b31a1d8633a5c7956741d17084e4e8aee714152ac2582f4f571a2540def1a310c99a1150f75cfbcbec20afd670ff26ca7e2dcd51b1a1e5c2d532ce8d443549dc4b171022dd12024977f592475a9b2b3ada3e70b190cb557e195cfad027b1d3a85120a387940713771e47fefb6eaa658f537d3c52fc9cbdb6d5a905d185345a9b8b3d1d6c5bfcc6dd0270bffceab873ea806bf68f58e3529af2a2f8e80b9e777cff6b09a1435c938f5540466c8a4716b3352bc307346b54a2455ff45e441058846f915ba2540e8d079d4cc263c144c4f1226feb4d8a9878ed79dc5b86c1d786ef2f4994bb4f49804c3433727983a756ce1a727edb4060da01773d6bf309e2b5d1bc2af26e20284a477eec2bd8923ed72ff10bcb6d8bffee1150f00674f7860c3abba49823642b81d07cd4728e7052e6bd511ef92fb0e7aac4ff6717debfa8d58a1f6a4431b31070f3297bc8b3a989a504d353a2413449abe4f9cf95385ebabf9453933826125c0d40bed03fb35e8affd760f0546988158aad11714474a57fa17ef8fbc3eff3cbb43451625fa15d5d5de18a4def546448077c93bd09ef334132bbcdb39a7a0dbb339b15c95d40c45dd90b0da820743367efc0cc5e58e9501102cb03401b9b04b25087ffba1ba6856e21bb9abfe2d5284b8d56bfef8fbee08952e9b0582c4957991fb2fdb840e8c5ef4366f57db4909b003327bfe1b5dda4343e7c0b6c7a0e73f8e16b5ce38282ce8767efbd0c593412f6f21d6f3511b3166b118d3c24f15ca98766d19e73a26d12e723bcda3f13dbdadc18e3a6e7e17b4a5898a38335b9598ebf1caca4e3738e51d69ddef54d90a843af602e7cf467e7c1a10f64ac38237acd2bc09d63f7d25afb3ea0112f0d0926aa535f0015c7a88a5552694cb4b8644a15355a11d0d922c4b366d15f0ca9e848b3b35e4317c0b1ee913fc0fa2fbebd12beaefda5098f1d95a1caa66cf7694fe53a43a9d851b53304efcd59fe96ac4d94fc4874fecfdaba5af3bcd1ba11062f45102d7f4ba2b7e5ce3f177e25fc696df6de1922eb585ea609aed5c3c7204794b61edb1b4f3eaf74e1846306b66bad80362cb54c2a0f721fd974d3f56e1366d902b4d8bd8fb15643f942471a12748eac2ed0cadf0ba31c3099d49e504db6bc60716c18ad254cc79f38ef876e96889c1b93f4a27eea1db7cffdc685df71f95d23786672f26a582c483ffc3d4b50857f7678f828ded957fe65cee1386566c7fdf4f474da9a92414e8fdf1b8287141ccf7548e4902d06bbc7b9c3489c850fe9f20427bac5b16680565ae40fa14069acce9828eeac604a363979c42c3b2cf89e4f9f477b42ba5e0b71118a298e9bc8ce2e8387afc39e306ac76d6a43de42e4f960c1ad6f9cf1e17516be64b66221f166cf666507cb0e06923599162f12696791b4fa8400e051ad6be212070cb5981cd330bc4dc49785481a71efdc674d7cfe1e2ca93adca10990d9c0563e3a9d72107b27b7830edb287f0d8bfd5e49e367a3e8222d4ffa45e525df52d2d000696de26f272bb4419952f395a78040d8331be3ff9af4f738224d079a66ed45b2e2911c10b340edd645938fa40d4feb46868316fd8b59a52268ec1cc95da590b75834d03f5bc222cbc7bd89d286173bdc7ee15627eaa96914c65a6711b83387520fae6d84f69b51726e01b415a160a970a89342319a24f94c171fc164f830bb289294b7189ab6cf661a5730796f179166bb44569d1749ed0f14b0e173456f5ed53a92fafcc8f13e2e99ff43d28789bcf15f6d1045b1e7a5b5017aa4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你的通行证呢，点击此处输入试试噢🫣</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 加密文章 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
